<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<!--
This document was converted from RTF source: 
By rtftohtml 4.19
See http://www.sunpack.com/RTF
Filename:TIJ2.rtf
Application Directory:c:\TOOLS\RTF2HTML\
Subject:
Author:Bruce Eckel
Operator:Bruce Eckel
Document Comments:
Version Comments:
Comments:
Keywords:
Translation Date:04/24/2000
Translation Time:06:35:53
Translation Platform:Win32
Number of Output files:23
This File:Chapter05.html
SplitDepth=1
SkipNavPanel=1
SkipLeadingToc=1
SkipTrailingToc=1
GenContents=1
GenFrames=1
GenIndex=1
-->
<HEAD lang="ru"><META http-equiv="Content-Type" content="text/html; charset=windows-1251">
<TITLE>5: Скрытие реализации</TITLE>
</HEAD>

<BODY  BGCOLOR="#FFFFFF">
 
  <CENTER>
    <H2><FONT FACE="Verdana">
  Thinking in Java, 2nd edition, Revision 11</FONT></H2>
  <H3><FONT FACE="Verdana">&copy;2000 by Bruce Eckel</FONT></H3>
  
    <FONT FACE="Verdana" size = "-1"> [ <a href="Chapter04.html">Предыдущая глава</a> 
    ] [ <a href="SimpleContents.html">Оглавление</a> ] [ <a href="Contents.html">Содержание</a> 
    ] [ <a href="DocIndex.html">Индекс</a> ] [ <a href="Chapter06.html">Следующая 
    глава</a> ] </FONT> 
  </CENTER>
  <p></P><A NAME="Chapter_5"></A><A NAME="_Toc375545290"></A><A NAME="_Toc477690725"></A><A NAME="_Toc481064588"></A><A NAME="Heading189"></A><FONT FACE = "Verdana">
<H1 ALIGN="LEFT"> 5: Скрытие реализации</H1>
</FONT> 
<P><FONT FACE="Georgia" SIZE=4>Основным обсуждением в объектно-ориентированном 
  программировании является &#8220;отделение вещей, которые меняются, от тех, 
  которые не меняются.&#8221;</FONT><BR>
</P>
<P><FONT FACE="Georgia">Это очень важно для библиотек. Пользователь (<I>клиентский 
  программист<A NAME="Index464"></A></I>) этой библиотеки должен полагаться на 
  ту часть библиотеки, которую он использует, и знать, что ему не нужно будет 
  снова переписывать код, как только выйдет новая версия этой библиотеки. С другой 
  стороны, создатель библиотеки<A NAME="Index465"></A> должен иметь свободу модификаций 
  и расширений, и быть уверенным, что эти изменения не повлияют на работу кода 
  клиентского программиста.</FONT><BR>
</P>

  
<P><FONT FACE="Georgia">Все это может быть достигнуто с помощью соглашений. Например, 
  программист библиотеки должен оставлять существующие методы при модификации 
  класса в библиотеке, т.к. это может нарушить работу кода клиентского программиста. 
  Обратная ситуация гораздо сложнее. В случае с членами данных, как создатель 
  библиотеки узнает, какие члены данных используются клиентским программистом? 
  Это также верно для методов, которые являются частью класса и не используются 
  напрямую клиентским программистом. А что, если создатель библиотеки хочет удалить 
  старую реализацию и поместить новую? Изменение любого из этих методов может 
  нарушить работу кода клиентского программиста. Получается, что программист находится 
  в весьма затруднительном положении и не может ничего изменить.</FONT><BR>
  </P>
 
  
<P><FONT FACE="Georgia">Для решения этой проблемы, Java предоставляет <A NAME="Index466"></A><A NAME="Index467"></A><i>спецификаторы 
  доступа</i> для того, чтобы создатель библиотеки мог сказать что доступно клиентскому 
  программисту, а что нет. Уровни контроля <A NAME="Index468"></A>доступа от &#8220;полного&#8221; 
  до &#8220;минимального&#8221; определяются с помощью ключевых слов: <A NAME="Index469"></A>публичный 
  - <B>public</B>, защищенный - <B>protected</B>, дружественный - &#8220;<A NAME="Index470"></A>friendly&#8221; 
  (не имеет ключевого слова) <A NAME="Index471"></A>и<B> <A NAME="Index472"></A></B>приватный 
  - <B>private</B>. Из предыдущего параграфа Вы можете посчитать, что как <A NAME="Index473"></A><A NAME="Index474"></A>разработчик 
  библиотеки, Вы будете хранить все, что возможно как &#8220;private&#8221;, и 
  раскрывать только те методы, которые Вы хотите предоставить клиентскому программисту. 
  Это абсолютно верно, хотя это бывает трудно понимать людям, программирующим 
  на других языках (особенно на C), которые имеют доступ ко всему, без ограничений. 
  К концу этой главы Вы поймете, насколько большое значение имеет контроль доступа 
  в Java.</FONT><BR>
  </P>


  
<P><FONT FACE="Georgia">Однако, концепция библиотеки компонент и контроля доступа 
  к ним это еще не все. Существует вопрос - как хранить вместе связанные компоненты 
  в модуле библиотеки. В Java это реализуется с помощью ключевого слова <B>package</B> 
  (пакет), и спецификаторы доступа действуют в зависимости от того, находится 
  ли класс в том же пакете или нет. Итак, в начале этой главы Вы узнаете, как 
  размещать компоненты библиотеки в пакетах. А затем, Вы сможете понять значение 
  спецификаторов доступа.</FONT><A NAME="_Toc375545291"></A><A NAME="_Toc481064589"></A><BR>
  </P>
<A NAME="Heading190"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> package: модуль библиотеки</H2>
</FONT>

  <P><FONT FACE="Georgia"> <A NAME="Index475"></A>Пакет это что Вы используете, 
    когда пишете ключевое слово <A NAME="Index476"></A><B>import</B> для подключения 
    целой библиотеки, такой как</FONT><BR>
  </P>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>import</font> java.util.*;</PRE></FONT></BLOCKQUOTE>
 
  
<P><FONT FACE="Georgia">Это включает в программу библиотеку <a name="Index477"></a>утилит, 
  которая является частью стандартной поставки Java. Например, класс <B>ArrayList</B> 
  находится в <B>java.util</B>, и Вы можете также указать полное имя <B>java.util.ArrayList</B> 
  (которое Вы можете использовать без выражения <B>import</B>), либо просто написать 
  <B>ArrayList</B> (при использовании <B>import</B>).</FONT><BR>
  </P>


  <P><FONT FACE="Georgia">Если Вы хотите включить единичный класс, Вы можете указать 
    этот класс в выражении <B>import</B></FONT><BR>
  </P>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>import</font> java.util.ArrayList;</PRE></FONT></BLOCKQUOTE>

  <P><FONT FACE="Georgia">После этого, Вы можете использовать <B>ArrayList</B> 
    без ограничений. Однако, никакие другие классы из пакета <B>java.util</B> 
    не будут доступны.</FONT><BR>
  </P>
 
  <P><FONT FACE="Georgia">Использование импорта обусловлено необходимостью управления 
    &#8220;<A NAME="Index478"></A>пространством имен.&#8221; Имена всех членов 
    класса изолированы друг от друга. Метод <B>f(&#160;)</B> внутри класса <B>A</B> 
    не будет <A NAME="Index479"></A>конфликтовать с методом <B>f(&#160;)</B> которой 
    имеет такую же сигнатуру (список аргументов) в классе <B>B</B>. А что же насчет 
    имен классов? Представьте, что Вы создаете класс <B>stack</B> и устанавливаете 
    на машине, на которой уже есть класс <B>stack,</B> написанный кем-то другим? 
    С Java в интернете такое вполне может произойти, и Вы об этом можете не узнать, 
    т.к. классы часто загружаются автоматически в процессе запуска Java-приложения.</FONT><BR>
  </P>


  <P><FONT FACE="Georgia">Из-за появления возможных конфликтов важно иметь полный 
    контроль над пространством имен в Java, а также, иметь возможность создавать 
    абсолютно уникальные имена.</FONT><BR>
  </P>

  
<P><FONT FACE="Georgia">До сих пор, большинство примеров в этой книге существовали 
  в единичном файле и проектировались для локального использования, без упоминания 
  о пакетах. (В этом случае класс располагался в &#8220;пакете по умолчанию.&#8221;) 
  Ради упрощения такой подход будет использоваться, где это возможно, в оставшейся 
  части книги. Однако, если Вы планируете создавать библиотеки и программы которые 
  будут дружественными для других программ на Java на той же машине, Вам нужно 
  будет подумать о предотвращении конфликтов с именами классов.</FONT><BR>
  </P>

  
<P><FONT FACE="Georgia">Когда Вы создаете файл исходного текста в Java, он обычно 
  называется <A NAME="Index480"></A><I>модулем компиляции</I> (иногда <A NAME="Index481"></A><I>модулем 
  трансляции</I>). Каждый модуль компиляции должен иметь расширение <B>.java</B>, 
  и внутри него может быть расположен публичный класс, который должен иметь имя 
  такое же, как имя файла (учитывая регистры, но без расширения <B>.java</B>). 
  В каждом модуле компиляции может быть только<I> один</I> <A NAME="Index482"></A><A NAME="Index483"></A>публичный 
  класс, в противном случае, компилятор будет недоволен. Остальные классы в этом 
  модуле компиляции, если они есть, скрыты от мира за пределами этого пакета, 
  т.к. они не публичные, и представляют классы &#8220;поддержки&#8221; для главного 
  публичного класса.</FONT><BR>
  </P>

  
<P><FONT FACE="Georgia">Когда Вы компилируете файл <B>.java</B> Вы получаете выходной 
  файл с точно таким же именем и расширением <B>.class</B> <I>для каждого класса 
  в файле </I><B>.java</B>. Таким образом, из нескольких <b>.java</b> файлов Вы 
  получаете несколько <b>.class</b> файлов. Если Вы работали с компилирующими 
  языками, то Вы, возможно, получали от компилятора выходные файлы (обычно это 
  &#8220;obj&#8221; файлы), которые, затем, объединялись вместе с другими файлами 
  такого же типа с помощью линкера (для создания исполняемого файла) либо генератора 
  библиотеки (для создания библиотеки). Но Java работает не так. Работающая программа 
  это набор <B>.class</B> файлов, которые могут быть собраны в пакет и запакованы 
  в <A NAME="Index484"></A><A NAME="Index485"></A>JAR файл (с помощью Java архиватора 
  <B>jar</B>). А интерпретатор Java способен находить, загружать и интерпретировать 
  эти файлы</FONT><A NAME="fnB32" HREF="#fn32">[32]</A><FONT FACE="Georgia">.</FONT><BR>
  </P>

  
<P><FONT FACE="Georgia">Библиотека это также набор <b>.class</b> файлов. Каждый 
  файл содержит один публичный класс (Вас не заставляют иметь публичный класс, 
  но это типичная ситуация), так что для каждого файла есть один компонент. Если 
  Вы хотите чтобы все эти компоненты хранились вместе (из различных <B>.java </B>и 
  <B>.class </B>файлов), Вы используете ключевое слово <B>package</B>.</FONT><BR>
  </P>

  <P><FONT FACE="Georgia">Когда Вы пишите:</FONT><BR>
  </P>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>package</font> mypackage;</PRE></FONT></BLOCKQUOTE>
 
  
<P><FONT FACE="Georgia">в начале файла (если Вы используете выражение <B>package</B>, 
  перед ним могут быть только комментарии), этим Вы указываете, что этот модуль 
  компиляции является частью библиотеки с названием <B>mypackage</B>. Или, другими 
  словами, Вы говорите, что публичный класс внутри этого модуля компиляции скрыт 
  под именем <B>mypackage</B>, и если кто-то захочет использовать этот класс он 
  должен либо указать имя пакета, либо использовать ключевое слово <B>import</B> 
  вместе с <B>mypackage</B> (используя варианты, показанные ранее). Заметьте, 
  что в Java есть соглашение для имен пакетов, это - использование символов только 
  нижнего регистра, даже для внутренних слов.</FONT><BR>
  </P>


  <P><FONT FACE="Georgia">Например, предположим, что имя файла - <B>MyClass.java</B>. 
    Это значит, что может быть только один публичный класс в этом файле, и имя 
    этого класса должно быть - <B>MyClass</B> (включая регистры):</FONT><BR>
  </P>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>package</font> mypackage;
<font color=#0000ff>public</font> <font color=#0000ff>class</font> MyClass {
  <font color=#009900>// . . .</font></PRE></FONT></BLOCKQUOTE>

  
<P><FONT FACE="Georgia">Теперь, если кто-то хочет использовать класс <B>MyClass</B> 
  или любой другой публичный класс из пакета <B>mypackage,</B> ему нужно будет 
  использовать ключевое слово <B>import</B> чтобы сделать доступными имена из 
  пакета <B>mypackage</B>. Существует также альтернатива - использование имен 
  с префиксами:</FONT><BR>
  </P>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>mypackage.MyClass m = <font color=#0000ff>new</font> mypackage.MyClass();</PRE></FONT></BLOCKQUOTE>

  <P><FONT FACE="Georgia">А ключевое слово <B>import</B> может это упростить:</FONT><BR>
  </P>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>import</font> mypackage.*;
<font color=#009900>// . . . </font>
MyClass m = <font color=#0000ff>new</font> MyClass();</PRE></FONT></BLOCKQUOTE>

  
<P><FONT FACE="Georgia">Это стоит запомнить, т.к. с помощью ключевых слов <B>package</B> 
  и <B>import</B>, Вы можете, как разработчик библиотеки, разделять глобальное 
  пространство имен, и, в результате, исключить конфликт имен, не зависимо от 
  того, сколько людей подключаются к интернет и начинают писать классы на Java.</FONT><A NAME="_Toc375545292"></A><A NAME="_Toc481064590"></A><BR>
  </P>
<A NAME="Heading191"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Создание уникальных имен пакетов</H3>
</FONT>
 
  
<P><FONT FACE="Georgia">Обратите внимание, что пакет, на самом деле, не всегда 
  располагается в единичном файле, и может быть собран из большого количества 
  <B>.class</B> файлов - и, в результате, получится небольшой беспорядок. Чтобы 
  не допустить этого, по логике вещей, нужно поместить все <B>.class</B> файлы 
  в один пакет и в отдельный каталог, с помощью иерархии файловой структуры Вашей 
  операционной системы. Это один из способов - как Java решает проблему нагромождения 
  файлов; С другим способом Вы познакомитесь позже, когда будет описана утилита 
  <B>jar</B>. <A NAME="Index486"></A><A NAME="Index487"></A></FONT><BR>
  </P>

 
  
<P><FONT FACE="Georgia">Сборка файлов пакета в отдельном каталоге решает две другие 
  проблемы: создания уникальных имен пакета, и поиска тех классов, которые могут 
  быть скрыты где угодно в структуре каталогов. Это достигается, как было описано 
  в Главе 2, с помощью указания пути к <B>.class</B> файлу в имени пакета, после 
  ключевого слова <B>package</B>. Компилятор навязывает именно такую форму, но 
  по соглашению, первая часть имени пакета зарезервирована - это доменное имя 
  создателя класса в интернет. Поскольку доменные имена в интернете гарантированно 
  являются уникальными, то, следуя этому соглашению, Вы гарантированно получаете 
  уникальные имена пакетов и никогда получите конфликта имен. (Во всяком случае, 
  пока Вы не отдадите это доменное имя кому-нибудь другому, кто начнет писать 
  классы на Java с теми же именами путей, что и у Вас.) Конечно, если у Вас нет 
  доменного имени, Вам придется придумать невероятную комбинацию (например, как 
  Ваши имя и фамилия), для создания уникального имени пакета. Но если Вы решите 
  опубликовывать код на Java, Вам стоит немного напрячься и получить собственное 
  доменное имя.</FONT><BR>
  </P>


  
<P><FONT FACE="Georgia">Также необходимо расположение пакета в отдельном каталоге 
  на Вашей машине. Когда Java программа запустится и потребует загрузки <A NAME="Index488"></A><A NAME="Index489"></A><B>.class</B> 
  файла (что делается динамически, в том месте программы где создается объект 
  соответствующего класса, либо впервые Вы получаете доступ к статическому члену 
  класса), она сможет определить расположение каталога, где находятся <B>.class 
  </B>файлы.</FONT><BR>
  </P>

  
<P><FONT FACE="Georgia">Интерпретатор Java действует следующим образом. Сначала, 
  он ищет переменную среды с именем <A NAME="Index490"></A>CLASSPATH (она устанавливается 
  в операционной системе программой установки Java, либо инструментами, основанными 
  на Java, на Вашей машине). CLASSPATH содержит один или более каталогов, которые 
  используются как корневые для поиска <B>.class</B> файлов. Начиная с этого корневого 
  каталога, интерпретатор берет имя пакета и заменяет каждую точку на косую черту 
  для создания имени пути от корня в CLASSPATH (так, например, <B>package foo.bar.baz</B> 
  превратится в <B>foo\bar\baz </B>или <B>foo/bar/baz </B>а, может быть, что-то 
  другое, в зависимости от Вашей операционной системы). Затем это добавляется 
  к различным элементам переменной CLASSPATH. Вот как интерпретатор ищет <B>.class</B> 
  файлы, с именем класса, который Вы пытаетесь создать. (Он также производит поиск 
  в стандартных каталогах, относительно того, где располагается сам интерпретатор).</FONT><BR>
  </P>

  
<P><FONT FACE="Georgia">Чтобы понять это, давайте рассмотрим мое доменное имя 
  - <B>bruceeckel.com</B>. Резервируя его - <B>com.bruceeckel</B> - создаем уникальное 
  глобальное имя для моих классов. (Имена com, edu, org, и т.д., раньше писались 
  с заглавными буквами в пакетах Java, однако это изменилось в Java 2, так что 
  сейчас имя пакета должно быть написано полностью в нижнем регистре.) Теперь 
  если я хочу создать библиотеку с именем <B>simple</B>, у меня получится следующее 
  имя пакета:</FONT><BR>
  </P>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>package</font> com.bruceeckel.simple;</PRE>
  </FONT><FONT FACE="Georgia">Теперь это имя пакета может быть использовано, как 
  прикрытие для пространства имен у следующих двух файлов:</FONT><BR>
</BLOCKQUOTE>


<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: com:bruceeckel:simple:Vector.java</font>
<font color=#009900>// Создание пакета.</font>
<font color=#0000ff>package</font> com.bruceeckel.simple;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Vector {
  <font color=#0000ff>public</font> Vector() {
    System.out.println(
      <font color=#004488>"com.bruceeckel.util.Vector"</font>);
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>

  <P><FONT FACE="Georgia">Когда Вы создадите пакет, Вы обнаружите, что выражение 
    <B>package</B> должно быть первой строкой кода после комментариев в файле. 
    Второй файл выглядит следующим образом:</FONT><BR>
  </P>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: com:bruceeckel:simple:List.java</font>
<font color=#009900>// Создание пакета.</font>
<font color=#0000ff>package</font> com.bruceeckel.simple;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> List {
  <font color=#0000ff>public</font> List() {
    System.out.println(
      <font color=#004488>"com.bruceeckel.util.List"</font>);
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>

  <P><FONT FACE="Georgia">Оба этих файла располагаются в подкаталоге на моей машине:</FONT><BR>
  </P>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>C:\DOC\JavaT\com\bruceeckel\simple</PRE></FONT></BLOCKQUOTE>

  <P><FONT FACE="Georgia">Если Вы вернетесь назад, то увидите имя пакета <B>com.bruceeckel.simple</B>. 
    А что же насчет первой части пути? Об этом заботится переменная CLASSPATH, 
    которая, на моей машине, содержит следующее значение:</FONT><BR>
  </P>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>CLASSPATH=.;D:\JAVA\LIB;C:\DOC\JavaT</PRE></FONT></BLOCKQUOTE>

  <P><FONT FACE="Georgia">Вы видите, что CLASSPATH содержит несколько альтернативных 
    путей поиска. </FONT><BR>
  </P>
 
  <P><FONT FACE="Georgia">Однако, при использовании JAR файлов, есть небольшая 
    разница. Вы должны указывать имя JAR файла в CLASSPATH, а не только путь к 
    нему. Так, для <A NAME="Index491"></A>JAR файла <B>grape.jar,</B> Ваша переменная 
    CLASSPATH может содержать:</FONT><BR>
  </P>


<BLOCKQUOTE><FONT SIZE = "+1"><PRE>CLASSPATH=.;D:\JAVA\LIB;C:\flavors\grape.jar</PRE></FONT></BLOCKQUOTE>
 
  
<P><FONT FACE="Georgia">Как только переменная CLASSPATH корректно установлена, 
  следующий файл может располагаться в любом каталоге:</FONT><BR>
  </P>


<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c05:LibTest.java</font>
<font color=#009900>// Использует библиотеку.</font>
<font color=#0000ff>import</font> com.bruceeckel.simple.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> LibTest {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Vector v = <font color=#0000ff>new</font> Vector();
    List l = <font color=#0000ff>new</font> List();
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>

  <P><FONT FACE="Georgia">Когда компилятор встречает выражение <B>import</B>, 
    он начинает поиск с каталогов, указанных в CLASSPATH, там ищет подкаталог 
    com\bruceeckel\simple, а затем, откомпилированный файл с соответствующим именем 
    (<B>Vector.class</B> для <B>Vector</B> и <B>List.class</B> для <B>List</B>). 
    Обратите внимание, что оба класса и необходимые методы в <B>Vector</B> и <B>List</B> 
    должны быть публичными.</FONT><BR>
  </P>

  
<P><FONT FACE="Georgia">Установка переменной CLASSPATH стало как бы испытанием 
  для новичков в Java (так было и для меня, когда я начинал), хотя JDK в Java 
  2 от Sun стал более умным. Вы увидите, что, после установки, даже если Вы не 
  установили переменную CLASSPATH, Вы сможете компилировать и запускать основные 
  программы на Java. Однако, для компиляции и запуска исходных кодов из этой книги 
  (доступных на CD ROM поставляющемся вместе с книгой, либо на <I>www.BruceEckel.com</I>), 
  Вам нужно будет сделать некоторые модификации переменной CLASSPATH (которые 
  описываются в пакете исходных кодов).</FONT><BR>
</P>
<A NAME="Heading192"></A><FONT FACE = "Verdana">
<H4 ALIGN="LEFT"> Коллизии</H4>
</FONT>
 
  <P><FONT FACE="Georgia">Что произойдет, если две библиотеки импортируются с 
    помощью * и содержат одинаковые <A NAME="Index492"></A><A NAME="Index493"></A>имена? 
    Например, предположим, что в программе есть следующие строки:</FONT><BR>
  </P>


<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>import</font> com.bruceeckel.simple.*;
<font color=#0000ff>import</font> java.util.*;</PRE></FONT></BLOCKQUOTE>

  
<P><FONT FACE="Georgia">Т.к. <B>java.util.*</B> также содержит класс <B>Vector</B>, 
  это приведет к потенциальной коллизии. Однако, пока Вы не пишете код, который 
  может вызвать коллизию, все будет в порядке, и это хорошо, т.к. в противном 
  случае, Вам придется очень много печатать на клавиатуре, чтобы предотвратить 
  возможную коллизию.</FONT><BR>
  </P>

  
<P><FONT FACE="Georgia">Коллизия <i>произойдет, </i>если Вы попробуете создать 
  класс <B>Vector</B>:</FONT><BR>
  </P>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Vector v = <font color=#0000ff>new</font> Vector();</PRE></FONT></BLOCKQUOTE>

  
<P><FONT FACE="Georgia">Какой из классов <B>Vector</B> должен здесь участвовать? 
  Этого не знает ни компилятор, ни читатель. Так что, компилятор выразит недовольство 
  и заставит Вас быть более точным. Если Вам нужен стандартный класс Java, например, 
  <B>Vector</B>, Вы можете написать:</FONT><BR>
  </P>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>java.util.Vector v = <font color=#0000ff>new</font> java.util.Vector();</PRE></FONT></BLOCKQUOTE>

  <P><FONT FACE="Georgia">Поскольку такая форма (совместно с CLASSPATH) полностью 
    определяет положение этого класса <B>Vector</B>, нет потребности в выражении 
    <B>import java.util.*</B>, пока Вы не захотите использовать что-нибудь еще 
    из <B>java.util</B>.</FONT><A NAME="_Toc375545293"></A><A NAME="_Toc481064591"></A><BR>
  </P>
<A NAME="Heading193"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Библиотека инструментов пользователя<A NAME="COM_EckelObjects_tools"> 
  </A></H3>
</FONT>

  <P><FONT FACE="Georgia">С помощью этих знаний, Вы сейчас сможете создать свои 
    собственные библиотеки инструментов, чтобы уменьшить, либо полностью исключить 
    дублирование кода. Вот пример - создание псевдонима для <B>System.out.println(&#160;)</B>, 
    чтобы уменьшить объем печати. Это может стать частью пакета с названием <B>tools</B>:</FONT><BR>
  </P>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: com:bruceeckel:tools:P.java</font>
<font color=#009900>// P.rint &amp; P.rintln сокращения.</font>
<font color=#0000ff>package</font> com.bruceeckel.tools;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> P {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> rint(String s) {
    System.out.print(s);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> rintln(String s) {
    System.out.println(s);
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>

  <P><FONT FACE="Georgia">Вы можете использовать эти сокращения для печати <B>String</B> 
    либо с новой строки (<B>P.rintln(&#160;)</B>), либо на текущей строке (<B>P.rint(&#160;)</B>).<A NAME="AAASpellcheck"></A></FONT><BR>
  </P>

  <P><FONT FACE="Georgia">Как Вы можете догадаться, этот файл должен располагаться 
    в одном из каталогов, указанных в CLASSPATH плюс <B>com/bruceeckel/tools</B>. 
    После компиляции файл <B>P.class</B> может использоваться где угодно в Вашей 
    системе после выражения <B>import</B>:</FONT><BR>
  </P>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c05:ToolTest.java</font>
<font color=#009900>// Использует библиотеку инструментов.</font>
<font color=#0000ff>import</font> com.bruceeckel.tools.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ToolTest {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    P.rintln(<font color=#004488>"Available from now on!"</font>);
    P.rintln(<font color=#004488>""</font> + 100); <font color=#009900>// Приводит к типу String</font>
    P.rintln(<font color=#004488>""</font> + 100L);
    P.rintln(<font color=#004488>""</font> + 3.14159);
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>

  <P><FONT FACE="Georgia">Обратите внимание, что все объекты могут быть преобразованы 
    в представление <B>String</B> простой установкой их в выражение вместе с объектом 
    <B>String</B>; в примере выше, это делается с помощью помещения пустой строки 
    в начале выражения <B>String</B>. Однако, есть небольшое замечание. Если Вы 
    вызываете <B>System.out.println(100)</B>, это работает без приведения к типу 
    <B>String</B>. Конечно, Вы можете, используя перегрузку, заставить класс <B>P</B> 
    делать то же самое (это упражнение представлено в конце этой главы).</FONT><BR>
  </P>

  <P><FONT FACE="Georgia">Итак, начиная с этого момента, как только у Вас появляется 
    новая полезная утилита, Вы вполне можете добавить ее в каталог <B>tools</B>. 
    (Либо в Ваш собственный каталог <B>util</B> или <B>tools</B>.)</FONT><A NAME="_Toc375545294"></A><A NAME="_Toc481064592"></A><BR>
  </P>
<A NAME="Heading194"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Использование импорта для изменения поведения</H3>
</FONT>
 
  <P><FONT FACE="Georgia">В языке C существует <i>условная компиляция,</i> которая 
    позволяет устанавливать различное поведение Вашего кода без изменения самого 
    кода. В Java такой возможности нет. Причина, по которой эта функция отсутствует 
    в Java, возможно в том, что в языке C эта функция в основном использовалась 
    для создания кросс-платформенных приложений: компилировались различные куски 
    кода, в зависимости от платформы, на которой они работали. Поскольку Java 
    автоматически поддерживает кросс-платформенность, необходимости в такой функции 
    нет.</FONT><BR>
  </P>


  
<P><FONT FACE="Georgia">Однако, есть и другая необходимость в условной компиляции. 
  Самое распространенное использование - отладочный код. Отладка включается в 
  процессе разработки, и отключается в конечном продукте. Аллен Холуб (Allen Holub) 
  (<I>www.holub.com</I>) предложил идею - использования пакетов, для имитации 
  условной компиляции. Он использовал это для создания Java-версии очень полезного 
  <i>механизма контроля</i> (assertion) из языка C, с помощью которого Вы можете 
  сказать &#8220;это должно быть истинно&#8221; либо &#8220;это должно быть ложно&#8221; 
  и, если выражение не удовлетворяет этому контролю, Вы узнаете об этом. Такой 
  инструмент является очень полезным во время отладки.</FONT><BR>
  </P>

  <P><FONT FACE="Georgia">Вот класс, который Вы можете использовать для отладки:</FONT><BR>
  </P>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: com:bruceeckel:tools:debug:Assert.java</font>
<font color=#009900>// Инструмент контроля для отладки.</font>
<font color=#0000ff>package</font> com.bruceeckel.tools.debug;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Assert {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> perr(String msg) {
    System.err.println(msg);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>final</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> is_true(<font color=#0000ff>boolean</font> exp) {
    <font color=#0000ff>if</font>(!exp) perr(<font color=#004488>"Assertion failed"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>final</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> is_false(<font color=#0000ff>boolean</font> exp){
    <font color=#0000ff>if</font>(exp) perr(<font color=#004488>"Assertion failed"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>final</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  is_true(<font color=#0000ff>boolean</font> exp, String msg) {
    <font color=#0000ff>if</font>(!exp) perr(<font color=#004488>"Assertion failed: "</font> + msg);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>final</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  is_false(<font color=#0000ff>boolean</font> exp, String msg) {
    <font color=#0000ff>if</font>(exp) perr(<font color=#004488>"Assertion failed: "</font> + msg);
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>

  <P><FONT FACE="Georgia">Этот класс просто инкапсулирует булевские тесты, и печатает 
    сообщение об ошибке, если эти тесты завершаются неудачно. В Главе 10, Вы познакомитесь 
    с более изощренным инструментом для борьбы с ошибками, называемым <I>обработка 
    исключений</I>, а пока метод <B>perr(&#160;)</B> будет отлично работать.</FONT><BR>
  </P>

  <P><FONT FACE="Georgia">Результат отправляется на консоль в поток <I>стандартных 
    ошибок</I> - <B>System.err</B>.</FONT><BR>
  </P>

  <P><FONT FACE="Georgia">Когда Вам необходимо использовать этот класс, Вы добавляете 
    одну строку в свою программу:</FONT><BR>
  </P>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>import</font> com.bruceeckel.tools.debug.*;</PRE></FONT></BLOCKQUOTE>

  <P><FONT FACE="Georgia">Для отключения этого контроля, Вы можете использовать 
    код, где реализован второй класс <B>Assert</B>, находящийся в другом пакете:</FONT><BR>
  </P>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: com:bruceeckel:tools:Assert.java</font>
<font color=#009900>// Отключение контроля </font>
<font color=#0000ff>package</font> com.bruceeckel.tools;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Assert {
  <font color=#0000ff>public</font> <font color=#0000ff>final</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> is_true(<font color=#0000ff>boolean</font> exp){}
  <font color=#0000ff>public</font> <font color=#0000ff>final</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> is_false(<font color=#0000ff>boolean</font> exp){}
  <font color=#0000ff>public</font> <font color=#0000ff>final</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  is_true(<font color=#0000ff>boolean</font> exp, String msg) {}
  <font color=#0000ff>public</font> <font color=#0000ff>final</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  is_false(<font color=#0000ff>boolean</font> exp, String msg) {}
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>

  <P><FONT FACE="Georgia">Так, если Вы измените предыдущее выражение <B>import</B> 
    на:</FONT><BR>
  </P>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>import</font> com.bruceeckel.tools.*;</PRE></FONT></BLOCKQUOTE>

  <P><FONT FACE="Georgia">программа больше не будет печатать контрольные данные. 
    Вот пример:</FONT><BR>
  </P>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c05:TestAssert.java</font>
<font color=#009900>// Демонстрация инструмента контроля.</font>
<font color=#009900>// Комментируете первую или вторую строчку и </font>
<font color=#009900>// получаете различные результаты:</font>
<font color=#0000ff>import</font> com.bruceeckel.tools.debug.*;
<font color=#009900>// import com.bruceeckel.tools.*;</font>

<font color=#0000ff>public</font> <font color=#0000ff>class</font> TestAssert {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Assert.is_true((2 + 2) == 5);
    Assert.is_false((1 + 1) == 2);
    Assert.is_true((2 + 2) == 5, <font color=#004488>"2 + 2 == 5"</font>);
    Assert.is_false((1 + 1) == 2, <font color=#004488>"1 +1 != 2"</font>);
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
 
  <P><FONT FACE="Georgia">Изменением импортируемого пакета, Вы производите переход 
    от отладочной к конечной версии. Эта техника может быть использована для создания 
    отладочного кода любого типа.</FONT><A NAME="_Toc481064593"></A><BR>
  </P>

<A NAME="Heading195"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Пакетное предостережение</H3>
</FONT>
 
  
<P><FONT FACE="Georgia">Необходимо запомнить, что когда Вы создаете пакет, Вы 
  косвенно задаете <a name="Index494"></a><a name="Index495"></a>структуру каталогов 
  при задании имени пакета. Пакет <I>должен</I> находиться в каталоге, определенном 
  в имени пакета, причем этот каталог должен быть доступен по переменной CLASSPATH. 
  Экспериментирование с ключевым словом <B>package</B> может быть бесполезным 
  вначале, поскольку пока Вы не будете придерживаться правила: имя пакета определяет 
  путь к нему, Вы будете получать множество непонятных run-time сообщений, сообщающих 
  о невозможности найти какой-нибудь класс, даже если он находится в том же самом 
  каталоге. Если Вы получите подобное сообщение, попробуйте закомментировать выражение 
  <B>package</B>, и, если все заработает, то Вы знаете, в чем проблема.</FONT><A NAME="_Toc375545295"></A><A NAME="_Toc481064594"></A><BR>
  </P>

<A NAME="Heading196"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Спецификаторы доступа в Java</H2>
</FONT>
 
  <P><FONT FACE="Georgia"> <a name="Index496"></a><a name="Index497"></a>Спецификаторы 
    доступа Java <A NAME="Index498"></A><B>public</B>, <A NAME="Index499"></A><B>protected</B> 
    и <A NAME="Index500"></A><B>private</B> располагаются перед каждым определением 
    каждого члена в Вашем классе, независимо от того, метод это или просто поле. 
    Каждый спецификатор доступа определяет доступ только для одного конкретного 
    определения. В этом - явное различие с языком C++, в котором спецификатор 
    доступа определяет доступ для всех последующих определений, пока не встретится 
    другой спецификатор доступа.</FONT><BR>
  </P>


  
<P><FONT FACE="Georgia">Так или иначе, у всего имеется какой-то тип доступа. Далее 
  Вы узнаете все о различных типах доступа, начиная с типа доступа по умолчанию.</FONT><A NAME="_Toc312373840"></A><A NAME="_Toc375545296"></A><A NAME="_Toc481064595"></A><BR>
  </P>
<A NAME="Heading197"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Дружественный доступ &#8220;Friendly&#8221;</H3>
</FONT> 
 
  <P><FONT FACE="Georgia">А что, если Вы вообще не определяете спецификатор доступа, 
    как это было сделано во всех примерах до настоящей главы? Доступ по умолчанию 
    не имеет ключевого слова, но обычно называется дружественным - &#8220;friendly.&#8221; 
    Это значит, что все другие классы в том же пакете имеют доступ к дружественным 
    членам, но для классов за пределами этого пакета, члены являются приватными 
    (<b>private</b>). Т.к. файл модуля компиляции может принадлежать только одному 
    пакету, все классы внутри этого единичного модуля компиляции автоматически 
    являются дружественными друг другу. Таким образом, говорят, что дружественные 
    элементы имеют <i>доступ на <a name="Index501"></a><a name="Index502"></a>уровне 
    пакета</i>.</FONT><BR>
  </P>

 
  
<P><FONT FACE="Georgia">Дружественный доступ позволяет Вам объединять связанные 
  классы в пакете, так, что они могут легко общаться друг с другом. Когда Вы располагаете 
  классы вместе в одном пакете, (определив таким образом совместный доступ для 
  дружественных членов), Вы &#8220;владеете&#8221; кодом в этом пакете. Во многих 
  языках, Вам волей-неволей приходится организовывать определения в файлах, но 
  Java Вас заставляет <A NAME="Index503"></A><A NAME="Index504"></A>создавать 
  их в разумной форме. К тому же, Вы, возможно, захотите исключить классы, которые 
  не должны иметь доступ к классам в том же пакете.</FONT><BR>
  </P>

 
  
<P><FONT FACE="Georgia">Класс управляет тем, какой код имеет доступ к его членам. 
  И нет никакого магического способа &#8220;прорваться внутрь.&#8221; Код из другого 
  пакета не может появиться и сказать, &#8220;Привет, Я друг Боба!&#8221; и затем 
  посмотреть все защищенные, дружественные и приватные члены Боба. Единственный 
  путь получить доступ, это:</FONT><BR>
  </P>

<OL>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Сделать этот член публичным. 
    И кто угодно, откуда угодно сможет получить к нему доступ.</FONT> 
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Сделайте это член дружественным, 
    удалив все спецификаторы доступа, и расположите классы в одном пакете.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Как Вы увидите в Главе 
    6, когда наследование определено, унаследованный класс получает доступ к защищенным 
    членам, а также к публичным членам (но не приватным). Этот класс может получить 
    доступ к дружественным членам, только если эти два класса находятся в одном 
    пакете. Но Вам не стоит беспокоиться об этом сейчас.</FONT> 
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Предоствавьте методы &#8220;accessor/mutator&#8221; 
    (также известные как &#8220;get/set&#8221; методы), которые читают и изменяют 
    значение какого-то поля класса. Это самый цивилизованный подход в терминах 
    ООП, и это основной подход в JavaBeans, как Вы увидите в Главе 13.</FONT><A NAME="_Ref351419800"></A><A NAME="_Toc375545297"></A><A NAME="_Toc481064596"></A> 
</OL><A NAME="Heading198"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> public: интерфейсный доступ</H3>
</FONT>

  <P><FONT FACE="Georgia">Если Вы используете ключевое слово <B>public</B>, это 
    <A NAME="Index505"></A>значит, что объявление, следующее сразу за этим словом, 
    доступно всем, и, конечно, клиентскому программисту, который использует эту 
    библиотеку. Предположим, что Вы создаете пакет <B>dessert</B>, содержащий 
    следующий модуль компиляции:</FONT><BR>
  </P>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c05:dessert:Cookie.java</font>
<font color=#009900>// Создаем библиотеку.</font>
<font color=#0000ff>package</font> c05.dessert;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Cookie {
  <font color=#0000ff>public</font> Cookie() { 
   System.out.println(<font color=#004488>"Cookie constructor"</font>); 
  }
  <font color=#0000ff>void</font> bite() { System.out.println(<font color=#004488>"bite"</font>); }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
 
  <P><FONT FACE="Georgia">Запомните, <B>Cookie.java</B> должен располагаться в 
    каталоге<B> c05\dessert</B> (<b>с05</b> означает пятую главу этой книги), 
    который должен быть доступен по одному из путей в CLASSPATH. Не надейтесь, 
    что Java всегда просматривает текущий каталог, как один из начальных каталогов 
    для поиска классов. Если Вы не добавите путь &quot;.&quot; в переменную среды 
    CLASSPATH, Java не будет этого делать.</FONT><BR>
  </P>


  <P><FONT FACE="Georgia">Теперь, если Вы создадите программу, использующую <B>Cookie</B>:</FONT><BR>
  </P>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c05:Dinner.java</font>
<font color=#009900>// Использует библиотеку.</font>
<font color=#0000ff>import</font> c05.dessert.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Dinner {
  <font color=#0000ff>public</font> Dinner() {
   System.out.println(<font color=#004488>"Dinner constructor"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Cookie x = <font color=#0000ff>new</font> Cookie();
    <font color=#009900>//! x.bite(); // Недоступно</font>
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>

  <P><FONT FACE="Georgia">Вы сможете создать объект <B>Cookie</B>, т.к. его конструктор 
    и сам класс являются публичными. (Далее Вы больше узнаете о концепции публичных 
    классов.) Однако, метод <B>bite(&#160;)</B> недоступен внутри <B>Dinner.java</B> 
    т.к. <B>bite(&#160;)</B> остается дружественным только внутри пакета <B>dessert</B>.</FONT><BR>
  </P>
<A NAME="Heading199"></A><FONT FACE = "Verdana">
<H4 ALIGN="LEFT"> Пакет по умолчанию<BR>
  <A NAME="Index506"></A><A NAME="Index507"></A><A NAME="Index508"></A></H4></FONT>

  <P><FONT FACE="Georgia">Вы, возможно, удивитесь, когда узнаете, что следующий 
    код компилируется, хотя Вам может показаться, что он нарушает правила языка 
    Java:</FONT><BR>
  </P>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c05:Cake.java</font>
<font color=#009900>// Получает дочтуп к классу 
// в другом модуле комиляции</font>

<font color=#0000ff>class</font> Cake {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Pie x = <font color=#0000ff>new</font> Pie();
    x.f();
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>

  <P><FONT FACE="Georgia">Другой файл в том же каталоге содержит следующее:</FONT><BR>
  </P>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c05:Pie.java</font>
<font color=#009900>// Другой класс.</font>

<font color=#0000ff>class</font> Pie {
  <font color=#0000ff>void</font> f() { System.out.println(<font color=#004488>"Pie.f()"</font>); }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>

  
<P><FONT FACE="Georgia">Вначале Вы можете посчитать эти файлы абсолютно чужими, 
  и все же <B>Cake</B> может создать объект <B>Pie</B> и вызвать его метод <B>f(&#160;)</B>! 
  (Конечно, Вам нужно, чтобы CLASSPATH содержал &quot;<b>.</b>&quot;, иначе файлы 
  не будут компилироваться.) Вы можете подумать, что и класс <B>Pie</B> и его 
  метод <B>f(&#160;)</B> являются дружественными и недоступны объекту <B>Cake</B>. 
  То, что они дружественны - это верно! А причина, по которой они доступны в <B>Cake.java</B> 
  в том, что они находятся в одном и том же каталоге и не имеют конкретного имени 
  пакета. Java считает эти файлы частью &#8220;пакета по умолчанию&#8221; для 
  этого каталога, и поэтому, дружественными всем остальным файлам в этом каталоге.</FONT><A NAME="_Toc375545298"></A><A NAME="_Toc481064597"></A><BR>
  </P>
<A NAME="Heading200"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> private: Вы не можете коснуться этого!</H3>
</FONT>
 
  <P><FONT FACE="Georgia">Ключевое <a name="Index509"></a>слово <B>private</B> 
    означает, что никто не имеет доступа к этому члену, за исключением класса, 
    в котором он находится. Другие классы в том же пакете не смогут получить доступ 
    к приватным членам. С другой стороны, очень часто пакет создается группой 
    людей, работающих вместе и <B>private</B> позволит Вам свободно изменять члены 
    класса, не беспокоясь о том, что это может нарушить работу другого класса 
    в том же пакете. </FONT><BR>
  </P>

 
  
<P><FONT FACE="Georgia">Дружественного доступа по умолчанию часто достаточно для 
  скрытия реализации; запомните: &#8220;дружественный&#8221; член недоступен пользователю 
  пакета. Это здорово, т.к. доступ по умолчанию - то, что Вы обычно используете 
  (и это именно то, что Вы получаете, когда вообще не ставите идентификаторы доступа). 
  Таким образом, Вы можете подумать, что доступ к членам должен быть публичным 
  для клиентского программиста, и в результате, Вам не нужно использовать ключевое 
  слово <B>private</B>, т.к. Вы можете прожить без него. Однако, использование 
  <B>private</B> очень важно, особенно в многопоточных программах. (Как Вы увидите 
  в Главе 14.)</FONT><BR>
  </P>


  <P><FONT FACE="Georgia">Вот пример использования <B>private</B>:</FONT><BR>
  </P>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c05:IceCream.java</font>
<font color=#009900>// Демонстрирует ключевое слово "private".</font>

<font color=#0000ff>class</font> Sundae {
  <font color=#0000ff>private</font> Sundae() {}
  <font color=#0000ff>static</font> Sundae makeASundae() { 
    <font color=#0000ff>return</font> <font color=#0000ff>new</font> Sundae(); 
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> IceCream {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#009900>//! Sundae x = new Sundae();</font>
    Sundae x = Sundae.makeASundae();
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>

  <P><FONT FACE="Georgia">Этот пример показывает использование <B>private</B>: 
    Вам может потребоваться контроль создания объекта и предотвращение прямого 
    доступа к какому-нибудь конструктору (или всем конструкторам). В примере выше, 
    Вы не можете создать объект <B>Sundae</B> с помощью его конструктора; для 
    этого Вы должны вызвать метод <B>makeASundae(&#160;)</B></FONT><A NAME="fnB33" HREF="#fn33">[33]</A><FONT FACE="Georgia">.</FONT><BR>
  </P>

  
<P><FONT FACE="Georgia">Любой метод, который Вы считаете вспомогательным для этого 
  класса можно сделать приватным<B>,</B> что будет гарантировать, что Вы не использовали 
  случайно этот метод в другом месте того же пакета, и в результате не можете 
  изменить либо удалить его. Создание метода приватным, гарантирует именно такой 
  результат.</FONT><BR>
  </P>

  
<P><FONT FACE="Georgia">Это верно и для приватных полей внутри класса. Если Вы 
  не собираетесь раскрывать реализацию (что бывает реже, чем Вы думаете), Вам 
  следует сделать все поля приватными. Однако, если ссылка на объект является 
  приватной внутри класса, это не значит, что другой объект не может иметь публичную 
  ссылку на тот же объект. (Смотрите приложение A об алиасах.)</FONT><A NAME="_Toc312373839"></A><A NAME="_Toc375545299"></A><A NAME="_Toc481064598"></A><BR>
  </P>
<A NAME="Heading201"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> protected: &#8220;тип дружественного доступа&#8221;</H3>
</FONT>

  <P><FONT FACE="Georgia">Спецификатор доступа <B>protected</B> требует дополнительных 
    усилий для понимания<A NAME="Index510"></A>. Но Вы должны знать, что Вам не 
    требуется понимать этот раздел, чтобы продолжать дальнейшее чтение разделов 
    о наследовании (Глава 6). Но для завершенности, здесь представлено краткое 
    описание и примеры использования ключевого слова <B>protected</B>. </FONT><BR>
  </P>
 
  
<P><FONT FACE="Georgia">Ключевое слово <B>protected</B> разрешает концепцию названную 
  <A NAME="Index511"></A><I>наследование</I>, которое берет существующий класс 
  и добавляет в него новые члены не затрагивая исходного (<i>базового класса</i>)<A NAME="Index512"></A><A NAME="Index513"></A>. 
  Вы также можете изменить поведение существующих методов класса. Для наследования 
  от существующего класса Вы говорите, что новый класс расширяет <A NAME="Index514"> 
  </A>(<B>extends) </B>существующий класс:</FONT><BR>
  </P>


<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>class</font> Foo <font color=#0000ff>extends</font> Bar {</PRE></FONT></BLOCKQUOTE>

  <P><FONT FACE="Georgia">Дальнейшее определение класса выглядит также.</FONT><BR>
  </P>
 
  
<P><FONT FACE="Georgia">Если Вы создаете новый пакет и наследуете класс из другого 
  пакета, то единственные члены, к которым Вы имеете доступ, это публичные члены 
  в исходном пакете. (Конечно, если наследование происходит в том же самом пакете, 
  Вы имеете нормальный пакетный доступ для всех &#8220;дружественных&#8221; членов.) 
  Но иногда, создатель базового класса хочет разрешить доступ к конкретному члену 
  только для наследуемого класса, но не всему миру в целом. Именно это делает 
  <B>protected</B>. Если Вы рассмотрите снова файл <B>Cookie.java</B>, нижеследующий 
  класс не <i>может</i> получить доступ к &#8220;дружественному&#8221; члену:</FONT><BR>
  </P>


<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c05:ChocolateChip.java</font>
<font color=#009900>// Нет доступа к члену</font>
<font color=#009900>// другого класса.</font>
<font color=#0000ff>import</font> c05.dessert.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ChocolateChip <font color=#0000ff>extends</font> Cookie {
  <font color=#0000ff>public</font> ChocolateChip() {
   System.out.println(
     <font color=#004488>"ChocolateChip constructor"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    ChocolateChip x = <font color=#0000ff>new</font> ChocolateChip();
    <font color=#009900>//! x.bite(); // Нет доступа к bite</font>
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>

  
<P><FONT FACE="Georgia">Одна из интересных особенностей наследования заключается 
  в том, что если метод <B>bite(&#160;)</B> существует в классе <B>Cookie</B>, 
  то он также существует в любом наследуемом от <B>Cookie</B> классе. Но, т.к. 
  <B>bite(&#160;)</B> является &#8220;дружественным&#8221; в другом пакете, он 
  недоступен нам в этом. Конечно, Вы можете сделать его публичным <B>public</B>, 
  но тогда каждый будет иметь к нему доступ, и может быть, Вы не хотите этого. 
  Если мы изменим класс <B>Cookie,</B> как показано ниже:</FONT><BR>
</P>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>public</font> <font color=#0000ff>class</font> Cookie {
  <font color=#0000ff>public</font> Cookie() { 
    System.out.println(<font color=#004488>"Cookie constructor"</font>);
  }
  <font color=#0000ff>protected</font> <font color=#0000ff>void</font> bite() {
    System.out.println(<font color=#004488>"bite"</font>); 
  }
}</PRE></FONT></BLOCKQUOTE>
 
  
<P><FONT FACE="Georgia">то метод <B>bite(&#160;)</B> будет иметь &#8220;дружественный&#8221; 
  доступ внутри пакета <B>dessert</B>, а также будет доступен всем наследникам 
  класса <B>Cookie</B>. Однако, он - не <A NAME="Index515"></A>публичный.</FONT><A NAME="_Toc375545301"></A><A NAME="_Toc481064599"></A><BR>
  </P>

<A NAME="Heading202"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Интерфейс и реализация</H2>
</FONT>

  <P><FONT FACE="Georgia">Контроль доступа часто называют с<I>крытием реализации<A NAME="Index516"></A><A NAME="Index517"></A></I>. 
    Завертывание методов и данных в классах в комбинации со скрытием реализации 
    называется часто <i>инкапсуляцией</i></FONT><A NAME="fnB34" HREF="#fn34">[34]</A><A NAME="Index518"></A><FONT FACE="Georgia">. 
    Результат - это тип данных с определенными характеристиками и поведением. 
    </FONT><BR>
  </P>

  
<P><FONT FACE="Georgia">Контроль доступа накладывает ограничения по двум важным 
  причинам. Первая - необходимость определения того, что клиентский программист 
  может использовать, а что нет. Вы можете построить Ваш внутренний механизм в 
  структуре класса, не беспокоясь о том, что клинетские программисты случайно 
  воспримут внутреннюю реализацию как часть интерфейса, которой они должны использовать.</FONT><BR>
  </P>

  
<P><FONT FACE="Georgia">Отсюда следует вторая причина, это разделение описания 
  и реализации. <A NAME="Index519"></A><A NAME="Index520"></A><A NAME="Index521"></A> 
  Если эта структура используется в нескольких программах, но клиентские программисты 
  не могут ничего общения с публичными членами, то Вы можете менять как угодно 
  все, что не является публичным (e.g., &#8220;дружественным,&#8221; защищенным, 
  либо приватным), без модификаций клиентского кода.</FONT><BR>
  </P>

  
<P><FONT FACE="Georgia">Мы живем в мире объектно-ориентированного программирования, 
  где <B>class</B> обычно описывает &#8220;класс объектов,&#8221; как Вы можете 
  описать класс рыб или класс птиц. Любой объект, принадлежащий этому классу разделит 
  эти характеристики и поведение. Класс - это описание того, как все объекты этого 
  типа будут выглядеть и действовать.</FONT><BR>
  </P>
 
  
<P><FONT FACE="Georgia">В оригинальном объектно-ориентированном <a name="Index522"></a>языке, 
  Simula-67<A NAME="Index523"></A>, ключевое слово <B>class</B> <A NAME="Index524"></A>использовалось 
  для описания нового типа данных. То же самое ключевое слово используется в большинстве 
  объектно-ориентированных языков. Это основной момент целого языка: создание 
  нового типа данных, который является чем-то большим, чем просто контейнером 
  содержащим данные и методы.</FONT><BR>
  </P>


  
<P><FONT FACE="Georgia">Класс - основная концепция ООП в Java. Это одно из ключевых 
  слов, которое не будет выделено жирным шрифтом в этой книге &#8212;чтобы не 
  было путаницы со словом повторяемым также часто, как и &#8220;класс.&#8221;</FONT><BR>
  </P>
 
  
<P><FONT FACE="Georgia">Для упрощения, Вы можете выбрать <a name="Index525"></a><a name="Index526"></a>стиль 
  создания классов, в котором сначала располагаются публичные члены, затем защищенные, 
  дружественные и, наконец, частные. Выгода в том что пользователь этого класса 
  сможет, просматривая файл сначала, увидеть сразу то, что важно для него (публичные 
  члены, т.к. к ним может быть получен доступ за пределами файла), и прекратить 
  просмотр при достижении непубличных членов, которые являются частью внутренней 
  реализации:</FONT><BR>
  </P>


<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>public</font> <font color=#0000ff>class</font> X {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> pub1(&#160;) { <font color=#009900>/* . . . */</font> }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> pub2(&#160;) { <font color=#009900>/* . . . */</font> }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> pub3(&#160;) { <font color=#009900>/* . . . */</font> }
  <font color=#0000ff>private</font> <font color=#0000ff>void</font> priv1(&#160;) { <font color=#009900>/* . . . */</font> }
  <font color=#0000ff>private</font> <font color=#0000ff>void</font> priv2(&#160;) { <font color=#009900>/* . . . */</font> }
  <font color=#0000ff>private</font> <font color=#0000ff>void</font> priv3(&#160;) { <font color=#009900>/* . . . */</font> }
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> i;
  <font color=#009900>// . . .</font>
}</PRE></FONT></BLOCKQUOTE>

  
<P><FONT FACE="Georgia">Это всего лишь частично упростит чтение, т.к. описание 
  и реализация все еще находятся вместе. То есть, Вы еще видите исходный код &#8212;реализацию&#8212;, 
  поскольку она находится здесь же, в классе. К тому же, документация из комментариев, 
  поддерживаемая утилитой javadoc (описанной в Главе 2) преуменьшает важность 
  чтения кода клиентским программистом. Отображение интерфейса для пользователя 
  класса это, на самом деле, занятие <A NAME="Index527"></A><A NAME="Index528"></A><I>браузера 
  классов</I>, инструмента, чья работа состоит в том, чтобы просмотреть все доступные 
  классы и показать Вам, что Вы можете делать с ними (т.е. показать все доступные 
  члены), в удобной форме. К тому времени, как Вы прочитаете это, такие браузеры 
  должны быть частью любой хорошей среды разработки Java.</FONT><A NAME="_Toc312373850"></A><A NAME="_Toc375545302"></A><A NAME="_Toc481064600"></A><BR>
  </P>
<A NAME="Heading203"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Доступ класса<BR>
  <A NAME="Index529"></A><A NAME="Index530"></A></H2></FONT>

  
<P><FONT FACE="Georgia">В Java, спецификаторы доступа могут также использоваться 
  для определения того, какие классы <i>внутри </i>библиотеки будут доступны пользователям 
  библиотеки. Если Вы хотите сделать класс доступным клиентскому программисту, 
  Вы располагаете ключевое слово <B>public</B> где-нибудь перед открывающей фигурной 
  скобкой тела класса. Это определяет, может ли клиентский программист создать 
  объект этого класса. </FONT><BR>
  </P>

  
<P><FONT FACE="Georgia">Для контроля доступа к классу, спецификатор должен располагаться 
  перед ключевым словом <B>class</B>.<B> </B>Итак, Вы можете написать:</FONT><BR>
  </P>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>public</font> <font color=#0000ff>class</font> Widget {</PRE></FONT></BLOCKQUOTE>

  <P><FONT FACE="Georgia">Если имя Вашей библиотеки <B>mylib</B> любой клиентский 
    программист может получить доступ к <B>Widget</B> с помощью</FONT><BR>
  </P>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>import</font> mylib.Widget;</PRE></FONT></BLOCKQUOTE>

  <P><FONT FACE="Georgia">либо</FONT><BR>
  </P>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>import</font> mylib.*;</PRE></FONT></BLOCKQUOTE>

  
<P><FONT FACE="Georgia">Однако, существует несколько дополнительных ограничений:</FONT><BR>
  </P>
<OL>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Может существовать только 
    один публичный класс в одном модуле компиляции (файле). Идея состоит в том, 
    что один модуль компиляции имеет один публичный интерфейс, представленный 
    этим публичным классом. Он может иметь так много поддерживающих &#8220;дружественных&#8221; 
    классов, сколько Вам необходимо. Если у Вас больше одного публичного класса 
    в модуле компиляции, компилятор выдаст сообщение об ошибке.</FONT> 
  <LI>Имя публичного класса должно полностью совпадать<FONT FACE="Georgia">, с 
    именем файла, содержащего соответствующий модуль компиляции, включая регистры 
    символов. Так, например, для класса <B>Widget</B>, имя файла должно быть <B>Widget.java</B>, 
    но никак не <B>widget.java</B> или <B>WIDGET.java</B>. Итак, Вы получите ошибку 
    компиляции, если Вы с этим не согласны.</FONT> 
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Возможно, но не типично, 
    что у Вас будет модуль компиляции вообще без публичного класса. В этом случае, 
    Вы можете называть файл как хотите.</FONT> 
</OL>
  
<P><FONT FACE="Georgia">А что, если у Вас есть такой класс внутри библиотеки <B>mylib</B>, 
  который Вы используете для выполнения задач представленных классом <B>Widget</B> 
  или каким-то другим публичным классом в <B>mylib</B>? Вы не хотите создавать 
  документацию для клиентского программиста, и думаете, что когда-нибудь позже 
  Вы захотите все изменить, либо вообще удалить класс, заменяя его другим. Чтобы 
  иметь такую возможность, Вам нужно убедиться, что ни один клиентский программист 
  не зависит от Ваших деталей реализации, скрытых внутри <B>mylib</B>. Для достижения 
  этого, Вы удаляете ключевое слово <B>public</B> из класса, в этом случае он 
  становится дружественным. (Этот класс может быть использован только внутри этого 
  пакета.)</FONT><BR>
  </P>

  
<P><FONT FACE="Georgia">Обратите внимание, что класс не может быть <B>private 
  </B>(это сделало бы его никому не доступным кроме самого этого класса), или 
  <B>protected</B></FONT><A NAME="fnB35" HREF="#fn35">[35]</A><FONT FACE="Georgia">. 
  Итак, у Вас есть только выбор из двух вариантов: &#8220;дружественный&#8221; 
  или публичный. Если Вы не хотите, чтобы кто-то другой имел доступ к классу, 
  Вы можете сделать все конструкторы приватными, этим запрещая любому кроме Вас, 
  создание объекта этого класса внутри статического члена класса.</FONT><A NAME="fnB36" HREF="#fn36">[36]</A><FONT FACE="Georgia">. 
  Вот пример:</FONT><BR>
  </P>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c05:Lunch.java</font>
<font color=#009900>// Демонстрирует спецификаторы доступа к классу.</font>
<font color=#009900>// Делает класс приватным</font>
<font color=#009900>// с помощью приватных конструкторов:</font>

<font color=#0000ff>class</font> Soup {
  <font color=#0000ff>private</font> Soup() {}
  <font color=#009900>// (1) Позволяет создание с помощью статического метода:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> Soup makeSoup() {
    <font color=#0000ff>return</font> <font color=#0000ff>new</font> Soup();
  }
  <font color=#009900>// (2) Создание статического объекта</font>
  <font color=#009900>// возвращается ссылка на запрос.</font>
  <font color=#009900>// (шаблон "Singleton"):</font>
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Soup ps1 = <font color=#0000ff>new</font> Soup();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> Soup access() {
    <font color=#0000ff>return</font> ps1;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> f() {}
}

<font color=#0000ff>class</font> Sandwich { <font color=#009900>// Использует Lunch</font>
  <font color=#0000ff>void</font> f() { <font color=#0000ff>new</font> Lunch(); }
}

<font color=#009900>// В файле только один публичный класс:</font>
<font color=#0000ff>public</font> <font color=#0000ff>class</font> Lunch {
  <font color=#0000ff>void</font> test() {
    <font color=#009900>// Вы не можете сделать это! Приватный контруктор:</font>
    <font color=#009900>//! Soup priv1 = new Soup();</font>
    Soup priv2 = Soup.makeSoup();
    Sandwich f1 = <font color=#0000ff>new</font> Sandwich();
    Soup.access().f();
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>

  
<P><FONT FACE="Georgia">До сих пор, большинство методов возвращали либо <B>void</B> 
  либо примитивный тип, и описание:</FONT><BR>
  </P>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>  <font color=#0000ff>public</font> <font color=#0000ff>static</font> Soup access() {
    <font color=#0000ff>return</font> ps1;
  }</PRE></FONT></BLOCKQUOTE>

  
<P><FONT FACE="Georgia">может вначале привести в замешательство. Слово перед именем 
  метода (<B>access</B>) говорит о том, что возвращает метод. Пока чаще всего 
  был тип <B>void,</B> и это означало, что метод не возвращает ничего. Но Вы можете 
  возвратить также ссылку на объект, что и происходит здесь. Этот метод возвращает 
  ссылку на объект класса <B>Soup</B>.</FONT><BR>
</P>

  
<P><FONT FACE="Georgia">Класс <B> Soup</B> показывает как предотвратить прямое 
  создание класса, сделав все конструкторы приватными. Запомните, что если Вы 
  не сознаете явно ни одного конструктора, конструктор по умолчанию (конструктор 
  без аргументов) сам будет создан для Вас. Если Вы напишите конструктор по умолчанию, 
  он не будет создаваться автоматически. Если Вы сделаете его приватным, то никто 
  не сможет создать объект этого класса. Но сейчас, как кто-нибудь сможет использовать 
  этот класс? Пример выше показывает два варианта. Первый, с помощью статического 
  метода создается объект типа <B>Soup</B> и возвращается ссылка на него. Это 
  может быть полезно, если Вы хотите выполнить несколько дополнительных операций 
  с классом <B>Soup</B>, перед тем как его возвратить, либо если Вы хотите хранить 
  количество создаваемых объектов типа <B>Soup</B> (возможно для контроля их популяции).</FONT><BR>
  </P>

  
<P><FONT FACE="Georgia">Второй вариант использует так называемый <A NAME="Index531"></A><A NAME="Index532"></A><A NAME="Index533"></A><I>шаблон 
  разработки</I>, который описан<I> </I>в книге <I>Thinking in Patterns with Java</I>, 
  доступной на с <I>www.BruceEckel.com</I>. Этот специфический шаблон называется 
  &#8220;<A NAME="Index534"></A>singleton&#8221; потому что он позволяет создавать 
  только один объект. Объект класса <B>Soup</B> создается как статический приватный 
  член класса <B>Soup</B>, и существует один и только один объект, и Вы не можете 
  получить его никаким другим способом, кроме как с помощью публичного метода 
  <B>access(&#160;)</B>.</FONT><BR>
  </P>

  
<P><FONT FACE="Georgia">Как ранее было упомянуто, если Вы вообще не ставите идентификатор 
  доступа для класса, он становится &#8220;дружественным.&#8221; Это означает, 
  что объект этого класса может быть создан в любом другом классе того же пакета, 
  но не за его пределами. (Запомните, все файлы в одном каталоге не имеющие явного 
  выражения <B>package,</B> принадлежат пакету по умолчанию для этого каталога.) 
  Однако, однако, если статический член этого класса - публичный, то клиентский 
  программист сможет получить доступ к этому статическому члену, даже если он 
  не сможет создать объект этого класса.</FONT><A NAME="_Toc375545303"></A><A NAME="_Toc481064601"></A><BR>
  </P>
<A NAME="Heading204"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Резюме</H2>
</FONT>

  
<P><FONT FACE="Georgia">В любых взаимоотношениях важно иметь границы и правила, 
  которые будут соблюдаться всеми сторонами. Когда Вы создаете библиотеку, Вы 
  устанавливаете взаимоотношения с пользователем этой библиотеки &#8212;клиентским 
  программистом&#8212; - другим программистом, создающим приложение либо использующем 
  Вашу библиотеку для создания другой библиотеки.</FONT><BR>
  </P>

  
<P><FONT FACE="Georgia">Без правил, клиентские программисты могут делать все что 
  они захотят со всеми членами класса, даже если Вы предпочитаете чтобы они напрямую 
  управляли только некоторыми из них. Все открыто миру.</FONT><BR>
  </P>

  
<P><FONT FACE="Georgia">Эта глава показывает, как формировать библиотеку из классов; 
  как располагать классы в библиотеке, и как управлять доступом к членам класса.</FONT><BR>
  </P>

  
<P><FONT FACE="Georgia">Подсчитано, что проекты на языке C начинают разлаживаться 
  между 50K и 100K строчек кода, т.к. C имеет единое &#8220;пространство имен&#8221;, 
  и имена начинают конфликтовать друг с другом, требуя дополнительных модификаций 
  кода. В Java, ключевое слово <B>package</B>, схема именования пакетов, и ключевое 
  слово <B>import</B> дает вам полный контроль над именами, и коллизия имен легко 
  предотвращается.</FONT><BR>
  </P>

  
<P><FONT FACE="Georgia">Есть две причины для использования контроля доступа <A NAME="Index535"></A><A NAME="Index536"></A>к 
  членам данных. Первая - не дать пользователям доступа к инструментам, которые 
  они не должны использовать; инструменты, которые необходимы для внутренних манипуляций 
  типа данных, но не часть интерфейса, который нужен пользователям для решения 
  их проблем. Создание методов и полей приватными - удобство для пользователей, 
  поскольку они могут легко увидеть то, что им нужно, и что они могут игнорировать. 
  Это упрощает для них понимание работы класса.</FONT><BR>
  </P>

  
<P><FONT FACE="Georgia">Вторая и самая важная причина - предоставление проектировщику 
  библиотеки возможности изменять внутренние разделы класса, не беспокоясь о том, 
  как это затронет код клиентского программиста. Вы можете сначала создать свой 
  класс, а затем определить, что реструктуризация Вашего кода даст большую скорость. 
  Если интерфейс и реализация ясно разделены и защищены, Вы сможете сделать это 
  не заставляя пользователя библиотеки переписывать свой код.</FONT><BR>
</P>

<p>Спецификаторы доступа Java дают значительный контроль создателю <font color=#0000ff>класса</font>. 
  Пользователи <font color=#0000ff>класса</font> смогут просто увидеть, что они 
  в точности могут использовать и что могут игнорировать. Хотя, более важно знать, 
  что ни один пользователь не зависит ни от какой части внутренней реализации<font color=#0000ff> 
  класса</font>. Если Вы уверены в <font color=#0000ff>этом</font> как проектировщик 
  <font color=#0000ff>класса</font>, Вы сможете изменить внутреннюю реализацию, 
  зная, что ни один клиентский код не будет затронут этими изменениями, из-за 
  того что он не может получить доступ к той части <font color=#0000ff>класса</font>. 
</p>
<P><FONT FACE="Georgia">Когда у Вас есть возможность изменять внутреннюю реализацию, 
  Вы можете не только улучшить свой дизайн <A NAME="Index537"></A>позже, но также 
  иметь свободу создания ошибок<A NAME="Index538"></A>. Не важно, с каким вниманием 
  Вы планируете и пишите, Вы все равно сделаете ошибки. Знания, что это относительно 
  безопасно - сделать такие ошибки- Вы получитет больше опыта, обучитесь быстрее, 
  и закончите Ваш проект раньше.</FONT><BR>
</P>

  <A NAME="Heading205"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Упражнения</H2>
</FONT>

  
<P><FONT FACE="Georgia" SIZE=2>Решения к избранным упражнениям находятся в электронном 
  документе <I>The Thinking in Java Annotated Solution Guide</I>, доступном за 
  небольшую плату на <I>www.BruceEckel.com</I>.</FONT><BR>
  </P>
<OL>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Напишите программу создающую 
    объект <B>ArrayList</B> без явного импорта <B>java.util.*</B>.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">В разделе &#8220;package: 
    модуль библиотеки,&#8221; перепишите фрагменты кода, относящиеся к <B>mypackage</B> 
    в компилируемый и запускаемый набор файлов Java.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">В разделе &#8220;Коллизии,&#8221; 
    возьмите фрагменты кода и перепишите их в программу, и проверьте, что коллизии 
    действительно происходят.</FONT> 
  <LI>Обобщите класс<FONT FACE="Georgia"> <B>P</B> определенный в этой главе добавлением 
    перегруженных версий <B>rint(&#160;)</B> и <B>rintln(&#160;)</B> необходимыми 
    для управления всеми основными типами Java.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Измените выражение import 
    в <B>TestAssert.java</B> для включения или выключения механизма контроля.</FONT>
  <LI>Создайте класс<FONT FACE="Georgia"> с публичными, приватными, защищенными<B>,</B> 
    и &#8220;дружественными&#8221; методами и данными. Создайте объект этого класса 
    и посмотрите какие ошибки компилятора Вы получите, пытаясь получить доступ 
    ко всем членам этого класса. Убедитесь, что классы в одном каталоге являются 
    частью пакета по умолчанию.</FONT> 
  <LI><FONT FACE="Georgia">Создайте класс с защищенными(<b>protected</b>) данными. 
    Создайте второй класс в том же файле с методом, который манипулирует с защищенными 
    данными в первом классе.</FONT>
  <LI>Измените класс<FONT FACE="Georgia"> <B>Cookie </B>как указано в разделе 
    &#8220;<B>protected</B>: &#8216;тип дружественного доступа.&#8217;&#8221; 
    Проверьте что метод <B>bite(&#160;) </B>не публичный.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">В разделе &#8220;Доступ 
    класса&#8221; Вы найдете фрагменты кода описывающие <B>mylib</B> и <B>Widget</B>. 
    Создайте эту библиотеку, и затем создайте <B>Widget</B> в классе не являющемся 
    частью пакета <B>mylib</B>.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Создайте новый каталог 
    и отредактируйте переменную CLASSPATH чтобы включить туда новый каталог. Скопируйте 
    файл <B>P.class</B> (после компиляции <B>com.bruceeckel.tools.P.java</B>) 
    в Ваш новый каталог и затем измените имена файла, класс <B>P</B> внутри и 
    имена методов. (Вы можете также захотеть добавить дополнительный вывод, чтобы 
    видеть как это работает.) Создайте еще одну программу в другом каталоге которая 
    использует Ваш новый класс.</FONT> 
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Следуя форме примера <B>Lunch.java</B>, 
    создайте класс с именем <B>ConnectionManager,</B> который управляет фиксированным 
    массивом объектов <B>Connection</B>. Клиентский программист не должен иметь 
    возможности явного создания объектов <B>Connection</B>, а может только получить 
    их из статического метода в <B>ConnectionManager</B>. Когда в <B>ConnectionManager</B> 
    параметр выходит за пределы объектов, он возвращает ссылку на <B>null</B>. 
    Проверьте классы в <B>main(&#160;)</B>.</FONT> 
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Создайте следующий файл 
    в каталоге c05/local (доступном по CLASSPATH):</FONT> 
</OL>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>///: c05:local:PackagedClass.java</font>
<font color=#0000ff>package</font> c05.local;
<font color=#0000ff>class</font> PackagedClass {
  <font color=#0000ff>public</font> PackagedClass() {
    System.out.println(
      <font color=#004488>"Creating a packaged class"</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

  <P><FONT FACE="Georgia">Затем создайте следующий файл в другом каталоге - не 
    c05:</FONT><BR>
  </P>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>///: c05:foreign:Foreign.java</font>
<font color=#0000ff>package</font> c05.foreign;
<font color=#0000ff>import</font> c05.local.*;
<font color=#0000ff>public</font> <font color=#0000ff>class</font> Foreign {
   <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main (String[] args) {
      PackagedClass pc = <font color=#0000ff>new</font> PackagedClass();
   }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

  <P><FONT FACE="Georgia">Объясните, почему компилятор генерирует ошибку. Изменит 
    ли что-нибудь помещение класса <B>Foreign</B> в пакет <B>c05.local</B>?</FONT><BR>
  </P>

<HR>
  
<P><A NAME="fn32" HREF="#fnB32">[32]</A><FONT FACE="Georgia" SIZE=2> В Java что 
  заставляет использовать интерпретатор. Существуют компиляторы Java создающие 
  единичный исполняемый файл.</FONT><BR>
  </P>

  <P><A NAME="fn33" HREF="#fnB33">[33]</A><FONT FACE="Georgia" SIZE=2> Есть другой 
    эффект в этом случае: т.к. конструктор по умолчанию - единственный из определенных, 
    и он - приватный, это предотвратит наследование от этого класса. (Тема, описанная 
    в Главе 6.)</FONT><BR>
  </P>

  
<P><A NAME="fn34" HREF="#fnB34">[34]</A><FONT FACE="Georgia" SIZE=2> Однако, люди 
  часто ссылаются на скрытие реализации как на инкапсуляцию.</FONT><BR>
  </P>

  <P><A NAME="fn35" HREF="#fnB35">[35]</A><FONT FACE="Georgia" SIZE=2> В действительности 
    <I>внутренний класс</I> может быть приватным или защищенным, но это уже специальные 
    случаи. Они будут описаны в Главе 7.</FONT><BR>
  </P>

  <P><A NAME="fn36" HREF="#fnB36">[36]</A><FONT FACE="Georgia" SIZE=2> Вы также 
    можете сделать это наследованием (Глава 6) от этого класса.</FONT><BR>
  </P>

 
<div align="center"><FONT FACE="Verdana" size = "-1"> [ <a href="Chapter04.html">Предыдущая 
  глава</a> ] [ <a href="SimpleContents.html">Оглавление</a> ] [ <a href="Contents.html">Содержание</a> 
  ] [ <a href="DocIndex.html">Индекс</a> ] [ <a href="Chapter06.html">Следующая 
  глава</a> ] </FONT><BR>
</div>
</BODY>

</HTML>
