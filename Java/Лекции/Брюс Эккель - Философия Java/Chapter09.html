<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<!--
This document was converted from RTF source: 
By rtftohtml 4.19
See http://www.sunpack.com/RTF
Filename:TIJ2.rtf
Application Directory:c:\TOOLS\RTF2HTML\
Subject:
Author:Bruce Eckel
Operator:Bruce Eckel
Document Comments:
Version Comments:
Comments:
Keywords:
Translation Date:04/24/2000
Translation Time:06:36:07
Translation Platform:Win32
Number of Output files:23
This File:Chapter09.html
SplitDepth=1
SkipNavPanel=1
SkipLeadingToc=1
SkipTrailingToc=1
GenContents=1
GenFrames=1
GenIndex=1
-->
<HEAD lang="en"><META http-equiv="Content-Type" content="text/html; charset=windows-1251">
<TITLE>9: Хранение Ваших объектов</TITLE>
</HEAD>

<BODY  BGCOLOR="#FFFFFF">
<DIV ALIGN="CENTER"> <a href="http://www.MindView.net"> </a> 
  <CENTER>
    <FONT FACE="Verdana" size = "-1"> </FONT> 
    <H2><FONT FACE="Verdana">
  Thinking in Java, 2nd edition, Revision 11</FONT></H2>
  <H3><FONT FACE="Verdana">&copy;2000 by Bruce Eckel</FONT></H3>
  
    <FONT FACE="Verdana" size = "-1"> </FONT>
    <p><font face="Verdana" size = "-1">[ <a href="Chapter08.html">Предыдущая 
      глава </a> ] [ <a href="SimpleContents.html">Оглавление</a> ] [ <a href="Contents.html">Содержание</a> 
      ] [ <a href="DocIndex.html">Индекс</a> ] [ <a href="Chapter10.html">Следующая 
      глава </a> ]</font> </p>
    <FONT FACE="Verdana" size = "-1"> </FONT> 
  </CENTER>
  <p></P></DIV>
<A NAME="_Toc477690729"></A><A NAME="_Toc481064664"></A><A NAME="Heading276"></A><FONT FACE = "Verdana">
<H1 ALIGN="LEFT"> 9: Хранение Ваших объектов<A NAME="OLE_LINK2"></A></H1>
</FONT> 
<P><FONT FACE="Georgia" SIZE=4>Это очень простая программа имеет только ограниченное 
  число объектов с известным временем жизни.</FONT></P>
<P><font face="Georgia">В общем случае ваши программы будут всегда создавать новые 
  объекты, основываясь на таких критериях, которые будут известны только во время 
  выполнения программы. Вы не можете знать до запуска программы количество или 
  даже точный тип необходимых объектов. Для решения общих проблем программирования 
  вы должны быть способны создать любое число объектов в любое время, в любом 
  месте. Так что вы на самом деле не можете создать поименованные ссылки, чтобы 
  держать их для каждого вашего объекта:</font></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>MyObject myReference;</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">так как вы никогда не будете знать, сколько таких ссылок 
  вам на самом деле необходимо.</FONT></P>
<P><FONT FACE="Georgia">Для решения этой насущной проблемы Java имеет несколько 
  способов хранения объектов (или скорее, ссылок на объекты). Встроенным типом 
  является массив, который обсуждался уже ранее. Также библиотека утилит Java 
  имеет разумный набор <a name="Index848"></a>контейнерный классов (также известных 
  как <a name="Index849"></a>классы сборки, поэтому библиотека Java 2 использует 
  имя <b>Collection</b> для указания определенного набора библиотеки, я буду использовать 
  более обобщающий термин </FONT><FONT FACE="Georgia"> &#8220;контейнер&#8221;). 
  Контейнеры обеспечивают удовлетворительные способы хранения и манипуляции вашими 
  объектами.</FONT><A NAME="_Toc375545347"></A><A NAME="_Toc481064665"></A></P>
<A NAME="Heading277"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Массивы</H2>
</FONT> 
<P><FONT FACE="Georgia">Наиболее необходимое введение в <a name="Index850"></a>массивы 
  в последнем разделе <a href="Chapter04.html">Главы 4</a>, которая показывает, 
  как вам определить и проинициализировать массив. Хранение объектов - это основная 
  тема этой главы, а массивы - это просто один способ хранить объекты. Но есть 
  несколько других способов хранения объектов, так что же делает массивы особенными?</FONT></P>
<P><font face="Georgia">Есть две проблемы, которые отличают массивы от других 
  типов контейнеров: <a name="Index851"></a>эффективность и <a name="Index852"></a>тип. 
  Массив является наиболее эффективным способом, из тех, которые обеспечивает 
  Java, для хранения объектов и доступа к ним в случайном порядке (на самом деле, 
  речь идет о ссылках на объекты). Массив - это простая линейная последовательность, 
  которая делает быстрым доступ к элементам, но вы расплачиваетесь за эту скорость: 
  когда вы создаете массив объектов, его размер фиксирован и не может изменяться 
  в течение всей продолжительности жизни этого массива объектов. Вы можете согласиться 
  создать массив определенного размера, а затем, если вы выйдите за пределы, создадите 
  новый и переместите все ссылки из старого массива в новый. Такое поведение заключено 
  в класс <b>ArrayList</b>, который будет изучен позже в этой главе. Однако, потому 
  что превышение этого размера не всегда одинаково, <b>ArrayList</b> менее эффективен, 
  чем массив.</font> </P>
<DIV ALIGN="LEFT"></DIV>
<P><FONT FACE="Georgia">Контейнерный класс <A NAME="Index853"></A><B>vector</B> 
  в C++ <I>знает </I>тип объектов, которые он хранит, но он имеет другие недостатки 
  по сравнению с массивами в Java: метод <b>vector</b>'а из С++ <b>operator[]</b> 
  не делает проверки границ, так что вы можете выйти за пределы <a href="#fn44">[44]</a>. 
  В Java есть проверка границ не зависимо от того используете ли вы массив или 
  контейнер, вы получите <a name="Index854"></a><b>RuntimeException</b>, если 
  вы выйдите за границы. Как вы выучили в <a href="Chapter10.html">Главе 10</a>, 
  этот тип исключения указывает на ошибку программы, и поэтому у вас нет необходимости 
  выполнять проверку в вашем коде. С другой стороны, объяснением того, что <b>vector</b> 
  из С++ не проверяет границы при каждом доступе, может стать скорость доступа, 
  в Java вы имеете постоянную проверку на превышение пределов все время и для 
  массивов и для контейнеров.</FONT></P>
<P><FONT FACE="Georgia">Другие основные контейнерные классы, которые мы изучим 
  в этой главе, <a name="Index855"></a><b>List</b>, <a name="Index856"></a><b>Set</b> 
  и <a name="Index857"></a><b>Map</b>, все имеют дело с объектами, как будто они 
  не имеют определенного типа. То есть, они трактуются как тип <a name="Index858"></a><b>Object</b> 
  - корневой класс для всех классов в Java. С одной точки зрения, это работает 
  прекрасно: вам необходимо построить только один контейнер и все объекты будут 
  подходить для этого контейнера. (За исключением примитивов, они могут быть помещены 
  в контейнер как константы при использовании классов-оболочек Java для примитивных 
  типов, или как переменные значения при использовании ваших собственных классов-оболочек.) 
  Это второй момент, когда массив лучше общих контейнеров: когда вы создаете массив, 
  вы создаете его для содержания определенного типа. Это значит, что вы имеете 
  проверку типа во время компиляции для предотвращения помещения неправильного 
  типа или ошибку типа при извлечении. Конечно, Java предохранит вас от посылки 
  объекту неподходящего сообщения и во время компиляции и во время выполнения. 
  Так что вы, так или иначе, не рискуете, это даже лучше, что компилятор направляет 
  вас, это быстрее при выполнении и при этом меньше вероятность, что конечный 
  пользователь будет удивлен, получив исключение.</FONT></P>
<P><FONT FACE="Georgia">Для эффективности и проверке типа ценной попыткой будет 
  использование массива, если это возможно. Однако когда вы пробуете решить общую 
  проблему, массив может быть слишком ограничен. После обзора массивов остаток 
  этой главы будет посвящен контейнерным классам, имеющимся в Java.</FONT><A NAME="_Toc375545348"></A><A NAME="_Toc481064666"></A></P>
<A NAME="Heading278"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Массивы - первоклассные объекты<A NAME="Index859"></A><A NAME="Index860"></A></H3>
</FONT> 
<P><FONT FACE="Georgia">Независимо от типа массива, с которым вы работаете, идентификатор 
  массива на самом деле указывает на действительные объекты, создаваемые в куче. 
  Это объект, который содержит ссылки на другие объекты, и он может быть создан 
  либо косвенным образом, как часть синтаксиса инициализации массива, либо явно 
  с помощью выражения <b>new</b>. Частью объекта массива (фактически, только поле 
  или метод, к которому вы можете получить доступ) является член <b>length</b> 
  с доступом только для чтения, который говорит вам, сколько элементов можно хранить 
  в объекте массива. <a name="Index861"></a><a name="Index862"></a>Синтаксис &#8216;<b>[]</b>&#8217; 
  - это просто способ доступа, который вы имеете к объекту массива.</FONT></P>
<P><FONT FACE="Georgia">Следующий пример показывает различные способы, которыми 
  может быть инициализирован массив, и как ссылки на объект могут быть присвоены 
  различным объектам массива. Он также показывает, что <a name="Index863"></a>массив 
  объектов и <a name="Index864"></a>массив примитивов почти идентичны в использовании. 
  Отличие только в том, что массив объектов хранит ссылки, в то время как массив 
  примитивов хранит значения примитивов напрямую.</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"> 
  <PRE><font color=#009900>//: c09:ArraySize.java</font>
<font color=#009900>// Инициализация &amp; пере присвоение массивов.</font>

<font color=#0000ff>class</font> Weeble {} <font color=#009900>// Немного мистическое создание</font>

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ArraySize {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#009900>// Массивы объектов:</font>
    Weeble[] a; <font color=#009900>// Null - ссылки</font>
    Weeble[] b = <font color=#0000ff>new</font> Weeble[5]; <font color=#009900>// Null - ссылки</font>
    Weeble[] c = <font color=#0000ff>new</font> Weeble[4];
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; c.length; i++)
      c[i] = <font color=#0000ff>new</font> Weeble();
    <font color=#009900>// Групповая инициализация:</font>
    Weeble[] d = { 
      <font color=#0000ff>new</font> Weeble(), <font color=#0000ff>new</font> Weeble(), <font color=#0000ff>new</font> Weeble()
    };
    <font color=#009900>// Динамическая групповая инициализация</font><font color=#009900>:</font>
    a = <font color=#0000ff>new</font> Weeble[] {
      <font color=#0000ff>new</font> Weeble(), <font color=#0000ff>new</font> Weeble()
    };
    System.out.println(<font color=#004488>"a.length="</font> + a.length);
    System.out.println(<font color=#004488>"b.length = "</font> + b.length);
    <font color=#009900>// Ссылки внутри массива автоматически</font>
    <font color=#009900>// инициализируются значением null:</font>
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; b.length; i++)
      System.out.println(<font color=#004488>"b["</font> + i + <font color=#004488>"]="</font> + b[i]);
    System.out.println(<font color=#004488>"c.length = "</font> + c.length);
    System.out.println(<font color=#004488>"d.length = "</font> + d.length);
    a = d;
    System.out.println(<font color=#004488>"a.length = "</font> + a.length);

    <font color=#009900>// Массив примитивов:</font>
    <font color=#0000ff>int</font>[] e; <font color=#009900>// Null - ссылка</font>
    <font color=#0000ff>int</font>[] f = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[5];
    <font color=#0000ff>int</font>[] g = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[4];
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; g.length; i++)
      g[i] = i*i;
    <font color=#0000ff>int</font>[] h = { 11, 47, 93 };
    <font color=#009900>// Ошибка компиляции: переменная e не инициализирована</font>
    <font color=#009900>//!System.out.println("e.length=" + e.length);</font>
    System.out.println(<font color=#004488>"f.length = "</font> + f.length);
    <font color=#009900>// Примитивы внутри массива</font>
    <font color=#009900>// автоматически инициализируются нулем:</font>
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; f.length; i++)
      System.out.println(<font color=#004488>"f["</font> + i + <font color=#004488>"]="</font> + f[i]);
    System.out.println(<font color=#004488>"g.length = "</font> + g.length);
    System.out.println(<font color=#004488>"h.length = "</font> + h.length);
    e = h;
    System.out.println(<font color=#004488>"e.length = "</font> + e.length);
    e = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[] { 1, 2 };
    System.out.println(<font color=#004488>"e.length = "</font> + e.length);
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Вот что программа выдает на выходе:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>b.length = 5
b[0]=<font color=#0000ff>null</font>
b[1]=<font color=#0000ff>null</font>
b[2]=<font color=#0000ff>null</font>
b[3]=<font color=#0000ff>null</font>
b[4]=<font color=#0000ff>null</font>
c.length = 4
d.length = 3
a.length = 3
a.length = 2
f.length = 5
f[0]=0
f[1]=0
f[2]=0
f[3]=0
f[4]=0
g.length = 4
h.length = 3
e.length = 3
e.length = 2</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Массив <b>a</b> изначально это просто <a name="Index865"></a><b>null</b>-ссылка, 
  и компилятор предохраняет вас от работы с этой ссылкой, пока вы правильно не 
  инициализируете ее. Массив <b>b</b> инициализирован и указывает на массив ссылок 
  <b>Weeble</b>, но никакие реальные объекты не помещаются в этот массив. Однако 
  вы все равно спросить размер массива, так как <b>b</b> указывает на допустимый 
  объект. Здесь мы получаем небольшой недостаток: вы не можете определить, сколько 
  элементов на самом деле есть <i>в</i> массиве, так как <b>length</b> говорит 
  нам о том, сколько элементов <i>могут</i> быть помещены в массив; то есть, размер 
  массива объектов - это не число элементов реально хранящихся в нем. Однако когда 
  создается массив объектов, его ссылки автоматически инициализируются значением 
  <b>null</b>, так что вы можете проверить, имеется ли в определенной ячейке массива 
  объект, просто проверив ее на <b>null</b>. Аналогично массив примитивов автоматически 
  инициализируется нулями для числовых типов: <b>(char)0 </b>для <b>char</b> и<b> 
  false</b> для <b>boolean</b>.</FONT></P>
<P><FONT FACE="Georgia">Массив <b>c</b> показывает создание массива объектов, 
  за которым следует присвоение объектов <b>Weeble</b> для всех ячеек массива. 
  Массив <b>d</b> показывает синтаксис &#8220;групповой инициализации&#8221;, 
  которая является причиной того, что массив объектов создается (косвенным образом 
  с помощью <b>new</b> в куче, так же как и массив <b>c</b>) и инициализируется 
  объектами <b>Weeble</b>, и все это в одной инструкции.</FONT></P>
<P><A NAME="Index866"></A><A NAME="Index867"></A><FONT FACE="Georgia">О следующей 
  инициализации массива можно думать, как о &#8220;динамической групповой инициализации&#8221;. 
  Групповая инициализация, использованная для <b>d</b>, должна использоваться 
  в точке определения <b>d</b>, но со вторым синтаксисом вы можете создавать и 
  инициализировать объекты где угодно. Например, предположим, есть метод <b>hide(&#160;)</b>, 
  который принимает массив объектов <b>Weeble</b>. Вы можете вызвать его, сказав:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>hide(d);</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">но вы можете также динамически создать массив, который 
  вы хотите передать в качестве аргумента:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>hide(<font color=#0000ff>new</font> Weeble[] { <font color=#0000ff>new</font> Weeble(), <font color=#0000ff>new</font> Weeble() });</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">В некоторых ситуациях этот новый синтаксис обеспечивает 
  более удобный способ для написания кода.</FONT></P>
<P><FONT FACE="Georgia">Выражение:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>a = d;</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">показывает, как вы можете получить ссылку, которая присоединена 
  к массиву объектов, и присвоить ее другому массиву объектов, также как вы делаете 
  это с другими типами ссылок на объекты. Теперь и <b>a</b>, и <b>d</b> указывают 
  на один и тот же массив объектов в куче.</FONT></P>
<P><FONT FACE="Georgia">Вторая часть <b>ArraySize.java</b> показывает, что массив 
  примитивов работает точно так же, как и массив объектов, <i>за исключением</i> 
  того, что массив примитивов содержит значения примитивов напрямую.</FONT><A NAME="_Toc375545349"></A></P>
<DIV ALIGN="LEFT"></DIV>
<A NAME="Heading279"></A><FONT FACE = "Verdana">
<H4 ALIGN="LEFT"> Контейнеры примитивов<A NAME="Index868"></A><A NAME="Index869"></A></H4>
</FONT> 
<P><FONT FACE="Georgia">Контейнерные </FONT><FONT FACE="Georgia">классы могут 
  хранить только ссылки на объекты. Однако массивы могут создаваться для хранения 
  примитивных типов так же, как и для хранения объектов. Возможно, использовать 
  классы-оболочки, такие как <b>Integer</b>, <b>Double</b> и т.п., для помещения 
  примитивных значений в контейнер, но классы-оболочки для примитивов может быть 
  неудобно использовать. Кроме того, более эффективно создавать и пользоваться 
  массивом примитивов, чем контейнером для оболочек примитивов.</FONT></P>
<P><FONT FACE="Georgia">Конечно, если вы используете примитивные типы и вам необходима 
  гибкость контейнера, который автоматически растягивается, когда необходимо дополнительное 
  пространство, массивы так не работают и вы вынуждены использовать контейнер 
  для оболочек примитивов. Вы можете подумать, что должен быть специальный тип 
  <b>ArrayList</b> для каждого примитивного типа данных, но Java не предлагает 
  их вам. Механизм шаблонизации определенного сорта в Java может иногда обеспечить 
  лучший способ для решения этой проблемы.</FONT><a href="#fn45">[45]</a><A NAME="_Toc481064667"></A></P>
<DIV ALIGN="LEFT"></DIV>
<A NAME="Heading280"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Возвращение массива</H3>
</FONT>
<P><FONT FACE="Georgia">Предположим, что вы пишите метод и не хотите возвращать 
  только одну вещь, а целый набор вещей. Такие языки, как C и C++ делают это очень 
  сложно, потому что вы не можете вернуть массив, а только указатель на массив. 
  Это приводит к проблемам, потому что необходимо управлять временем жизни массива, 
  что легко приводит к утечке памяти.</FONT></P>
<P><A NAME="Index870"></A><A NAME="Index871"></A><FONT FACE="Georgia">Java имеет 
  схожий подход, но вы можете просто &#8220;вернуть массив&#8221;. На самом деле, 
  конечно, вы возвращаете ссылку на массив, но в Java вам нет необходимости нести 
  ответственность за этот массив, он будет существовать столько, сколько вам нужно, 
  а сборщик мусора очистит его, когда вы закончите работу с ним.</FONT></P>
<P><FONT FACE="Georgia"> </FONT><FONT FACE="Georgia">Посмотрите пример возвращения 
  массива <B>String</B>:</FONT><BR>
</P>
<DIV ALIGN="LEFT"></DIV>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:IceCream.java</font>
<font color=#009900>// Возвращение массивов из методов.</font>

<font color=#0000ff>public</font> <font color=#0000ff>class</font> IceCream {
  <font color=#0000ff>static</font> String[] flav = {
    <font color=#004488>"Chocolate"</font>, <font color=#004488>"Strawberry"</font>,
    <font color=#004488>"Vanilla Fudge Swirl"</font>, <font color=#004488>"Mint Chip"</font>,
    <font color=#004488>"Mocha Almond Fudge"</font>, <font color=#004488>"Rum Raisin"</font>,
    <font color=#004488>"Praline Cream"</font>, <font color=#004488>"Mud Pie"</font> 
  };
  <font color=#0000ff>static</font> String[] flavorSet(<font color=#0000ff>int</font> n) {
    <font color=#009900>// Это должно быть положительным &amp; ограниченным:</font>
    n = Math.abs(n) % (flav.length + 1);
    String[] results = <font color=#0000ff>new</font> String[n];
    <font color=#0000ff>boolean</font>[] picked = 
      <font color=#0000ff>new</font> <font color=#0000ff>boolean</font>[flav.length];
    <font color=#0000ff>for</font> (<font color=#0000ff>int</font> i = 0; i &lt; n; i++) {
      <font color=#0000ff>int</font> t;
      <font color=#0000ff>do</font> 
        t = (<font color=#0000ff>int</font>)(Math.random() * flav.length);
      <font color=#0000ff>while</font> (picked[t]);
      results[i] = flav[t];
      picked[t] = <font color=#0000ff>true</font>;
    }
    <font color=#0000ff>return</font> results;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 20; i++) {
      System.out.println(
        <font color=#004488>"flavorSet("</font> + i + <font color=#004488>") = "</font>);
      String[] fl = flavorSet(flav.length);
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; fl.length; j++)
        System.out.println(<font color=#004488>"\t"</font> + fl[j]);
    }
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Метод <b>flavorSet(&#160;)</b> создает массив <b>String</b>, 
  называемый <b>results</b>. Размер массива - <b>n</b>, определяется аргументом, 
  передаваемым вами в метод. Затем выполняется случайный выбор вкуса из массива 
  <b>flav</b> и помещение его в <b>results</b>, который в конце возвращается. 
  Возврат массива, так же, как и возврат любого объекта, это ссылка. Неважно, 
  что массив был создан внутри <b>flavorSet(&#160;)</b>, или что массив был создан 
  в любом другом месте, это не имеет значения. Сборщик мусора позаботится о его 
  очистке, когда вы завершите с ним работать, а массив будет существовать для 
  нас столько, сколько он вам понадобится.</FONT></P>
<P><FONT FACE="Georgia">С другой стороны, обратите внимание, что когда <b>flavorSet(&#160;)</b> 
  выбирает вкус случайным образом, происходит проверка, что это значение случайно 
  не было выбрано ранее. Это выполняется в цикле <b>do</b>, который сохраняет 
  случайность порядка, пока не найдет тот, который еще не выбран в массиве <b>picked</b>. 
  (Конечно, также можно выполнить сравнение для <b>String</b>, чтобы посмотреть, 
  что случайно выбранный элемент уже не выбран в массив <b>results</b>, но сравнение 
  для <b>String</b> не эффективно.) Если проверка прошла удачно, элемент добавляется 
  и ищется следующий (<b>i </b>получает приращение).</FONT></P>
<P><FONT FACE="Georgia"><B>main(&#160;)</B> печатает 20 полных наборов вкусов, 
  так что вы можете увидеть, что <b>flavorSet(&#160;)</b> выбирает вкусы в случайном 
  порядке всякий раз. Это легче увидеть, если вы перенаправите вывод в файл. И 
  пока вы смотрите на файл, помните, что вы только <i>хотите</i> мороженое, но 
  вам оно <i>не нужно</i>.</FONT><A NAME="_Toc481064668"></A></P>
<DIV ALIGN="LEFT"></DIV>
<A NAME="Heading281"></A><FONT FACE = "Verdana"> 
<H3 ALIGN="LEFT"> Класс Arrays</H3>
</FONT> 
<p>В<FONT FACE="Georgia"> <B>java.util</B> вы найдете класс <a name="Index872"></a><b>Arrays</b>, 
  который содержит набор <b>статических</b> методов, выполняющих вспомогательные 
  функции для массивов. Среди них четыре основных функции: <b>equals(&#160;)</b> 
  - для сравнения двух массивов на равенство; <b>fill(&#160;)</b> - для заполнения 
  массива значением; <b>sort(&#160;)</b> - для сортировки массива; и <b>binarySearch(&#160;)</b> 
  - для нахождения элемента в отсортированном массиве. Все эти методы перегружены 
  для всех примитивных типов и для типа <b>Object</b>. Кроме того, есть одиночный 
  метод <b>asList(&#160;)</b>, который получает массив и переводит его в контейнер 
  <b>List</b>, который вы выучите позже в этой главе.</FONT></p>
<p><FONT FACE="Georgia">Являясь полезным, класс <b>Arrays</b> остается маленьким, 
  вобрав в себя всю функциональность. Например, было бы здорово иметь возможность 
  легко печатать элементы массива, не вводя код цикла <b>for</b> всякий раз. И, 
  как вы увидите, метод <b>fill(&#160;)</b> получает только одно значение и помещает 
  его в массив, так что, если вы хотите, например, заполнить массив случайными 
  числами, <b>fill(&#160;)</b> - не помощник.</FONT></p>
<p><FONT FACE="Georgia">Так что есть смысл пополнить класс <b>Arrays</b> дополнительными 
  утилитами, которые будут по соглашению помешены в <b>package</b> <b>com.bruceeckel.util</b>. 
  Здесь будет печать массива любого типа и заполнения массива значениями или объектами, 
  которые создаются объектом, называемым <i>генератор</i>, который определите 
  вы.</FONT></p>
<P><A NAME="Index873"></A>Поскольку необходим код для создания каждого примитивного 
  типа наряду с <font face="Georgia"><b>Object</b>, будет много сильно похожего 
  кода <a href="#fn46">[46]</a>. Например, интерфейс &#8220;генератор&#8221; требуется 
  для каждого типа, потому что возвращаемый тип <b>next(&#160;)</b> должен быть 
  различным в каждом случае:</font></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: com:bruceeckel:util:Generator.java</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>public</font> <font color=#0000ff>interface</font> Generator { 
  Object next(); 
} <font color=#009900>///:~</font>

<font color=#009900>//: com:bruceeckel:util:BooleanGenerator.java</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>public</font> <font color=#0000ff>interface</font> BooleanGenerator {
  <font color=#0000ff>boolean</font> next();
} <font color=#009900>///:~</font>

<font color=#009900>//: com:bruceeckel:util:ByteGenerator.java</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>public</font> <font color=#0000ff>interface</font> ByteGenerator {
  <font color=#0000ff>byte</font> next();
} <font color=#009900>///:~</font>

<font color=#009900>//: com:bruceeckel:util:CharGenerator.java</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>public</font> <font color=#0000ff>interface</font> CharGenerator {
  <font color=#0000ff>char</font> next();
} <font color=#009900>///:~</font>

<font color=#009900>//: com:bruceeckel:util:ShortGenerator.java</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>public</font> <font color=#0000ff>interface</font> ShortGenerator {
  <font color=#0000ff>short</font> next();
} <font color=#009900>///:~</font>

<font color=#009900>//: com:bruceeckel:util:IntGenerator.java</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>public</font> <font color=#0000ff>interface</font> IntGenerator {
  <font color=#0000ff>int</font> next();
} <font color=#009900>///:~</font>

<font color=#009900>//: com:bruceeckel:util:LongGenerator.java</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>public</font> <font color=#0000ff>interface</font> LongGenerator {
  <font color=#0000ff>long</font> next();
} <font color=#009900>///:~</font>

<font color=#009900>//: com:bruceeckel:util:FloatGenerator.java</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>public</font> <font color=#0000ff>interface</font> FloatGenerator {
  <font color=#0000ff>float</font> next();
} <font color=#009900>///:~</font>

<font color=#009900>//: com:bruceeckel:util:DoubleGenerator.java</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>public</font> <font color=#0000ff>interface</font> DoubleGenerator {
  <font color=#0000ff>double</font> next();
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<P><A NAME="Index874"></A><FONT FACE="Georgia"><B>Arrays2</B> содержит варианты 
  функций <b>print(&#160;)</b>, перегруженной для каждого типа. Вы можете просто 
  напечатать массив, вы можете добавить сообщение перед печатью массива или вы 
  можете напечатать пределы элементов массива. Код метода <b>print(&#160;)</b> 
  говорит сам за себя:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: com:bruceeckel:util:Arrays2.java</font>
<font color=#009900>// Дополнение к java.util.Arrays, для обеспечения</font>
<font color=#009900>// дополнительной полезной функциональности при работе</font>
<font color=#009900>// с массивами. Позволяет печатать массивы,</font>
<font color=#009900>// и заполнять их определенными пользователем</font>
<font color=#009900>// "генераторами" объектов.</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Arrays2 {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font>
  start(<font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to, <font color=#0000ff>int</font> length) {
    <font color=#0000ff>if</font>(from != 0 || to != length)
      System.out.print(<font color=#004488>"["</font>+ from +<font color=#004488>":"</font>+ to +<font color=#004488>"] "</font>);
    System.out.print(<font color=#004488>"("</font>);
  }
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> end() {
    System.out.println(<font color=#004488>")"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> print(Object[] a) {
    print(a, 0, a.length);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  print(String msg, Object[] a) {
    System.out.print(msg + <font color=#004488>" "</font>);
    print(a, 0, a.length);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  print(Object[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to){
    start(from, to, a.length);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++) {
      System.out.print(a[i]);
      <font color=#0000ff>if</font>(i &lt; to -1)
        System.out.print(<font color=#004488>", "</font>);
    }
    end();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> print(<font color=#0000ff>boolean</font>[] a) {
      print(a, 0, a.length);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  print(String msg, <font color=#0000ff>boolean</font>[] a) {
    System.out.print(msg + <font color=#004488>" "</font>);
    print(a, 0, a.length);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  print(<font color=#0000ff>boolean</font>[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to) {
    start(from, to, a.length);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++) {
      System.out.print(a[i]);
      <font color=#0000ff>if</font>(i &lt; to -1)
        System.out.print(<font color=#004488>", "</font>);
    }
    end();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> print(<font color=#0000ff>byte</font>[] a) {
      print(a, 0, a.length);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  print(String msg, <font color=#0000ff>byte</font>[] a) {
    System.out.print(msg + <font color=#004488>" "</font>);
    print(a, 0, a.length);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  print(<font color=#0000ff>byte</font>[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to) {
    start(from, to, a.length);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++) {
      System.out.print(a[i]);
      <font color=#0000ff>if</font>(i &lt; to -1)
        System.out.print(<font color=#004488>", "</font>);
    }
    end();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> print(<font color=#0000ff>char</font>[] a) {
      print(a, 0, a.length);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  print(String msg, <font color=#0000ff>char</font>[] a) {
    System.out.print(msg + <font color=#004488>" "</font>);
    print(a, 0, a.length);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  print(<font color=#0000ff>char</font>[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to) {
    start(from, to, a.length);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++) {
      System.out.print(a[i]);
      <font color=#0000ff>if</font>(i &lt; to -1)
        System.out.print(<font color=#004488>", "</font>);
    }
    end();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> print(<font color=#0000ff>short</font>[] a) {
      print(a, 0, a.length);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  print(String msg, <font color=#0000ff>short</font>[] a) {
    System.out.print(msg + <font color=#004488>" "</font>);
    print(a, 0, a.length);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  print(<font color=#0000ff>short</font>[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to) {
    start(from, to, a.length);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++) {
      System.out.print(a[i]);
      <font color=#0000ff>if</font>(i &lt; to - 1)
        System.out.print(<font color=#004488>", "</font>);
    }
    end();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> print(<font color=#0000ff>int</font>[] a) {
      print(a, 0, a.length);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  print(String msg, <font color=#0000ff>int</font>[] a) {
    System.out.print(msg + <font color=#004488>" "</font>);
    print(a, 0, a.length);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  print(<font color=#0000ff>int</font>[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to) {
    start(from, to, a.length);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++) {
      System.out.print(a[i]);
      <font color=#0000ff>if</font>(i &lt; to - 1)
        System.out.print(<font color=#004488>", "</font>);
    }
    end();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> print(<font color=#0000ff>long</font>[] a) {
    print(a, 0, a.length);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  print(String msg, <font color=#0000ff>long</font>[] a) {
    System.out.print(msg + <font color=#004488>" "</font>);
    print(a, 0, a.length);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  print(<font color=#0000ff>long</font>[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to) {
    start(from, to, a.length);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++) {
      System.out.print(a[i]);
      <font color=#0000ff>if</font>(i &lt; to - 1)
        System.out.print(<font color=#004488>", "</font>);
    }
    end();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> print(<font color=#0000ff>float</font>[] a) {
      print(a, 0, a.length);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  print(String msg, <font color=#0000ff>float</font>[] a) {
    System.out.print(msg + <font color=#004488>" "</font>);
    print(a, 0, a.length);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  print(<font color=#0000ff>float</font>[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to) {
    start(from, to, a.length);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++) {
      System.out.print(a[i]);
      <font color=#0000ff>if</font>(i &lt; to - 1)
        System.out.print(<font color=#004488>", "</font>);
    }
    end();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> print(<font color=#0000ff>double</font>[] a) {
      print(a, 0, a.length);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  print(String msg, <font color=#0000ff>double</font>[] a) {
    System.out.print(msg + <font color=#004488>" "</font>);
    print(a, 0, a.length);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  print(<font color=#0000ff>double</font>[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to){
    start(from, to, a.length);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++) {
      System.out.print(a[i]);
      <font color=#0000ff>if</font>(i &lt; to - 1)
        System.out.print(<font color=#004488>", "</font>);
    }
    end();
  }
  <font color=#009900>// Заполнение массива с использованием генератора:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  fill(Object[] a, Generator gen) {
      fill(a, 0, a.length, gen);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  fill(Object[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to, 
       Generator gen){
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++)
      a[i] = gen.next();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  fill(<font color=#0000ff>boolean</font>[] a, BooleanGenerator gen) {
      fill(a, 0, a.length, gen);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  fill(<font color=#0000ff>boolean</font>[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to,
       BooleanGenerator gen) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++)
      a[i] = gen.next();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  fill(<font color=#0000ff>byte</font>[] a, ByteGenerator gen) {
      fill(a, 0, a.length, gen);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  fill(<font color=#0000ff>byte</font>[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to, 
       ByteGenerator gen) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++)
      a[i] = gen.next();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  fill(<font color=#0000ff>char</font>[] a, CharGenerator gen) {
      fill(a, 0, a.length, gen);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  fill(<font color=#0000ff>char</font>[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to, 
       CharGenerator gen) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++)
      a[i] = gen.next();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  fill(<font color=#0000ff>short</font>[] a, ShortGenerator gen) {
      fill(a, 0, a.length, gen);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  fill(<font color=#0000ff>short</font>[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to, 
       ShortGenerator gen) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++)
      a[i] = gen.next();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  fill(<font color=#0000ff>int</font>[] a, IntGenerator gen) {
      fill(a, 0, a.length, gen);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  fill(<font color=#0000ff>int</font>[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to, 
       IntGenerator gen) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++)
      a[i] = gen.next();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  fill(<font color=#0000ff>long</font>[] a, LongGenerator gen) {
      fill(a, 0, a.length, gen);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  fill(<font color=#0000ff>long</font>[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to, 
       LongGenerator gen) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++)
      a[i] = gen.next();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  fill(<font color=#0000ff>float</font>[] a, FloatGenerator gen) {
      fill(a, 0, a.length, gen);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  fill(<font color=#0000ff>float</font>[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to, 
       FloatGenerator gen) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++)
      a[i] = gen.next();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  fill(<font color=#0000ff>double</font>[] a, DoubleGenerator gen) {
      fill(a, 0, a.length, gen);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  fill(<font color=#0000ff>double</font>[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to,
       DoubleGenerator gen){
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++)
      a[i] = gen.next();
  }
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Random r = <font color=#0000ff>new</font> Random();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> RandBooleanGenerator 
  <font color=#0000ff>implements</font> BooleanGenerator {
    <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> next() { 
      <font color=#0000ff>return</font> r.nextBoolean();
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> RandByteGenerator 
  <font color=#0000ff>implements</font> ByteGenerator {
    <font color=#0000ff>public</font> <font color=#0000ff>byte</font> next() { 
      <font color=#0000ff>return</font> (<font color=#0000ff>byte</font>)r.nextInt();
    }
  }
  <font color=#0000ff>static</font> String ssource = 
    <font color=#004488>"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</font> +
    <font color=#004488>"abcdefghijklmnopqrstuvwxyz"</font>;
  <font color=#0000ff>static</font> <font color=#0000ff>char</font>[] src = ssource.toCharArray();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> RandCharGenerator 
  <font color=#0000ff>implements</font> CharGenerator {
    <font color=#0000ff>public</font> <font color=#0000ff>char</font> next() {
      <font color=#0000ff>int</font> pos = Math.abs(r.nextInt());
      <font color=#0000ff>return</font> src[pos % src.length];
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> RandStringGenerator
  <font color=#0000ff>implements</font> Generator {
    <font color=#0000ff>private</font> <font color=#0000ff>int</font> len;
    <font color=#0000ff>private</font> RandCharGenerator cg = 
      <font color=#0000ff>new</font> RandCharGenerator();
    <font color=#0000ff>public</font> RandStringGenerator(<font color=#0000ff>int</font> length) {
      len = length;
    }
    <font color=#0000ff>public</font> Object next() {
      <font color=#0000ff>char</font>[] buf = <font color=#0000ff>new</font> <font color=#0000ff>char</font>[len];
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; len; i++)
        buf[i] = cg.next();
      <font color=#0000ff>return</font> <font color=#0000ff>new</font> String(buf);
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> RandShortGenerator 
  <font color=#0000ff>implements</font> ShortGenerator {
    <font color=#0000ff>public</font> <font color=#0000ff>short</font> next() { 
      <font color=#0000ff>return</font> (<font color=#0000ff>short</font>)r.nextInt();
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> RandIntGenerator 
  <font color=#0000ff>implements</font> IntGenerator {
    <font color=#0000ff>private</font> <font color=#0000ff>int</font> mod = 10000;
    <font color=#0000ff>public</font> RandIntGenerator() {}
    <font color=#0000ff>public</font> RandIntGenerator(<font color=#0000ff>int</font> modulo) {
      mod = modulo;
    }
    <font color=#0000ff>public</font> <font color=#0000ff>int</font> next() { 
      <font color=#0000ff>return</font> r.nextInt() % mod; 
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> RandLongGenerator 
  <font color=#0000ff>implements</font> LongGenerator {
    <font color=#0000ff>public</font> <font color=#0000ff>long</font> next() { <font color=#0000ff>return</font> r.nextLong(); }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> RandFloatGenerator 
  <font color=#0000ff>implements</font> FloatGenerator {
    <font color=#0000ff>public</font> <font color=#0000ff>float</font> next() { <font color=#0000ff>return</font> r.nextFloat(); }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> RandDoubleGenerator 
  <font color=#0000ff>implements</font> DoubleGenerator {
    <font color=#0000ff>public</font> <font color=#0000ff>double</font> next() {<font color=#0000ff>return</font> r.nextDouble();}
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Для заполнения массива с использованием генератора метод 
  <b>fill(&#160;)</b> получает ссылку на подходящий <b>interface </b>генератора, 
  который имеет метод <b>next(&#160;)</b>, который каким-то образом производит 
  объект правильного типа (в зависимости от того, как реализован интерфейс). Метод 
  <b>fill(&#160;)</b> просто вызывает <b>next(&#160;) </b></FONT><FONT FACE="Georgia">до 
  тех пор, пока не будут достигнуты нужные пределы для заполнения. Теперь вы можете 
  создать любой генератор, реализовав подходящий <b>interface</b>, и использовать 
  ваш генератор с методом <b>fill(&#160;)</b>.</FONT></P>
<P><FONT FACE="Georgia">Случайные генераторы данных полезны для тестирования, 
  так что набор внутренних классов создается для реализации всех интерфейсов примитивных 
  генераторов, так же как и генератор <b>String</b>, представляющий <b>Object</b>. 
  Вы можете видеть, что <b>RandStringGenerator</b> использует <b>RandCharGenerator</b> 
  для заполнения массива символов, который затем переводится в <b>String</b>. 
  Размер массива определяется по аргументу конструктора.</FONT></P>
<P><FONT FACE="Georgia">Для генерации не слишком больших чисел <b>RandIntGenerator</b> 
  берет по умолчанию остаток от деления на 10,000, но перегрузка конструктора 
  позволит вам выбрать меньшее значение.</FONT></P>
<P><FONT FACE="Georgia">Вот программа для проверки библиотеки и демонстрации ее 
  использования:</FONT></P>
<DIV ALIGN="LEFT"></DIV>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:TestArrays2.java</font>
<font color=#009900>// Проверки и демонстрация утилит Arrays2</font>
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> TestArrays2 {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>int</font> size = 6;
    <font color=#009900>// Или получим size из командной строки:</font>
    <font color=#0000ff>if</font>(args.length != 0)
      size = Integer.parseInt(args[0]);
    <font color=#0000ff>boolean</font>[] a1 = <font color=#0000ff>new</font> <font color=#0000ff>boolean</font>[size];
    <font color=#0000ff>byte</font>[] a2 = <font color=#0000ff>new</font> <font color=#0000ff>byte</font>[size];
    <font color=#0000ff>char</font>[] a3 = <font color=#0000ff>new</font> <font color=#0000ff>char</font>[size];
    <font color=#0000ff>short</font>[] a4 = <font color=#0000ff>new</font> <font color=#0000ff>short</font>[size];
    <font color=#0000ff>int</font>[] a5 = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[size];
    <font color=#0000ff>long</font>[] a6 = <font color=#0000ff>new</font> <font color=#0000ff>long</font>[size];
    <font color=#0000ff>float</font>[] a7 = <font color=#0000ff>new</font> <font color=#0000ff>float</font>[size];
    <font color=#0000ff>double</font>[] a8 = <font color=#0000ff>new</font> <font color=#0000ff>double</font>[size];
    String[] a9 = <font color=#0000ff>new</font> String[size];
    Arrays2.fill(a1, 
      <font color=#0000ff>new</font> Arrays2.RandBooleanGenerator());
    Arrays2.print(a1);
    Arrays2.print(<font color=#004488>"a1 = "</font>, a1);
    Arrays2.print(a1, size/3, size/3 + size/3);
    Arrays2.fill(a2,
      <font color=#0000ff>new</font> Arrays2.RandByteGenerator());
    Arrays2.print(a2);
    Arrays2.print(<font color=#004488>"a2 = "</font>, a2);
    Arrays2.print(a2, size/3, size/3 + size/3);
    Arrays2.fill(a3,
      <font color=#0000ff>new</font> Arrays2.RandCharGenerator());
    Arrays2.print(a3);
    Arrays2.print(<font color=#004488>"a3 = "</font>, a3);
    Arrays2.print(a3, size/3, size/3 + size/3);
    Arrays2.fill(a4,
      <font color=#0000ff>new</font> Arrays2.RandShortGenerator());
    Arrays2.print(a4);
    Arrays2.print(<font color=#004488>"a4 = "</font>, a4);
    Arrays2.print(a4, size/3, size/3 + size/3);
    Arrays2.fill(a5,
      <font color=#0000ff>new</font> Arrays2.RandIntGenerator());
    Arrays2.print(a5);
    Arrays2.print(<font color=#004488>"a5 = "</font>, a5);
    Arrays2.print(a5, size/3, size/3 + size/3);
    Arrays2.fill(a6,
      <font color=#0000ff>new</font> Arrays2.RandLongGenerator());
    Arrays2.print(a6);
    Arrays2.print(<font color=#004488>"a6 = "</font>, a6);
    Arrays2.print(a6, size/3, size/3 + size/3);
    Arrays2.fill(a7,
      <font color=#0000ff>new</font> Arrays2.RandFloatGenerator());
    Arrays2.print(a7);
    Arrays2.print(<font color=#004488>"a7 = "</font>, a7);
    Arrays2.print(a7, size/3, size/3 + size/3);
    Arrays2.fill(a8,
      <font color=#0000ff>new</font> Arrays2.RandDoubleGenerator());
    Arrays2.print(a8);
    Arrays2.print(<font color=#004488>"a8 = "</font>, a8);
    Arrays2.print(a8, size/3, size/3 + size/3);
    Arrays2.fill(a9,
      <font color=#0000ff>new</font> Arrays2.RandStringGenerator(7));
    Arrays2.print(a9);
    Arrays2.print(<font color=#004488>"a9 = "</font>, a9);
    Arrays2.print(a9, size/3, size/3 + size/3);
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Параметр <B>size</B> имеет значение по умолчанию, но вы 
  можете также установить его из командной строки.</FONT><A NAME="_Toc481064669"></A></P>
<A NAME="Heading282"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Заполнение массива</H3>
</FONT> 
<P><FONT FACE="Georgia">Стандартная библиотека Java <b>Arrays</b> также имеет 
  метод <b>fill(&#160;)</b>, но он достаточно простой, он просто дублирует одно 
  значение в каждую ячейку или, в случае объектов, копирует одну и ту же ссылку 
  в каждую ячейку. Используя <b>Arrays2.print(&#160;)</b>, можно легко продемонстрировать 
  метод <b>Arrays.fill(&#160;)</b>:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"> 
  <PRE><font color=#009900>//: c09:FillingArrays.java</font>
<font color=#009900>// Использование Arrays.fill()</font>
<font color=#0000ff>import</font> com.bruceeckel.util.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> FillingArrays {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>int</font> size = 6;
    <font color=#009900>// Или получим size из командной строки:</font>
    <font color=#0000ff>if</font>(args.length != 0)
      size = Integer.parseInt(args[0]);
    <font color=#0000ff>boolean</font>[] a1 = <font color=#0000ff>new</font> <font color=#0000ff>boolean</font>[size];
    <font color=#0000ff>byte</font>[] a2 = <font color=#0000ff>new</font> <font color=#0000ff>byte</font>[size];
    <font color=#0000ff>char</font>[] a3 = <font color=#0000ff>new</font> <font color=#0000ff>char</font>[size];
    <font color=#0000ff>short</font>[] a4 = <font color=#0000ff>new</font> <font color=#0000ff>short</font>[size];
    <font color=#0000ff>int</font>[] a5 = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[size];
    <font color=#0000ff>long</font>[] a6 = <font color=#0000ff>new</font> <font color=#0000ff>long</font>[size];
    <font color=#0000ff>float</font>[] a7 = <font color=#0000ff>new</font> <font color=#0000ff>float</font>[size];
    <font color=#0000ff>double</font>[] a8 = <font color=#0000ff>new</font> <font color=#0000ff>double</font>[size];
    String[] a9 = <font color=#0000ff>new</font> String[size];
    Arrays.fill(a1, <font color=#0000ff>true</font>);
    Arrays2.print(<font color=#004488>"a1 = "</font>, a1);
    Arrays.fill(a2, (<font color=#0000ff>byte</font>)11);
    Arrays2.print(<font color=#004488>"a2 = "</font>, a2);
    Arrays.fill(a3, 'x');
    Arrays2.print(<font color=#004488>"a3 = "</font>, a3);
    Arrays.fill(a4, (<font color=#0000ff>short</font>)17);
    Arrays2.print(<font color=#004488>"a4 = "</font>, a4);
    Arrays.fill(a5, 19);
    Arrays2.print(<font color=#004488>"a5 = "</font>, a5);
    Arrays.fill(a6, 23);
    Arrays2.print(<font color=#004488>"a6 = "</font>, a6);
    Arrays.fill(a7, 29);
    Arrays2.print(<font color=#004488>"a7 = "</font>, a7);
    Arrays.fill(a8, 47);
    Arrays2.print(<font color=#004488>"a8 = "</font>, a8);
    Arrays.fill(a9, <font color=#004488>"Hello"</font>);
    Arrays2.print(<font color=#004488>"a9 = "</font>, a9);
    <font color=#009900>// Манипуляция пределами:</font>
    Arrays.fill(a9, 3, 5, <font color=#004488>"World"</font>);
    Arrays2.print(<font color=#004488>"a9 = "</font>, a9);
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Вы можете заполнить либо весь массив, или, как показывают 
  два последних выражения, диапазон элементов. Но так как вы передаете только 
  одно значение для заполнения с использованием <b>Arrays.fill(&#160;)</b>, метод 
  <b>Arrays2.fill(&#160;)</b> производит более интересный результат.</FONT><A NAME="_Toc481064670"></A></P>
<A NAME="Heading283"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Копирование массива<A NAME="Index876"></A><A NAME="Index877"></A></H3>
</FONT> 
<P><FONT FACE="Georgia">Стандартная библиотека Java обеспечивает <b>static</b> 
  метод <a name="Index878"></a><b>System.arraycopy(&#160;)</b>, который может 
  ускорить копирование массива по сравнению с использование цикла <b>for</b> для 
  выполнения копирования в ручную. <b>System.arraycopy(&#160;) </b>перегружена 
  для обработки всех типов. Вот пример, который манипулирует массивами типа <b>int</b>:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:CopyingArrays.java</font>
<font color=#009900>// Использование System.arraycopy()</font>
<font color=#0000ff>import</font> com.bruceeckel.util.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> CopyingArrays {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>int</font>[] i = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[25];
    <font color=#0000ff>int</font>[] j = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[25];
    Arrays.fill(i, 47);
    Arrays.fill(j, 99);
    Arrays2.print(<font color=#004488>"i = "</font>, i);
    Arrays2.print(<font color=#004488>"j = "</font>, j);
    System.arraycopy(i, 0, j, 0, i.length);
    Arrays2.print(<font color=#004488>"j = "</font>, j);
    <font color=#0000ff>int</font>[] k = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[10];
    Arrays.fill(k, 103);
    System.arraycopy(i, 0, k, 0, k.length);
    Arrays2.print(<font color=#004488>"k = "</font>, k);
    Arrays.fill(k, 103);
    System.arraycopy(k, 0, i, 0, k.length);
    Arrays2.print(<font color=#004488>"i = "</font>, i);
    <font color=#009900>// Объекты:</font>
    Integer[] u = <font color=#0000ff>new</font> Integer[10];
    Integer[] v = <font color=#0000ff>new</font> Integer[5];
    Arrays.fill(u, <font color=#0000ff>new</font> Integer(47));
    Arrays.fill(v, <font color=#0000ff>new</font> Integer(99));
    Arrays2.print(<font color=#004488>"u = "</font>, u);
    Arrays2.print(<font color=#004488>"v = "</font>, v);
    System.arraycopy(v, 0, 
      u, u.length/2, v.length);
    Arrays2.print(<font color=#004488>"u = "</font>, u);
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Аргументы для <b>arraycopy(&#160;)</b> - это исходный 
  массив, смещение в исходном массиве, от которого нужно начать копирование, принимающий 
  массив, смещение в принимающем массиве, куда начнется копироваться, и число 
  элементов для копирования. Естественно, нарушение границ массива является причиной 
  исключения.</FONT></P>
<P><FONT FACE="Georgia">Пример показывает, что и примитивный массив, и массив 
  объектов может быть скопирован. Однако если вы копируете массив объектов, то 
  копируются только ссылки, не происходит дублирования самих объектов. Это называется 
  поверхностным копирование (смотрите <a href="AppendixA.html">Приложение A</a>).</FONT><A NAME="_Toc375545350"></A><A NAME="_Toc481064671"></A></P>
<DIV ALIGN="LEFT"></DIV>
<A NAME="Heading284"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Сравнение массивов<A NAME="Index879"></A><A NAME="Index880"></A></H3>
</FONT>
<DIV ALIGN="LEFT"> 
  <P><FONT FACE="Georgia"><B>Arrays</B> обеспечивает перегруженный метод <b>equals(&#160;)</b> 
    для сравнения целых массивов на равенство. Также, он перегружен для всех примитивов 
    и для <b>Object</b>. Чтобы быть равными, массивы должны иметь одинаковое число 
    элементов, а каждый элемент должен быть равен каждому соответствующему элементу 
    другого массива, используя <b>equals(&#160;)</b> для каждого элемента. (Для 
    примитивов используется <b>equals(&#160;)</b> для класса-оболочки примитива; 
    например, <b>Integer.equals(&#160;) </b>для <b>int</b>.)<b> </b>Вот пример:</FONT></P>
  </DIV>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:ComparingArrays.java</font>
<font color=#009900>// Использование Arrays.equals()</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ComparingArrays {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>int</font>[] a1 = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[10];
    <font color=#0000ff>int</font>[] a2 = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[10];
    Arrays.fill(a1, 47);
    Arrays.fill(a2, 47);
    System.out.println(Arrays.equals(a1, a2));
    a2[3] = 11;
    System.out.println(Arrays.equals(a1, a2));
    String[] s1 = <font color=#0000ff>new</font> String[5];
    Arrays.fill(s1, <font color=#004488>"Hi"</font>);
    String[] s2 = {<font color=#004488>"Hi"</font>, <font color=#004488>"Hi"</font>, <font color=#004488>"Hi"</font>, <font color=#004488>"Hi"</font>, <font color=#004488>"Hi"</font>};
    System.out.println(Arrays.equals(s1, s2));
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Изначально <b>a1</b> и <b>a2</b> точно равны, так что 
  на выходе получаем &#8220;true&#8221;, но затем один элемент меняется, так что 
  вторая строка выводит &#8220;false&#8221;. В последнем случае все элементы <b>s1</b>указывают 
  на один и тот же объект, а <b>s2</b> имеет пять уникальных элементов. Однако 
  равенство объектов базируется на соглашении (через <b>Object.equals(&#160;)</b>), 
  так что результат - &#8220;true&#8221;.</FONT><a name="_Toc481064672"></a></P>
<A NAME="Heading285"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Сравнение элементов массива<A NAME="Index881"></A></H3>
</FONT> 
<P><FONT FACE="Georgia">Одна из возможностей, отсутствующих в библиотеках Java 
  1.0 и 1.1 - это алгоритмические операции &#8212; даже простая <a name="Index882"></a>сортировка. 
  Это была довольно смущающая ситуация для того, что ожидал соответствующую стандартную 
  библиотеку. К счастью, Java 2 исправил ситуацию, как минимум, с проблемой сортировки.</FONT></P>
<P><FONT FACE="Georgia">Проблема при написании общего кода сортировки в том, что 
  сортировка должна выполнять сравнение, основываясь на реальном типе объектов. 
  Конечно, один из подходов - это написание различных методов сортировки для каждого 
  из имеющихся типов, но вы должны быть способны понять, что это не продуктивный 
  способ, который легко повторно использовать для новых типов.</FONT></P>
<P><FONT FACE="Georgia">Основная цель дизайна программирования состоит в &#8220;разделении 
  вещей, которые меняются, от вещей, которые остаются теми же&#8221;. В этом случае 
  код, который остается тем же самым - это общий алгоритм сортировки, а вещи, 
  которые меняются при следующим использовании - это способ сравнения объектов. 
  Так что вместо тяжелого написания кода сравнения для многих разных процедур 
  сортировки используется техника <a name="Index883"></a><i>обратного вызова</i>. 
  При обратном вызове часть кода, которая меняется от случая к случаю, инкапсулируется 
  в собственный класс, а часть кода, которая всегда остается той же, совершает 
  обратный вызов этого изменяемого кода. Этим способ ом вы можете создавать разные 
  объекты, определяя различные способы сравнения, и передавать их одному и тому 
  же коду сортировки.</FONT></P>
<P><FONT FACE="Georgia">В Java 2 есть два способа обеспечения функциональности 
  сравнения. Первый из них - <i>естественный метод сравнения</i>, который импортируется 
  в класс путем реализации интерфейса <b>java.lang.Comparable</b>. Это очень простой 
  интерфейс с единственным методом <a name="Index884"></a><b>compareTo(&#160;)</b>. 
  Этот метод принимает другой <b>Object</b>, как аргумент, и производит отрицательное 
  значение, если аргумент меньше, чем текущий объект, ноль, если аргумент равен, 
  и положительное значение, если аргумент больше текущего объекта.</FONT></P>
<P><FONT FACE="Georgia">Здесь </FONT><FONT FACE="Georgia">приведен класс, реализующий 
  <a name="Index885"></a><b>Comparable</b> и демонстрирующий сравнение при использовании 
  метода <b>Arrays.sort(&#160;)</b> стандартной библиотеки Java:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:CompType.java</font>
<font color=#009900>// Реализация Comparable в классе.</font>
<font color=#0000ff>import</font> com.bruceeckel.util.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> CompType <font color=#0000ff>implements</font> Comparable {
  <font color=#0000ff>int</font> i;
  <font color=#0000ff>int</font> j;
  <font color=#0000ff>public</font> CompType(<font color=#0000ff>int</font> n1, <font color=#0000ff>int</font> n2) { 
    i = n1;
    j = n2;
  }
  <font color=#0000ff>public</font> String toString() { 
    <font color=#0000ff>return</font> <font color=#004488>"[i = "</font> + i + <font color=#004488>", j = "</font> + j + <font color=#004488>"]"</font>;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> compareTo(Object rv) {
    <font color=#0000ff>int</font> rvi = ((CompType)rv).i;
    <font color=#0000ff>return</font> (i &lt; rvi ? -1 : (i == rvi ? 0 : 1));
  }
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Random r = <font color=#0000ff>new</font> Random();
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> randInt() {
    <font color=#0000ff>return</font> Math.abs(r.nextInt()) % 100;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> Generator generator() {
    <font color=#0000ff>return</font> <font color=#0000ff>new</font> Generator() {
      <font color=#0000ff>public</font> Object next() {
        <font color=#0000ff>return</font> <font color=#0000ff>new</font> CompType(randInt(),randInt());
      }
    };
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    CompType[] a = <font color=#0000ff>new</font> CompType[10];
    Arrays2.fill(a, generator());
    Arrays2.print(<font color=#004488>"before sorting, a = "</font>, a);
    Arrays.sort(a);
    Arrays2.print(<font color=#004488>"after sorting, a = "</font>, a);
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Когда вы определяете функцию сравнения, вы несете ответственность 
  за смысл, вкладываемый в сравнение одного вашего объекта с другим. В этом примере 
  для сравнения используется только значение <b>i</b>, а значение <b>j</b> игнорируется. 
  </FONT></P>
<P><FONT FACE="Georgia">Метод <B>static randInt(&#160;)</B> производит положительное 
  значение между нулем и 100, а метод <b>generator(&#160;)</b> производит объект, 
  который реализует интерфейс <b>Generator</b> при создании анонимного внутреннего 
  класса (смотрите <a href="Chapter08.html">Главу 8</a>). Таким образом, создается 
  объект <b>CompType</b> и инициализируется случайными значениями. В функции <b>main(&#160;)</b> 
  используется генератор для заполнения массива типа <b>CompType</b>. Если <b>Comparable</b> 
  не будет реализован, то вы получите сообщение об ошибке времени компиляции, 
  когда попробуете вызвать функцию <b>sort(&#160;)</b>.</FONT></P>
<P><FONT FACE="Georgia">Теперь предположим, что кто-то передал вам класс, реализующий 
  <b>Comparable</b>, или вы получаете класс, который реализует <b>Comparable</b>, 
  но вам не нравится способ, которым он работает и вы хотите в дальнейшем иметь 
  другую функцию сравнения для этого типа. Чтобы сделать это, вы используете второй 
  подход для сравнения объектов, создавая отдельный класс, который реализует интерфейс, 
  называемый <a name="Index886"></a><b>Comparator</b>. Он имеет два метода: <b>compare(&#160;)</b> 
  и <b>equals(&#160;)</b>. Однако вам не нужно реализовывать <b>equals(&#160;)</b> 
  за исключением случаев, требующих особой производительности, потому что всегда, 
  когда вы создаете класс, он обязательно наследуется от <b>Object</b>, который 
  имеет метод <b>equals(&#160;)</b>. Так что вы просто можете использовать по 
  умолчанию <b>Object</b> <b>equals(&#160;)</b> и удовлетворится договоренностями, 
  налагаемыми интерфейсами.</FONT></P>
<DIV ALIGN="LEFT"></DIV>
<P><FONT FACE="Georgia">Класс <B>Collections</B> (который мы рассмотрим немного 
  позже) содержит только <b>Comparator</b>, который меняет порядок сортировки 
  на обратный естественному. Это легко может быть применено к <b>CompType</b>:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:Reverse.java</font>
<font color=#009900>// Collecions.reverseOrder() Comparator.</font>
<font color=#0000ff>import</font> com.bruceeckel.util.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Reverse {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    CompType[] a = <font color=#0000ff>new</font> CompType[10];
    Arrays2.fill(a, CompType.generator());
    Arrays2.print(<font color=#004488>"before sorting, a = "</font>, a);
    Arrays.sort(a, Collections.reverseOrder());
    Arrays2.print(<font color=#004488>"after sorting, a = "</font>, a);
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><A NAME="Index887"></A><FONT FACE="Georgia">Вызов <B>Collections.reverseOrder(&#160;)</B> 
  производит ссылку на <B>Comparator</B>.</FONT></P>
<P><FONT FACE="Georgia">В качестве второго примера <B>Comparator</B> сравнивает 
  объекты <B>CompType</B>, основываясь на их значениях <B>j</B>, а не на их значениях 
  <B>i</B>:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:ComparatorTest.java</font>
<font color=#009900>// Реализация Comparator для класса.</font>
<font color=#0000ff>import</font> com.bruceeckel.util.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> CompTypeComparator <font color=#0000ff>implements</font> Comparator {
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> compare(Object o1, Object o2) {
    <font color=#0000ff>int</font> j1 = ((CompType)o1).j;
    <font color=#0000ff>int</font> j2 = ((CompType)o2).j;
    <font color=#0000ff>return</font> (j1 &lt; j2 ? -1 : (j1 == j2 ? 0 : 1));
  }
}
           
<font color=#0000ff>public</font> <font color=#0000ff>class</font> ComparatorTest {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    CompType[] a = <font color=#0000ff>new</font> CompType[10];
    Arrays2.fill(a, CompType.generator());
    Arrays2.print(<font color=#004488>"before sorting, a = "</font>, a);
    Arrays.sort(a, <font color=#0000ff>new</font> CompTypeComparator());
    Arrays2.print(<font color=#004488>"after sorting, a = "</font>, a);
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Метод <B>compare(&#160;)</B> должен возвращать отрицательное, 
  нулевое или положительное значение, если первый аргумент меньше, равен или больше 
  второго, соответственно.</FONT><A NAME="_Toc481064673"></A></P>
<A NAME="Heading286"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Сортировка массива</H3>
</FONT> 
<P><FONT FACE="Georgia">С помощью встроенного метода сортировки вы можете сортировать 
  любой массив примитивных типов и любой массив объектов, который реализует <b>Comparable</b> 
  или имеет ассоциированный <b>Comparator</b>. Таким образом, заполняется большая 
  дыра в библиотеке Java &#8212; верите или нет, но в Java 1.0 или 1.1 не было 
  поддержки для сортировки <b>String</b>! Вот пример, который генерирует случайным 
  образом объекты <b>String</b> и сортирует их:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:StringSorting.java</font>
<font color=#009900>// Сортировка массива Strings.</font>
<font color=#0000ff>import</font> com.bruceeckel.util.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> StringSorting {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    String[] sa = <font color=#0000ff>new</font> String[30];
    Arrays2.fill(sa,
      <font color=#0000ff>new</font> Arrays2.RandStringGenerator(5));
    Arrays2.print(<font color=#004488>"Before sorting: "</font>, sa);
    Arrays.sort(sa);
    Arrays2.print(<font color=#004488>"After sorting: "</font>, sa);
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Одно вы должны заметить об алгоритме сортировки при выводе 
  <b>String</b> - это <a name="Index888"></a><a name="Index889"></a><a name="Index890"></a><i>лексикография</i>, 
  которая помещает все слова, начинающиеся с большой буквы, вперед, а далее следуют 
  все слова, начинающиеся с маленьких букв. (Телефонные книги обычно упорядочены 
  таким образом.) Вы можете также сгруппировать слова вместе, не зависимо от регистра, 
  и вы можете сделать это, определив класс <b>Comparator</b> и, таким образом, 
  перегрузив поведение по умолчанию для <b>String Comparable</b>. Для повторного 
  использования это будет добавлено в пакет &#8220;util&#8221;:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: com:bruceeckel:util:AlphabeticComparator.java</font>
<font color=#009900>// Собираем вместе большие и маленькие буквы.</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> AlphabeticComparator 
<font color=#0000ff>implements</font> Comparator{
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> compare(Object o1, Object o2) {
    String s1 = (String)o1;
    String s2 = (String)o2;
    <font color=#0000ff>return</font> s1.toLowerCase().compareTo(
      s2.toLowerCase());
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Каждый <B>String</B> преобразуется в нижний регистр перед 
  сравнением. Встроенный метод <b>compareTo(&#160;)</b> для <b>String</b> обеспечивает 
  желаемую функциональность.</FONT></P>
<P><FONT FACE="Georgia">Вот тест использования <B>AlphabeticComparator</B>:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:AlphabeticSorting.java</font>
<font color=#009900>//Собираем вместе большие и маленькие буквы.</font>
<font color=#0000ff>import</font> com.bruceeckel.util.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> AlphabeticSorting {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    String[] sa = <font color=#0000ff>new</font> String[30];
    Arrays2.fill(sa,
      <font color=#0000ff>new</font> Arrays2.RandStringGenerator(5));
    Arrays2.print(<font color=#004488>"Before sorting: "</font>, sa);
    Arrays.sort(sa, <font color=#0000ff>new</font> AlphabeticComparator());
    Arrays2.print(<font color=#004488>"After sorting: "</font>, sa);
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Алгоритм сортировки, который используется в стандартной 
  библиотеке Java, оптимально предназначен для определенного типа, сортируемого 
  вами &#8212; быстрая сортировка для примитивных типов соизмерима по скорости 
  с сортировкой для объектов. Так что вам нет необходимости тратить какое-то время 
  на заботу о производительности, пока ваш инструмент профилирования не укажет 
  на процесс сортировки, как на узкое место.</FONT><A NAME="_Toc481064674"></A></P>
<A NAME="Heading287"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Поиск в отсортированном массиве<A NAME="Index891"></A></H3>
</FONT> 
<P><FONT FACE="Georgia">Как только массив отсортирован, вы можете выполнить быстрый 
  поиск определенного элемента, используя <a name="Index892"></a><b>Arrays.binarySearch(&#160;)</b>. 
  Однако очень важно, чтобы вы не пробовали использовать <a name="Index893"></a><b>binarySearch(&#160;)</b> 
  для не отсортированного массива, иначе получите непредсказуемый результат. Следующий 
  пример использует <b>RandIntGenerator</b> для заполнения массива, затем для 
  получения значений поиска:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:ArraySearching.java</font>
<font color=#009900>// Использование Arrays.binarySearch().</font>
<font color=#0000ff>import</font> com.bruceeckel.util.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ArraySearching {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>int</font>[] a = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[100];
    Arrays2.RandIntGenerator gen = 
      <font color=#0000ff>new</font> Arrays2.RandIntGenerator(1000);
    Arrays2.fill(a, gen);
    Arrays.sort(a);
    Arrays2.print(<font color=#004488>"Sorted array: "</font>, a);
    <font color=#0000ff>while</font>(<font color=#0000ff>true</font>) {
      <font color=#0000ff>int</font> r = gen.next();
      <font color=#0000ff>int</font> location = Arrays.binarySearch(a, r);
      <font color=#0000ff>if</font>(location &gt;= 0) {
        System.out.println(<font color=#004488>"Location of "</font> + r + 
          <font color=#004488>" is "</font> + location + <font color=#004488>", a["</font> + 
          location + <font color=#004488>"] = "</font> + a[location]);
        <font color=#0000ff>break</font>; <font color=#009900>// выход из цикла</font>
      }
    }
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">В цикле <B>while</B> генерируются случайные значения в 
  качестве элементов поиска до тех пор, пока одно из них не будет найдено.</FONT></P>
<P><FONT FACE="Georgia"><B>Arrays.binarySearch(&#160;)</B> производит значение 
  большее или равное нулю, если элемент найден. В противном случае он производит 
  отрицательное значение, представляющее место, в котором этот элемент должен 
  быть вставлен, если вы имеете дело с отсортированным массивом. Производимое 
  значение - это</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE>-(точка вставки) - 1</PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Точка вставки - это индекс первого элемента, который больше 
  ключевого значения, или <b>a.size(&#160;)</b>, если все элементы массива меньше, 
  чем указанное значение.</FONT></P>
<P><FONT FACE="Georgia">Если массив содержит дублирующиеся элементы, то нет гарантии, 
  какой из них будет найден. Алгоритм реально не предназначен для поддержки поиска 
  одинаковых элементов, если они допускаются. Однако, если вам нужен отсортированный 
  список не дублируемых элементов, используйте <b>TreeSet</b>, который будет введен 
  позже в этой главе. Он заботится обо всех деталях автоматически. Только в случае 
  узкого места производительности вы должны заменить <b>TreeSet</b> на массив, 
  управляемый в ручную.</FONT></P>
<P><FONT FACE="Georgia">Если у вас есть отсортированный массив объектов с использованием 
  <b>Comparator</b> (массивы примитивных типов не позволяют выполнять сортировку 
  с использованием <b>Comparator</b>), вы должны включить этот же самый <b>Comparator</b>, 
  когда выполняете <b>binarySearch(&#160;)</b> (используя перегруженную версию 
  прилагаемой функции). Например, программа <b>AlphabeticSorting.java</b> может 
  быть модифицирована для выполнения поиска:</FONT></P>
<DIV ALIGN="LEFT"></DIV>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:AlphabeticSearch.java</font>
<font color=#009900>// Поиск с использованием Comparator.</font>
<font color=#0000ff>import</font> com.bruceeckel.util.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> AlphabeticSearch {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    String[] sa = <font color=#0000ff>new</font> String[30];
    Arrays2.fill(sa,
      <font color=#0000ff>new</font> Arrays2.RandStringGenerator(5));
    AlphabeticComparator comp =
      <font color=#0000ff>new</font> AlphabeticComparator();
    Arrays.sort(sa, comp);
    <font color=#0000ff>int</font> index =
      Arrays.binarySearch(sa, sa[10], comp);
    System.out.println(<font color=#004488>"Index = "</font> + index);
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia"><B>Comparator</B> должен передаваться в перегруженный 
  метод <B>binarySearch(&#160;)</B> в качестве третьего аргумента. В приведенном 
  выше примере успех гарантирован, потому что ищется элемент, выдернутый из массива.</FONT><A NAME="_Toc481064675"></A></P>
<A NAME="Heading288"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Резюме о массивах</H3>
</FONT> 
<P><FONT FACE="Georgia">Чтобы суммировать все виденное вами до этих пор, можно 
  сказать, что вашим первым и наиболее эффективным выбором для поддержки группы 
  объектов должен быть массив, и вы ограничены в своем выборе, если хотите держать 
  группу примитивов. В оставшейся части этой главы мы посмотрим более общий случай, 
  когда вы не знаете во время написания программы, сколько объектов вам будет 
  необходимо, или если вам нужен более изощренный способ хранения ваших объектов. 
  Java обеспечивает библиотеку <a name="Index894"></a><i>контейнерных классов</i> 
  для решения этой проблемы, основными типами которой являются <a name="Index895"></a><b>List</b>, 
  <a name="Index896"></a><b>Set</b> и <a name="Index897"></a><b>Map</b>. Используя 
  эти инструменты, вы можете решить удивительно много проблем.</FONT></P>
<P><FONT FACE="Georgia">Наряду со своими остальными характеристиками, <b>Set</b>, 
  например, содержит только один объект каждого значения, а <b>Map</b> - это <a name="Index898"></a><i>ассоциированный 
  массив</i>, позволяющий вам ассоциировать объект с любым другим объектом, контейнерный 
  классы Java автоматически изменяют свой размер. Так что, в отличие от массивов, 
  вы можете поместить в контейнер любое число объектов и вам нет необходимости 
  заботиться о величине контейнера во время написания программы.</FONT><A NAME="_Toc481064676"></A></P>
<DIV ALIGN="LEFT"></DIV>
<A NAME="Heading289"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Введение в контейнеры</H2>
</FONT> 
<P><FONT FACE="Georgia">Для меня контейнерные классы - это один из самых мощных 
  инструментов для первоначальной разработки, потому что они значительно увеличивают 
  вашу программистскую мысль. Контейнеры <a name="Index899"></a><a name="Index900"></a>Java 
  2 представляют полную переделку <a href="#fn47">[47]</a> слабых ранних попыток 
  Java1.0 и 1.1. Некоторые из переделок сделали вещи компактнее и более чувствительным. 
  Также была добавлена функциональность в библиотеку контейнеров, обеспечивающая 
  поведение <a name="Index901"></a>связанных списков, <a name="Index902"></a>очередей 
  и <a name="Index903"></a>двусторонних очередей (называемой &#8220;decks&#8221;).</FONT></P>
<P><FONT FACE="Georgia">Разработка библиотеки контейнеров достаточно сложна (это 
  правда для большинства проблем разработки библиотеки). В <a name="Index904"></a><a name="Index905"></a>C++ 
  контейнерные классы охватывают многие другие классы. Это было лучше, чем то, 
  что имелось до появления контейнерных классов C++ (ничего), но это нельзя было 
  хорошо перевести в Java. Другой крайний случай я вижу в том, что библиотека 
  контейнеров содержит единственный класс - &#8220;контейнер&#8221;, который ведет 
  себя и как линейная последовательность, и как ассоциированный массив одновременно. 
  Библиотека контейнеров Java 2 сохраняет баланс: полная функциональность, которую 
  вы ожидаете от зрелой библиотеки контейнеров, сочетается с легкостью изучения 
  и использования - вот что отличает эту библиотеку от библиотеки контейнерных 
  классов С++ и других схожих библиотек контейнеров. Результат может казаться 
  немного странным. В отличие от некоторых решений, сделанных в ранних версиях 
  библиотеки Java, эта странность не случайна, а была основана на тщательном рассмотрении 
  решений, основанных на компромиссе в сложности. Может пройти какое-то время, 
  прежде чем вы почувствуете себя комфортно с некоторыми аспектами библиотеки, 
  но я думаю, что вы пройдете это быстро и будете использовать эти новые инструменты.</FONT></P>
<P><FONT FACE="Georgia">Библиотека контейнеров Java 2 принимается за проблему 
  &#8220;хранения ваших объектов&#8221; и делит ее на две отдельные концепции:<A NAME="Index906"></A><A NAME="Index907"></A><A NAME="Index908"></A><A NAME="Index909"></A><A NAME="Index910"></A></FONT></P>
<DIV ALIGN="LEFT"></DIV>
<OL>
  <LI><FONT FACE="Verdana"><B> </B></FONT><FONT FACE="Georgia"><B>Коллекция</B>: 
    группа индивидуальных элементов, часто с определенными правилами, применяемыми 
    к элементам. <B>Список</B> должен хранить элементы в определенной последовательности, 
    а <B>Набор</B> не может иметь дублирующиеся элементы. (<i>Мешок</i>, который 
    не реализован в библиотеке контейнеров Java, так как <b>Списки</b> обеспечивают 
    вам достаточно функциональности, не имеет таких правил.)</FONT> 
  <LI><FONT FACE="Georgia"><B>Карта</B>: группа объектных пар ключ - значение. 
    На первый взгляд, это может выглядеть, как <b>Коллекция</b> пар, но когда 
    вы попробуете реализовать этим способом, дизайн станет неуклюжим, так что 
    будет понятнее выделить независимую концепцию. С другой стороны, это достаточно 
    последовательно, смотреть на часть <b>Карты</b>, как <b>Коллекцию</b>, представляющую 
    эту часть. Таким образом, Карта может возвращать <b>Набор</b> своих ключевых 
    значений, <b>Коллекцию</b> своих значений или <b>Набор</b> своих пар. <B>Карты</B>, 
    как и массивы, могут иметь несколько измерений без добавления новой концепции: 
    вы просто создаете <b>Карту</b>, чьими значениями являются другие карты (а 
    значениями этих <b>Карт</b> тоже могут быть <b>Карты</b> и т.д.).</FONT> 
</OL><DIV ALIGN="LEFT">
  <P><FONT FACE="Georgia">Сначала мы рассмотрим общие особенности контейнеров, 
    затем перейдем к деталям, и под конец узнаем, почему есть разные версии одних 
    и тех же контейнеров и как выбирать между ними.</FONT><A NAME="_Ref348399494"></A><A NAME="_Toc375545351"></A><A NAME="_Toc481064677"></A></P>
</DIV>
<A NAME="Heading290"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Распечатка контейнера</H3>
</FONT>
<P><FONT FACE="Georgia">В отличие от массива, контейнеры прекрасно распечатываются 
  без любой помощи. Вот пример, который также вводит основные типы контейнеров:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:PrintingContainers.java</font>
<font color=#009900>// Контейнеры распечатывают себя автоматически.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> PrintingContainers {
  <font color=#0000ff>static</font> Collection fill(Collection c) {
    c.add(<font color=#004488>"dog"</font>);
    c.add(<font color=#004488>"dog"</font>);
    c.add(<font color=#004488>"cat"</font>);
    <font color=#0000ff>return</font> c;
  }
  <font color=#0000ff>static</font> Map fill(Map m) {
    m.put(<font color=#004488>"dog"</font>, <font color=#004488>"Bosco"</font>);
    m.put(<font color=#004488>"dog"</font>, <font color=#004488>"Spot"</font>);
    m.put(<font color=#004488>"cat"</font>, <font color=#004488>"Rags"</font>);
    <font color=#0000ff>return</font> m;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    System.out.println(fill(<font color=#0000ff>new</font> ArrayList()));
    System.out.println(fill(<font color=#0000ff>new</font> HashSet()));
    System.out.println(fill(<font color=#0000ff>new</font> HashMap()));
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Как упомянуто ранее, есть две основных категории в библиотеке 
  контейнеров Java. Различие основывается на числе элементов, содержащихся в каждой 
  ячейке контейнера. Категория <b>Collection</b> (коллекция) хранит только один 
  элемент в каждой ячейке (имя немного вводит в заблуждение, так как любая библиотека 
  контейнеров часто называется &#8220;collections&#8221;). Сюда включается <b>List</b> 
  (список), который хранит группы элементов в указанном порядке, и <b>Set </b>(набор), 
  который позволяет добавление одного элемента каждого типа. <b>ArrayList</b> 
  - это тип <b>List</b>, а <b>HashSet </b>- это тип <b>Set</b>. Для добавление 
  элементов в любой из <b>Collection</b> существует метод <b>add(&#160;)</b>.</FONT></P>
<P><FONT FACE="Georgia"> <B>Map</B> (карта) хранит пары ключ-значение, что похоже 
  на мини базу данных. Приведенная выше программа использует одну часть букета 
  <b>Map</b> - <b>HashMap</b>. Если вы имеете <b>Map</b>, ассоциированную со штатами, 
  и вы хотите узнать столицу Огайо, вы ищите его так, как будто вы просматриваете 
  индексированный массив. (Карты также называются <a name="Index911"></a><a name="Index912"></a><i>ассоциативным 
  массивом</i>.) Для добавления элемента в <b>Map</b> существует метод <b>put(&#160;)</b>, 
  который принимает ключ и значение в качестве аргументов. Приведенный выше пример 
  показывает только добавление элементов, но не ищет элементы после добавления. 
  Это будет показано позднее.</FONT></P>
<P><FONT FACE="Georgia">Перегруженный метод <b>fill(&#160;)</b> заполняет <b>Collection</b> 
  и <b>Map</b>, соответственно. Если вы посмотрите на то, что получается на выводе, 
  вы сможете увидеть, что поведение печати по умолчанию (обеспечиваемое через 
  разные методы контейнеров <b>toString(&#160;)</b>) производят плохо читаемый 
  результат, так как не печатается необходимая дополнительная информация, как 
  это было с массивами:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>[dog, dog, cat]
[cat, dog]
{cat=Rags, dog=Spot}</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia"> <B>Collection</B> распечатывается путем окружения квадратными 
  скобками, а каждый элемент разделяется запятой. <b>Map</b> окружается фигурными 
  скобками, а каждый ключ и ассоциированное с ним значение соединяется знаком 
  равенства (ключ слева, а значение справа).</FONT></P>
<P><FONT FACE="Georgia">Вы немедленно можете увидеть различия в поведении разных 
  контейнеров. <b>List</b> хранит объекты точно так, как они были введены, без 
  изменения порядка или редактирования. Однако <b>Set</b> принял по одному экземпляру 
  каждого объекта и использовал свой внутренний метод упорядочивания (в общем, 
  обычно заботитесь только о том, является ли что-то или нет членом <b>Set</b>, 
  а не порядок, в котором оно появится &#8212; для этого вы используете <b>List</b>). 
  <b>Map</b> тоже принимает только по одному значению для каждого элемента, основываясь 
  на ключе, и он также имеет свое собственное внутреннее упорядочивание и не заботится 
  о том порядке, в котором вы вводили элементы.</FONT><A NAME="_Toc481064678"></A></P>
<DIV ALIGN="LEFT"></DIV>
<A NAME="Heading291"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Заполнение контейнеров</H3>
</FONT>
<DIV ALIGN="LEFT"> 
  <P><FONT FACE="Georgia">Хотя проблему печати контейнеры берут на себя, заполнение 
    контейнеров имеет те же недостатки, что и <b>java.util.Arrays</b>. Как и <b>Arrays</b>, 
    есть общий класс, называемый <b>Collections</b>, который содержит <b>статические</b> 
    методы утилит, включаю одну из них, называемую <a name="Index913"></a><b>fill(&#160;)</b>. 
    Этот <b>fill(&#160;)</b> также просто дублирует единственную ссылку объекта, 
    помещая ее в контейнер, и также работает только для объектов <b>List</b>, 
    а не для <b>Set</b> или <b>Map</b>:</FONT></P>
  </DIV>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:FillingLists.java</font>
<font color=#009900>// Метод Collections.fill().</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> FillingLists {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    List list = <font color=#0000ff>new</font> ArrayList();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
      list.add(<font color=#004488>""</font>);
    Collections.fill(list, <font color=#004488>"Hello"</font>);
    System.out.println(list);
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Этот метод делает мало полезного, он может только заменять 
  элементы, которые уже внесены в <b>List</b>, и не добавляет новых элементов.</FONT></P>
<P><FONT FACE="Georgia">Чтобы быть способными создавать интересные примеры, здесь 
  введена дополнительная библиотека <b>Collections2</b> (по соглашению, часть 
  <b>com.bruceeckel.util</b>) с методом <b>fill(&#160;)</b>, который использует 
  <a name="Index914"></a>генератор для добавления элементов и позволяет вам указывать 
  число элементов, которые вы хотите добавить (<b>add(&#160;)</b>). <b>Generator 
  interface</b>, определенный ранее, будет работать для <b>Collection</b>, но 
  <b>Map</b> требует своего собственного интерфейса генератора, так как должны 
  производится пары объектов (один - ключ, второй - значение) при каждом вызове 
  <b>next(&#160;)</b>. Вот класс <b>Pair</b>:</FONT></P>
<DIV ALIGN="LEFT"></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: com:bruceeckel:util:Pair.java</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>public</font> <font color=#0000ff>class</font> Pair {
  <font color=#0000ff>public</font> Object key, value;
  Pair(Object k, Object v) {
    key = k;
    value = v;
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Далее, интерфейс генератора, который производит <B>Pair</B>:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: com:bruceeckel:util:MapGenerator.java</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>public</font> <font color=#0000ff>interface</font> MapGenerator {
  Pair next();
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">С этим могут быть разработан набор утилит, работающих 
  с <a name="Index915"></a>контейнерными классами:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"> 
  <PRE><font color=#009900>//: com:bruceeckel:util:Collections2.java</font>
<font color=#009900>// Для заполнения контейнера любого типа</font>
<font color=#009900>//используйте объект генератора.</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Collections2 {
  <font color=#009900>// Заполнение массива с помощью генератора:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  fill(Collection c, Generator gen, <font color=#0000ff>int</font> count) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; count; i++)
      c.add(gen.next());
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  fill(Map m, MapGenerator gen, <font color=#0000ff>int</font> count) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; count; i++) {
      Pair p = gen.next();
      m.put(p.key, p.value);
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> RandStringPairGenerator
  <font color=#0000ff>implements</font> MapGenerator {
    <font color=#0000ff>private</font> Arrays2.RandStringGenerator gen;
    <font color=#0000ff>public</font> RandStringPairGenerator(<font color=#0000ff>int</font> len) {
      gen = <font color=#0000ff>new</font> Arrays2.RandStringGenerator(len);
    }
    <font color=#0000ff>public</font> Pair next() {
      <font color=#0000ff>return</font> <font color=#0000ff>new</font> Pair(gen.next(), gen.next());
    }
  }
  <font color=#009900>// Объект по умолчанию, так что вам не нужно</font>
  <font color=#009900>// создавать свой собственный:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> RandStringPairGenerator rsp =
    <font color=#0000ff>new</font> RandStringPairGenerator(10);
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> StringPairGenerator
  <font color=#0000ff>implements</font> MapGenerator {
    <font color=#0000ff>private</font> <font color=#0000ff>int</font> index = -1;
    <font color=#0000ff>private</font> String[][] d;
    <font color=#0000ff>public</font> StringPairGenerator(String[][] data) {
      d = data;
    }
    <font color=#0000ff>public</font> Pair next() {
      <font color=#009900>// заставляем индекс меняться:</font>
      index = (index + 1) % d.length;
      <font color=#0000ff>return</font> <font color=#0000ff>new</font> Pair(d[index][0], d[index][1]);
    }
    <font color=#0000ff>public</font> StringPairGenerator reset() { 
      index = -1; 
      <font color=#0000ff>return</font> <font color=#0000ff>this</font>;
    }
  }
  <font color=#009900>// Используем предопределенный набор данных:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> StringPairGenerator geography =
    <font color=#0000ff>new</font> StringPairGenerator(
      CountryCapitals.pairs);
  <font color=#009900>// Производим последовательность из двумерного массива:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> StringGenerator
  <font color=#0000ff>implements</font> Generator {
    <font color=#0000ff>private</font> String[][] d;
    <font color=#0000ff>private</font> <font color=#0000ff>int</font> position;
    <font color=#0000ff>private</font> <font color=#0000ff>int</font> index = -1;
    <font color=#0000ff>public</font> 
    StringGenerator(String[][] data, <font color=#0000ff>int</font> pos) {
      d = data;
      position = pos;
    }
    <font color=#0000ff>public</font> Object next() {
      <font color=#009900>// заставляем индекс меняться:</font>
      index = (index + 1) % d.length;
      <font color=#0000ff>return</font> d[index][position];
    }
    <font color=#0000ff>public</font> StringGenerator reset() { 
      index = -1;
      <font color=#0000ff>return</font> <font color=#0000ff>this</font>;
    }
  }
  <font color="#009900">// Используем предопределенный набор данных:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> StringGenerator countries =
    <font color=#0000ff>new</font> StringGenerator(CountryCapitals.pairs,0);
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> StringGenerator capitals =
    <font color=#0000ff>new</font> StringGenerator(CountryCapitals.pairs,1);
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Обе версии <b>fill(&#160;)</b> принимают аргументы, которые 
  определяют число элементов для добавления в контейнер. Кроме того, есть два 
  генератора для карты: <b>RandStringPairGenerator</b>, который создает любое 
  число пар тарабарских <b>String</b>, с длиной, определяемой аргументом конструктора; 
  и <b>StringPairGenerator</b>, который производит пары <b>String</b>, выдавая 
  двумерный массив <b>String</b>. <b>StringGenerator</b> также получает двумерный 
  массив <b>String</b>, а генерирует единственный элемент типа <b>Pair</b>.<b> 
  </b>Объекты <b>static rsp</b>, <b>geography</b>,<b> countries</b> и <b>capitals</b> 
  обеспечивают предварительно построенные генераторы, последние три используют 
  все страны мира и их столицы. Обратите внимание, что если вы пробуете создать 
  больше пар, чем имеется, генератор зациклится, вернувшись в начало, и, если 
  вы поместите пару в <b>Map</b>, дублирование просто игнорируется.</FONT></P>
<P><FONT FACE="Georgia">Здесь предопределенный набор данных, который содержит 
  названия государств и их столиц. Они написаны маленькими буквами, чтобы предотвратить 
  появление лишнего пространства:</FONT></P>
<DIV ALIGN="LEFT"></DIV>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: com:bruceeckel:util:CountryCapitals.java</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>public</font> <font color=#0000ff>class</font> CountryCapitals {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>final</font> String[][] pairs = {
    <font color=#009900>// Африка</font>
    {<font color=#004488>"ALGERIA"</font>,<font color=#004488>"Algiers"</font>}, {<font color=#004488>"ANGOLA"</font>,<font color=#004488>"Luanda"</font>},
    {<font color=#004488>"BENIN"</font>,<font color=#004488>"Porto-Novo"</font>}, {<font color=#004488>"BOTSWANA"</font>,<font color=#004488>"Gaberone"</font>},
    {<font color=#004488>"BURKINA FASO"</font>,<font color=#004488>"Ouagadougou"</font>}, {<font color=#004488>"BURUNDI"</font>,<font color=#004488>"Bujumbura"</font>},
    {<font color=#004488>"CAMEROON"</font>,<font color=#004488>"Yaounde"</font>}, {<font color=#004488>"CAPE VERDE"</font>,<font color=#004488>"Praia"</font>},
    {<font color=#004488>"CENTRAL AFRICAN REPUBLIC"</font>,<font color=#004488>"Bangui"</font>},
    {<font color=#004488>"CHAD"</font>,<font color=#004488>"N'djamena"</font>},  {<font color=#004488>"COMOROS"</font>,<font color=#004488>"Moroni"</font>},
    {<font color=#004488>"CONGO"</font>,<font color=#004488>"Brazzaville"</font>}, {<font color=#004488>"DJIBOUTI"</font>,<font color=#004488>"Dijibouti"</font>},
    {<font color=#004488>"EGYPT"</font>,<font color=#004488>"Cairo"</font>}, {<font color=#004488>"EQUATORIAL GUINEA"</font>,<font color=#004488>"Malabo"</font>},
    {<font color=#004488>"ERITREA"</font>,<font color=#004488>"Asmara"</font>}, {<font color=#004488>"ETHIOPIA"</font>,<font color=#004488>"Addis Ababa"</font>},
    {<font color=#004488>"GABON"</font>,<font color=#004488>"Libreville"</font>}, {<font color=#004488>"THE GAMBIA"</font>,<font color=#004488>"Banjul"</font>},
    {<font color=#004488>"GHANA"</font>,<font color=#004488>"Accra"</font>}, {<font color=#004488>"GUINEA"</font>,<font color=#004488>"Conakry"</font>},
    {<font color=#004488>"GUINEA"</font>,<font color=#004488>"-"</font>}, {<font color=#004488>"BISSAU"</font>,<font color=#004488>"Bissau"</font>},
    {<font color=#004488>"CETE D'IVOIR (IVORY COAST)"</font>,<font color=#004488>"Yamoussoukro"</font>},
    {<font color=#004488>"KENYA"</font>,<font color=#004488>"Nairobi"</font>}, {<font color=#004488>"LESOTHO"</font>,<font color=#004488>"Maseru"</font>},
    {<font color=#004488>"LIBERIA"</font>,<font color=#004488>"Monrovia"</font>}, {<font color=#004488>"LIBYA"</font>,<font color=#004488>"Tripoli"</font>},
    {<font color=#004488>"MADAGASCAR"</font>,<font color=#004488>"Antananarivo"</font>}, {<font color=#004488>"MALAWI"</font>,<font color=#004488>"Lilongwe"</font>},
    {<font color=#004488>"MALI"</font>,<font color=#004488>"Bamako"</font>}, {<font color=#004488>"MAURITANIA"</font>,<font color=#004488>"Nouakchott"</font>},
    {<font color=#004488>"MAURITIUS"</font>,<font color=#004488>"Port Louis"</font>}, {<font color=#004488>"MOROCCO"</font>,<font color=#004488>"Rabat"</font>},
    {<font color=#004488>"MOZAMBIQUE"</font>,<font color=#004488>"Maputo"</font>}, {<font color=#004488>"NAMIBIA"</font>,<font color=#004488>"Windhoek"</font>},
    {<font color=#004488>"NIGER"</font>,<font color=#004488>"Niamey"</font>}, {<font color=#004488>"NIGERIA"</font>,<font color=#004488>"Abuja"</font>},
    {<font color=#004488>"RWANDA"</font>,<font color=#004488>"Kigali"</font>}, {<font color=#004488>"SAO TOME E PRINCIPE"</font>,<font color=#004488>"Sao Tome"</font>},
    {<font color=#004488>"SENEGAL"</font>,<font color=#004488>"Dakar"</font>}, {<font color=#004488>"SEYCHELLES"</font>,<font color=#004488>"Victoria"</font>},
    {<font color=#004488>"SIERRA LEONE"</font>,<font color=#004488>"Freetown"</font>}, {<font color=#004488>"SOMALIA"</font>,<font color=#004488>"Mogadishu"</font>},
    {<font color=#004488>"SOUTH AFRICA"</font>,<font color=#004488>"Pretoria</font><font color=#004488>/Cape Town"</font>}, {<font color=#004488>"SUDAN"</font>,<font color=#004488>"Khartoum"</font>},
    {<font color=#004488>"SWAZILAND"</font>,<font color=#004488>"Mbabane"</font>}, {<font color=#004488>"TANZANIA"</font>,<font color=#004488>"Dodoma"</font>},
    {<font color=#004488>"TOGO"</font>,<font color=#004488>"Lome"</font>}, {<font color=#004488>"TUNISIA"</font>,<font color=#004488>"Tunis"</font>},
    {<font color=#004488>"UGANDA"</font>,<font color=#004488>"Kampala"</font>},
    {<font color=#004488>"DEMOCRATIC REPUBLIC OF THE CONGO (ZAIRE)"</font>,<font color=#004488>"Kinshasa"</font>},
    {<font color=#004488>"ZAMBIA"</font>,<font color=#004488>"Lusaka"</font>}, {<font color=#004488>"ZIMBABWE"</font>,<font color=#004488>"Harare"</font>},
    <font color=#009900>// Азия</font>
    {<font color=#004488>"AFGHANISTAN"</font>,<font color=#004488>"Kabul"</font>}, {<font color=#004488>"BAHRAIN"</font>,<font color=#004488>"Manama"</font>},
    {<font color=#004488>"BANGLADESH"</font>,<font color=#004488>"Dhaka"</font>}, {<font color=#004488>"BHUTAN"</font>,<font color=#004488>"Thimphu"</font>},
    {<font color=#004488>"BRUNEI"</font>,<font color=#004488>"Bandar Seri Begawan"</font>}, {<font color=#004488>"CAMBODIA"</font>,<font color=#004488>"Phnom Penh"</font>},
    {<font color=#004488>"CHINA"</font>,<font color=#004488>"Beijing"</font>}, {<font color=#004488>"CYPRUS"</font>,<font color=#004488>"Nicosia"</font>},
    {<font color=#004488>"INDIA"</font>,<font color=#004488>"New Delhi"</font>}, {<font color=#004488>"INDONESIA"</font>,<font color=#004488>"Jakarta"</font>},
    {<font color=#004488>"IRAN"</font>,<font color=#004488>"Tehran"</font>}, {<font color=#004488>"IRAQ"</font>,<font color=#004488>"Baghdad"</font>},
    {<font color=#004488>"ISRAEL"</font>,<font color=#004488>"Jerusalem"</font>}, {<font color=#004488>"JAPAN"</font>,<font color=#004488>"Tokyo"</font>},
    {<font color=#004488>"JORDAN"</font>,<font color=#004488>"Amman"</font>}, {<font color=#004488>"KUWAIT"</font>,<font color=#004488>"Kuwait City"</font>},
    {<font color=#004488>"LAOS"</font>,<font color=#004488>"Vientiane"</font>}, {<font color=#004488>"LEBANON"</font>,<font color=#004488>"Beirut"</font>},
    {<font color=#004488>"MALAYSIA"</font>,<font color=#004488>"Kuala Lumpur"</font>}, {<font color=#004488>"THE MALDIVES"</font>,<font color=#004488>"Male"</font>},
    {<font color=#004488>"MONGOLIA"</font>,<font color=#004488>"Ulan Bator"</font>}, {<font color=#004488>"MYANMAR (BURMA)"</font>,<font color=#004488>"Rangoon"</font>},
    {<font color=#004488>"NEPAL"</font>,<font color=#004488>"Katmandu"</font>}, {<font color=#004488>"NORTH KOREA"</font>,<font color=#004488>"P'yongyang"</font>},
    {<font color=#004488>"OMAN"</font>,<font color=#004488>"Muscat"</font>}, {<font color=#004488>"PAKISTAN"</font>,<font color=#004488>"Islamabad"</font>},
    {<font color=#004488>"PHILIPPINES"</font>,<font color=#004488>"Manila"</font>}, {<font color=#004488>"QATAR"</font>,<font color=#004488>"Doha"</font>},
    {<font color=#004488>"SAUDI ARABIA"</font>,<font color=#004488>"Riyadh"</font>}, {<font color=#004488>"SINGAPORE"</font>,<font color=#004488>"Singapore"</font>},
    {<font color=#004488>"SOUTH KOREA"</font>,<font color=#004488>"Seoul"</font>}, {<font color=#004488>"SRI LANKA"</font>,<font color=#004488>"Colombo"</font>},
    {<font color=#004488>"SYRIA"</font>,<font color=#004488>"Damascus"</font>}, {<font color=#004488>"TAIWAN (REPUBLIC OF CHINA)"</font>,<font color=#004488>"Taipei"</font>},
    {<font color=#004488>"THAILAND"</font>,<font color=#004488>"Bangkok"</font>}, {<font color=#004488>"TURKEY"</font>,<font color=#004488>"Ankara"</font>},
    {<font color=#004488>"UNITED ARAB EMIRATES"</font>,<font color=#004488>"Abu Dhabi"</font>}, {<font color=#004488>"VIETNAM"</font>,<font color=#004488>"Hanoi"</font>},
    {<font color=#004488>"YEMEN"</font>,<font color=#004488>"Sana'a"</font>},
    <font color=#009900>// Австралия и Океания</font>
    {<font color=#004488>"AUSTRALIA"</font>,<font color=#004488>"Canberra"</font>}, {<font color=#004488>"FIJI"</font>,<font color=#004488>"Suva"</font>},
    {<font color=#004488>"KIRIBATI"</font>,<font color=#004488>"Bairiki"</font>},
    {<font color=#004488>"MARSHALL ISLANDS"</font>,<font color=#004488>"Dalap-Uliga-Darrit"</font>},
    {<font color=#004488>"MICRONESIA"</font>,<font color=#004488>"Palikir"</font>}, {<font color=#004488>"NAURU"</font>,<font color=#004488>"Yaren"</font>},
    {<font color=#004488>"NEW ZEALAND"</font>,<font color=#004488>"Wellington"</font>}, {<font color=#004488>"PALAU"</font>,<font color=#004488>"Koror"</font>},
    {<font color=#004488>"PAPUA NEW GUINEA"</font>,<font color=#004488>"Port Moresby"</font>},
    {<font color=#004488>"SOLOMON ISLANDS"</font>,<font color=#004488>"Honaira"</font>}, {<font color=#004488>"TONGA"</font>,<font color=#004488>"Nuku'alofa"</font>},
    {<font color=#004488>"TUVALU"</font>,<font color=#004488>"Fongafale"</font>}, {<font color=#004488>"VANUATU"</font>,<font color=#004488>"&lt; Port-Vila"</font>},
    {<font color=#004488>"WESTERN SAMOA"</font>,<font color=#004488>"Apia"</font>},
    <font color=#009900>// Восточная Европа и бывшая СССР</font>
    {<font color=#004488>"ARMENIA"</font>,<font color=#004488>"Yerevan"</font>}, {<font color=#004488>"AZERBAIJAN"</font>,<font color=#004488>"Baku"</font>},
    {<font color=#004488>"BELARUS (BYELORUSSIA)"</font>,<font color=#004488>"Minsk"</font>}, {<font color=#004488>"GEORGIA"</font>,<font color=#004488>"Tbilisi"</font>},
    {<font color=#004488>"KAZAKSTAN"</font>,<font color=#004488>"Almaty"</font>}, {<font color=#004488>"KYRGYZSTAN"</font>,<font color=#004488>"Alma-Ata"</font>},
    {<font color=#004488>"MOLDOVA"</font>,<font color=#004488>"Chisinau"</font>}, {<font color=#004488>"RUSSIA"</font>,<font color=#004488>"Moscow"</font>},
    {<font color=#004488>"TAJIKISTAN"</font>,<font color=#004488>"Dushanbe"</font>}, {<font color=#004488>"TURKMENISTAN"</font>,<font color=#004488>"Ashkabad"</font>},
    {<font color=#004488>"UKRAINE"</font>,<font color=#004488>"Kyiv"</font>}, {<font color=#004488>"UZBEKISTAN"</font>,<font color=#004488>"Tashkent"</font>},
    <font color=#009900>// Европа</font>
    {<font color=#004488>"ALBANIA"</font>,<font color=#004488>"Tirana"</font>}, {<font color=#004488>"ANDORRA"</font>,<font color=#004488>"Andorra la Vella"</font>},
    {<font color=#004488>"AUSTRIA"</font>,<font color=#004488>"Vienna"</font>}, {<font color=#004488>"BELGIUM"</font>,<font color=#004488>"Brussels"</font>},
    {<font color=#004488>"BOSNIA"</font>,<font color=#004488>"-"</font>}, {<font color=#004488>"HERZEGOVINA"</font>,<font color=#004488>"Sarajevo"</font>},
    {<font color=#004488>"CROATIA"</font>,<font color=#004488>"Zagreb"</font>}, {<font color=#004488>"CZECH REPUBLIC"</font>,<font color=#004488>"Prague"</font>},
    {<font color=#004488>"DENMARK"</font>,<font color=#004488>"Copenhagen"</font>}, {<font color=#004488>"ESTONIA"</font>,<font color=#004488>"Tallinn"</font>},
    {<font color=#004488>"FINLAND"</font>,<font color=#004488>"Helsinki"</font>}, {<font color=#004488>"FRANCE"</font>,<font color=#004488>"Paris"</font>},
    {<font color=#004488>"GERMANY"</font>,<font color=#004488>"Berlin"</font>}, {<font color=#004488>"GREECE"</font>,<font color=#004488>"Athens"</font>},
    {<font color=#004488>"HUNGARY"</font>,<font color=#004488>"Budapest"</font>}, {<font color=#004488>"ICELAND"</font>,<font color=#004488>"Reykjavik"</font>},
    {<font color=#004488>"IRELAND"</font>,<font color=#004488>"Dublin"</font>}, {<font color=#004488>"ITALY"</font>,<font color=#004488>"Rome"</font>},
    {<font color=#004488>"LATVIA"</font>,<font color=#004488>"Riga"</font>}, {<font color=#004488>"LIECHTENSTEIN"</font>,<font color=#004488>"Vaduz"</font>},
    {<font color=#004488>"LITHUANIA"</font>,<font color=#004488>"Vilnius"</font>}, {<font color=#004488>"LUXEMBOURG"</font>,<font color=#004488>"Luxembourg"</font>},
    {<font color=#004488>"MACEDONIA"</font>,<font color=#004488>"Skopje"</font>}, {<font color=#004488>"MALTA"</font>,<font color=#004488>"Valletta"</font>},
    {<font color=#004488>"MONACO"</font>,<font color=#004488>"Monaco"</font>}, {<font color=#004488>"MONTENEGRO"</font>,<font color=#004488>"Podgorica"</font>},
    {<font color=#004488>"THE NETHERLANDS"</font>,<font color=#004488>"Amsterdam"</font>}, {<font color=#004488>"NORWAY"</font>,<font color=#004488>"Oslo"</font>},
    {<font color=#004488>"POLAND"</font>,<font color=#004488>"Warsaw"</font>}, {<font color=#004488>"PORTUGAL"</font>,<font color=#004488>"Lisbon"</font>},
    {<font color=#004488>"ROMANIA"</font>,<font color=#004488>"Bucharest"</font>}, {<font color=#004488>"SAN MARINO"</font>,<font color=#004488>"San Marino"</font>},
    {<font color=#004488>"SERBIA"</font>,<font color=#004488>"Belgrade"</font>}, {<font color=#004488>"SLOVAKIA"</font>,<font color=#004488>"Bratislava"</font>},
    {<font color=#004488>"SLOVENIA"</font>,<font color=#004488>"Ljujiana"</font>}, {<font color=#004488>"SPAIN"</font>,<font color=#004488>"Madrid"</font>},
    {<font color=#004488>"SWEDEN"</font>,<font color=#004488>"Stockholm"</font>}, {<font color=#004488>"SWITZERLAND"</font>,<font color=#004488>"Berne"</font>},
    {<font color=#004488>"UNITED KINGDOM"</font>,<font color=#004488>"London"</font>}, {<font color=#004488>"VATICAN CITY"</font>,<font color=#004488>"---"</font>},
    <font color=#009900>// Северная и Центральная Америка</font>
    {<font color=#004488>"ANTIGUA AND BARBUDA"</font>,<font color=#004488>"Saint John's"</font>}, {<font color=#004488>"BAHAMAS"</font>,<font color=#004488>"Nassau"</font>},
    {<font color=#004488>"BARBADOS"</font>,<font color=#004488>"Bridgetown"</font>}, {<font color=#004488>"BELIZE"</font>,<font color=#004488>"Belmopan"</font>},
    {<font color=#004488>"CANADA"</font>,<font color=#004488>"Ottawa"</font>}, {<font color=#004488>"COSTA RICA"</font>,<font color=#004488>"San Jose"</font>},
    {<font color=#004488>"CUBA"</font>,<font color=#004488>"Havana"</font>}, {<font color=#004488>"DOMINICA"</font>,<font color=#004488>"Roseau"</font>},
    {<font color=#004488>"DOMINICAN REPUBLIC"</font>,<font color=#004488>"Santo Domingo"</font>},
    {<font color=#004488>"EL SALVADOR"</font>,<font color=#004488>"San Salvador"</font>}, {<font color=#004488>"GRENADA"</font>,<font color=#004488>"Saint George's"</font>},
    {<font color=#004488>"GUATEMALA"</font>,<font color=#004488>"Guatemala City"</font>}, {<font color=#004488>"HAITI"</font>,<font color=#004488>"Port-au-Prince"</font>},
    {<font color=#004488>"HONDURAS"</font>,<font color=#004488>"Tegucigalpa"</font>}, {<font color=#004488>"JAMAICA"</font>,<font color=#004488>"Kingston"</font>},
    {<font color=#004488>"MEXICO"</font>,<font color=#004488>"Mexico City"</font>}, {<font color=#004488>"NICARAGUA"</font>,<font color=#004488>"Managua"</font>},
    {<font color=#004488>"PANAMA"</font>,<font color=#004488>"Panama City"</font>}, {<font color=#004488>"ST. KITTS"</font>,<font color=#004488>"-"</font>},
    {<font color=#004488>"NEVIS"</font>,<font color=#004488>"Basseterre"</font>}, {<font color=#004488>"ST. LUCIA"</font>,<font color=#004488>"Castries"</font>},
    {<font color=#004488>"ST. VINCENT AND THE GRENADINES"</font>,<font color=#004488>"Kingstown"</font>},
    {<font color=#004488>"UNITED STATES OF AMERICA"</font>,<font color=#004488>"Washington, D.C."</font>},
    <font color=#009900>// Южная Америка</font>
    {<font color=#004488>"ARGENTINA"</font>,<font color=#004488>"Buenos Aires"</font>},
    {<font color=#004488>"BOLIVIA"</font>,<font color=#004488>"Sucre (legal)</font><font color=#004488>/La Paz(administrative)"</font>},
    {<font color=#004488>"BRAZIL"</font>,<font color=#004488>"Brasilia"</font>}, {<font color=#004488>"CHILE"</font>,<font color=#004488>"Santiago"</font>},
    {<font color=#004488>"COLOMBIA"</font>,<font color=#004488>"Bogota"</font>}, {<font color=#004488>"ECUADOR"</font>,<font color=#004488>"Quito"</font>},
    {<font color=#004488>"GUYANA"</font>,<font color=#004488>"Georgetown"</font>}, {<font color=#004488>"PARAGUAY"</font>,<font color=#004488>"Asuncion"</font>},
    {<font color=#004488>"PERU"</font>,<font color=#004488>"Lima"</font>}, {<font color=#004488>"SURINAME"</font>,<font color=#004488>"Paramaribo"</font>},
    {<font color=#004488>"TRINIDAD AND TOBAGO"</font>,<font color=#004488>"Port of Spain"</font>},
    {<font color=#004488>"URUGUAY"</font>,<font color=#004488>"Montevideo"</font>}, {<font color=#004488>"VENEZUELA"</font>,<font color=#004488>"Caracas"</font>},
  };
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Это простой двумерный массив данных типа <B>String</B> 
  </FONT><a href="#fn48">[48]</a><FONT FACE="Georgia">. Вот простой тест использования 
  метода <B>fill(&#160;)</B> и генераторов:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:FillTest.java</font>
<font color=#0000ff>import</font> com.bruceeckel.util.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> FillTest {
  <font color=#0000ff>static</font> Generator sg = 
    <font color=#0000ff>new</font> Arrays2.RandStringGenerator(7);
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    List list = <font color=#0000ff>new</font> ArrayList();
    Collections2.fill(list, sg, 25);
    System.out.println(list + <font color=#004488>"\n"</font>);
    List list2 = <font color=#0000ff>new</font> ArrayList();
    Collections2.fill(list2, 
      Collections2.capitals, 25);
    System.out.println(list2 + <font color=#004488>"\n"</font>);
    Set set = <font color=#0000ff>new</font> HashSet();
    Collections2.fill(set, sg, 25);
    System.out.println(set + <font color=#004488>"\n"</font>);
    Map m = <font color=#0000ff>new</font> HashMap();
    Collections2.fill(m, Collections2.rsp, 25);
    System.out.println(m + <font color=#004488>"\n"</font>);
    Map m2 = <font color=#0000ff>new</font> HashMap();
    Collections2.fill(m2, 
      Collections2.geography, 25);
    System.out.println(m2);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">С этими инструментами вы легко можете проверить различные 
  контейнеры, заполнив их интересующими вас данными.</FONT><A NAME="_Toc481064679"></A></P>
<A NAME="Heading292"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Неудобство контейнеров: неизвестный тип</H2>
</FONT>
<DIV ALIGN="LEFT"> 
  <P><FONT FACE="Georgia">&#8220;Неудобство&#8221; при использовании контейнеров 
    Java в том, что вы теряете информацию о типе, когда помещаете объект в контейнер. 
    Это случается потому, что программист такого контейнерного класса не имел 
    идей о том, как указать тип того, что вы хотите поместить в контейнер, а создание 
    контейнеров для хранения только вашего типа не допустит создания инструментов 
    общего назначения. Так что вместо этого контейнер содержит ссылки на <b>Object</b>, 
    который является корнем всех классов, так что он содержит любой тип. (Конечно, 
    сюда не включаются примитивные типы, так как они не наследуются ни от чего.) 
    Это лучшее решение, за исключением:</FONT><FONT FACE="Georgia"><A NAME="Index916"></A></FONT></P>
  </DIV>
<OL>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Так как информация о типе 
    отбрасывается, когда вы помещаете ссылку на объект в контейнер, нет ограничений 
    на тип объекта, который может быть помещен в контейнер, даже если вы предназначаете 
    его только для хранения, скажем, котов. Кто-либо может так же легко поместить 
    в контейнер собаку.</FONT>
  <LI>Так как информация о типе теряется, есть только одна вещь, которую контейнер 
    знает, он хранит ссылки на объекты. Вы должны выполнить приведение к правильному 
    типу перед использованием объекта. 
</OL>
<P><FONT FACE="Georgia">С другой стороны, Java не позволит вам <i>неправильно</i> 
  использовать объект, который вы поместили в контейнер. Если вы поместили собаку 
  в контейнер кошек, а затем пробуете трактовать все что есть в контейнере как 
  кошек, вы получите исключение во время выполнения, когда вытянете ссылку на 
  собаку из контейнера кошек и попробуете ее привести к кошке.</FONT></P>
<P>Вот пример использование основной рабочей лошадки контейнеров -<font face="Georgia"><b>ArrayList</b>. 
  Для начала вы можете думать об <b>ArrayList</b>, как о &#8220;массиве, который 
  автоматически растягивает себя&#8221;. Использование <b>ArrayList</b> достаточно 
  простое: создание, помещение в него объектов с помощью <a name="Index917"></a><a name="Index918"></a><b>add(&#160;),</b> 
  и, позже, получение их с помощью <a name="Index919"></a><a name="Index920"></a><b>get(&#160;) 
  </b>и индекса, так же как будто вы имеете дело с массивом, но без квадратных 
  скобок <a href="#fn49">[49]</a>. <b>ArrayList</b> также имеет метод <a name="Index921"></a><a name="Index922"></a><b>size(&#160;)</b>, 
  который позволяет вам узнать сколько элементов было добавлено, так что вы по 
  невнимательности не выйдете за пределы и не получите исключение.</font></P>
<P><FONT FACE="Georgia">Сначала создаются классы <B>Cat</B> и <B>Dog</B>:</FONT></P>
<DIV ALIGN="LEFT"></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:Cat.java</font>
<font color=#0000ff>public</font> <font color=#0000ff>class</font> Cat {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> catNumber;
  Cat(<font color=#0000ff>int</font> i) { catNumber = i; }
  <font color=#0000ff>void</font> print() {
    System.out.println(<font color=#004488>"Cat #"</font> + catNumber);
  }
} <font color=#009900>///:~</font>

<font color=#009900>//: c09:Dog.java</font>
<font color=#0000ff>public</font> <font color=#0000ff>class</font> Dog {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> dogNumber;
  Dog(<font color=#0000ff>int</font> i) { dogNumber = i; }
  <font color=#0000ff>void</font> print() {
    System.out.println(<font color=#004488>"Dog #"</font> + dogNumber);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Кошки (<B>Cat</B>) и собаки (<B>Dog</B>) помещаются в 
  контейнер, а затем вытягиваются оттуда:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:CatsAndDogs.java</font>
<font color=#009900>// Пример простого контейнера.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> CatsAndDogs {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    ArrayList cats = <font color=#0000ff>new</font> ArrayList();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 7; i++)
      cats.add(<font color=#0000ff>new</font> Cat(i));
    <font color=#009900>// Не проблема добавить к кошкам собаку:</font>
    cats.add(<font color=#0000ff>new</font> Dog(7));
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; cats.size(); i++)
      ((Cat)cats.get(i)).print();
    <font color=#009900>// Собака обнаружится только во время выполнения</font>
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Классы <B>Cat</B> и <B>Dog</B> отличаются &#8212; они 
  не имеют ничего общего, за исключением того, что они оба - <b>Object</b>. (Если 
  вы не можете точно сказать от чего унаследован класс, вы автоматически наследуете 
  от <b>Object</b>.) Так как <b>ArrayList</b> содержит <b>Object</b>, вы можете 
  поместить в контейнер не только объекты <b>Cat</b> с помощью метода <b>add(&#160;)</b> 
  контейнера <b>ArrayList</b>, но вы также можете добавить объекты <b>Dog</b> 
  и при этом не получите ошибок времени компиляции, либо времени выполнения. Когда 
  вы достаете то, о чем выдумаете как об объекте <b>Cat</b> с помощью метода <b>get(&#160;)</b> 
  контейнера <b>ArrayList</b>, вы получаете назад ссылку на объект, который вы 
  должны привести к <b>Cat</b>. Затем вам необходимо взять в круглые скобки все 
  выражение, чтобы навязать вычисление приведения до вызова метода <b>print(&#160;)</b> 
  для <b>Cat</b>, в противном случае вы получите синтаксическую ошибку. Затем, 
  во время выполнения, когда вы попробуете привести объект <b>Dog</b> к типу <b>Cat</b>, 
  вы получите исключение.</FONT></P>
<P><FONT FACE="Georgia">Это больше, чем просто неприятность. Это то, что может 
  создать трудные в обнаружении ошибки. Если одна часть (или несколько частей) 
  программы вставляют объекты в контейнер, и вы обнаруживаете только в отдельной 
  части программы исключение, говорящее о том, что в контейнер был помещен неправильный 
  объект, то вы должны найти, где производится неправильное вставление. С другой 
  стороны, программирование удобно начать с каких-то стандартных контейнерных 
  классов, несмотря на недостатки и неуклюжесть.</FONT><A NAME="_Toc481064680"></A></P>
<DIV ALIGN="LEFT"></DIV>
<A NAME="Heading293"></A><FONT FACE = "Verdana"> 
<H3 ALIGN="LEFT"> Иногда это работает так или иначе</H3>
</FONT> 
<P><FONT FACE="Georgia">Оказывается, что в некоторых случаях кажется, что все 
  работает правильно без обратного приведения к типу. Один случай достаточно особенный: 
  класс <b>String</b> получает дополнительную помощь от компилятора, что делает 
  работу более гладкой. Даже когда компилятор ожидает объект <b>String</b>, но 
  не получает его, он автоматически вызывает метод <a name="Index923"></a><a name="Index924"></a><b>toString(&#160;)</b>, 
  который определен для <b>Object</b>, и может быть перегружен любым классом Java. 
  Этот метод производит желаемый объект <b>String</b>, который затем используется 
  везде, где он ожидается.</FONT></P>
<P><FONT FACE="Georgia">Таким образом, все что вам нужно сделать - создать печать 
  для класса, перегрузив метод <b>toString(&#160;)</b>, как показано в следующем 
  примере:</FONT></P>
<DIV ALIGN="LEFT"></DIV>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:Mouse.java</font>
<font color=#009900>// Перегрузка toString().</font>
<font color=#0000ff>public</font> <font color=#0000ff>class</font> Mouse {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> mouseNumber;
  Mouse(<font color=#0000ff>int</font> i) { mouseNumber = i; }
  <font color=#009900>// Перегружаем Object.toString():</font>
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> <font color=#004488>"This is Mouse #"</font> + mouseNumber;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> getNumber() {
    <font color=#0000ff>return</font> mouseNumber;
  }
} <font color=#009900>///:~</font>

<font color=#009900>//: c09:WorksAnyway.java</font>
<font color=#009900>// В особых случаях кажется,</font>
<font color=#009900>// что вещи работают правильно.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> MouseTrap {
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> caughtYa(Object m) {
    Mouse mouse = (Mouse)m; <font color=#009900>// Приведение от Object</font>
    System.out.println(<font color=#004488>"Mouse: "</font> + 
      mouse.getNumber());
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> WorksAnyway {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    ArrayList mice = <font color=#0000ff>new</font> ArrayList();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 3; i++)
      mice.add(<font color=#0000ff>new</font> Mouse(i));
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; mice.size(); i++) {
      <font color=#009900>// Приведение не нужно, автоматически</font>
      <font color=#009900>// вызовется Object.toString():</font>
      System.out.println(
        <font color=#004488>"Free mouse: "</font> + mice.get(i));
      MouseTrap.caughtYa(mice.get(i));
    }
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Вы можете видеть <B>toString(&#160;)</B> перегруженную 
  в <B>Mouse</B>. Во втором цикле <B>for</B> в <B>main(&#160;)</B> вы видите инструкцию:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>System.out.println(<font color=#004488>"Free mouse: "</font> + mice.get(i));</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">После знака &#8216;<b>+</b>&#8217; компилятор ожидает 
  увидеть объект <a name="Index925"></a><a name="Index926"></a><b>String</b>. 
  <b>get(&#160;)</b> производит <b>Object</b>, поэтому, для получения желаемого 
  <b>String</b> компилятор обязательно вызовет <b>toString(&#160;)</b>. К сожалению, 
  вы можете работать с таким видом магии только для <b>String</b>; это не поддерживается 
  для любого другого типа.</FONT></P>
<P>Второй подход для упрятывания приведения помещен внутри <FONT FACE="Georgia"><b>MouseTrap</b>. 
  Метод <b>caughtYa(&#160;)</b> получает не <b>Mouse</b>, а <b>Object</b>, который 
  затем приводится к <b>Mouse</b>. Конечно, это достаточно дерзко, так как принимаемый 
  <b>Object</b> может быть чем угодно, при передаче в этот метод. Однако если 
  приведение некорректно &#8212; если вы передали неправильный тип &#8212; вы 
  получите исключение времени выполнения. Это не так хорошо, как проверка времени 
  компиляции, но это все еще устойчиво. Обратите внимание, что при использовании 
  этого метода</FONT><FONT FACE="Georgia">:</FONT></P>
<DIV ALIGN="LEFT"></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>MouseTrap.caughtYa(mice.get(i));</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT">
  <P><FONT FACE="Georgia">приведение не нужно</FONT><A NAME="_Toc481064681"></A></P>
</DIV>
<A NAME="Heading294"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Создание сознающего тип ArrayList<A NAME="Index927"></A><A NAME="Index928"></A></H3>
</FONT> 
<P><FONT FACE="Georgia">Вы можете быть не удовлетворены этими путями решения. 
  Более надежное решение заключается в создании новых классов на основе <b>ArrayList</b>, 
  которые будут принимать только ваш тип и производить только ваш тип:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:MouseList.java</font>
<font color=#009900>// Сознающий тип ArrayList.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> MouseList {
  <font color=#0000ff>private</font> ArrayList list = <font color=#0000ff>new</font> ArrayList();
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> add(Mouse m) {
    list.add(m);
  }
  <font color=#0000ff>public</font> Mouse get(<font color=#0000ff>int</font> index) {
    <font color=#0000ff>return</font> (Mouse)list.get(index);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> size() { <font color=#0000ff>return</font> list.size(); }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Вот тест для нового контейнера:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:MouseListTest.java</font>
<font color=#0000ff>public</font> <font color=#0000ff>class</font> MouseListTest {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    MouseList mice = <font color=#0000ff>new</font> MouseList();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 3; i++)
      mice.add(<font color=#0000ff>new</font> Mouse(i));
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; mice.size(); i++)
      MouseTrap.caughtYa(mice.get(i));
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Это похоже на предыдущий пример, за исключением того, 
  что новый класс <b>MouseList</b> имеет <b>private</b> член, типа <b>ArrayList</b>, 
  и методы, такие же, как и у <b>ArrayList</b>. Однако он не принимает и не производит 
  общий <b>Object</b>, а только объекты <b>Mouse</b>.</FONT></P>
<P><FONT FACE="Georgia">Обратите внимание, что если бы <b>MouseList</b> вместо 
  этого был <i>наследован</i> от <b>ArrayList</b>, метод <b>add(Mouse)</b> просто 
  бы перегружал существующий метод <b>add(Object)</b> и все равно не было бы ограничения 
  на тип объекта, который может быть добавлен. Таким образом, <b>MouseList</b> 
  становился бы суррогатом <b>ArrayList</b>, выполняя некоторые действия перед 
  передачей ответственности (смотрите <i>Thinking in Patterns with Java</i>, доступную 
  на <i>www.BruceEckel.com</i>).</FONT></P>
<P><FONT FACE="Georgia">Так как <B>MouseList</B> будет принимать только <B>Mouse</B>, 
  то если вы скажете:</FONT></P>
<DIV ALIGN="LEFT"></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>mice.add(<font color=#0000ff>new</font> Pigeon());</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">вы получите сообщение об ошибки во время компиляции. Этот 
  подход, более утомительный с точки зрения кодирования, сразу сообщит вам, если 
  вы неправильно используете тип.</FONT></P>
<P><FONT FACE="Georgia">Обратите внимание, что нет необходимости в приведении 
  при использовании <B>get(&#160;)</B> &#8212; здесь всегда <B>Mouse</B>.</FONT></P>
<DIV ALIGN="LEFT"></DIV>
<A NAME="Heading295"></A><FONT FACE = "Verdana">
<H4 ALIGN="LEFT"> Параметризированные типы</H4>
</FONT>
<DIV ALIGN="LEFT"> 
  <P><FONT FACE="Georgia">Этот вид проблемы не обособлен &#8212; существуют многочисленные 
    случаи, когда вам необходимо создавать новые типы, основываясь на других типах, 
    и в которых полезно иметь определенную информацию во время компиляции. Это 
    концепция <a name="Index929"></a><a name="Index930"></a><i>параметризированного 
    типа</i>. В С++ это напрямую поддерживается языком с помощью <a name="Index931"></a><a name="Index932"></a><i>шаблонов</i>. 
    Было бы хорошо, чтобы в будущих версиях Java поддерживала некоторые варианты 
    параметризированных типов; текущий лидер автоматически создает классы, аналогичные 
    <b>MouseList</b>.</FONT><a name="_Toc375545352"></a><a name="_Toc481064682"></a></P>
  </DIV>
<A NAME="Heading296"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Итераторы</H2>
</FONT> 
<P><FONT FACE="Georgia">В любом контейнерном классе вы должны иметь способ поместить 
  вещь внутри и способ достать вещь наружу. Кроме этого, первичная задача контейнера 
  &#8212; хранить вещи. В случае <a name="Index933"></a><b>ArrayList</b>: <b>add(&#160;)</b> 
  - способ, который вставляет объекты, а <b>get(&#160;)</b> - <i>один</i> из способов 
  получит вещи наружу. <b>ArrayList</b> достаточно гибок, вы можете выбрать все 
  что угодно в любое время и выбирать различные элементы одновременно, используя 
  разные индексы.</FONT><FONT FACE="Georgia"><A NAME="Index934"></A><A NAME="Index935"></A></FONT></P>
<P><FONT FACE="Georgia">Если вы хотите начать думать на более высоком уровне, 
  то есть препятствие: вам необходимо знать точный тип контейнера для правильного 
  его использования. Сначала это может не показаться плохим, но что, если вы начнете 
  использовать <b>ArrayList</b>, а позже в вашей программе вы обнаружите, что 
  в связи со способом использования контейнера более эффективным будет использование 
  <b>LinkedList</b> вместо него? Или, предположим, вы хотите написать кусок общего 
  кода, который не будет знать или заботится о типе контейнера, с которым он работает, 
  так что может ли он использовать разные типы контейнеров без переписывания кода?</FONT></P>
<P><FONT FACE="Georgia">Концепция <a name="Index936"></a><i>итераторов</i> может 
  быть использована для достижения этой абстракции. Итератор - это объект, чья 
  работа заключается в перемещении по последовательности объектов и выборе каждого 
  объекта в такой последовательности, чтобы клиентский программист не знал или 
  не заботился о подлежащей структуре этой последовательности. Кроме того, итераторы 
  это обычно то, что называется &#8220;легковесными&#8221; объектами: объекты, 
  дешевые в создании. По этому, вы часто будите находить несколько странными на 
  вид ограничения для итераторов; например, некоторые итераторы могут перемещаться 
  только в одном направлении.</FONT></P>
<P><FONT FACE="Georgia"> Java <B>Iterator</B> - это пример итератора с такого 
  рода ограничениями. Вы многое можете делать с ним, включая<A NAME="Index937"></A>:</FONT></P>
<DIV ALIGN="LEFT"></DIV>
<OL>
  <LI><font face="Georgia">Просить контейнер передать вам <b>Iterator</b></font>, 
    используя метод, называемый <font face="Georgia"> <b>iterator(&#160;)</b>.<b> 
    </b>Этот <b>Iterator </b>будет готов к возврату первого элемента последовательности 
    при первом вызове метода <b>next(&#160;)</b>.</font>
  <LI><FONT FACE="Georgia">Получать следующий объект в последовательности с помощью 
    <B>next(&#160;)</B>.</FONT>
  <LI><FONT FACE="Georgia">Проверять <i>есть</i> ли еще объекты в последовательности 
    с помощью <B>hasNext(&#160;)</B>.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Удалять последний элемент, 
    возвращенный итератором, с помощью <B>remove(&#160;)</B>.</FONT>
</OL>
<P><FONT FACE="Georgia">Это все. Это простая реализация итератора, но достаточно 
  мощная (и существуют более изощренный <b>ListIterator</b> для <b>List</b>). 
  Чтобы посмотреть, как это работает, позвольте вновь использовать программу <b>CatsAndDogs.java</b>, 
  введенную ранее в этой главе. В оригинальной версии метод <b>get(&#160;)</b> 
  был использован для выбора каждого элемента, но в следующей измененной версии 
  используется итератор:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:CatsAndDogs2.java</font>
<font color=#009900>// Простой контейнер с итератором.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> CatsAndDogs2 {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    ArrayList cats = <font color=#0000ff>new</font> ArrayList();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 7; i++)
      cats.add(<font color=#0000ff>new</font> Cat(i));
    Iterator e = cats.iterator();
    <font color=#0000ff>while</font>(e.hasNext())
      ((Cat)e.next()).print();
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Вы можете видеть, что последние несколько строк используют 
  <b>Iterator</b>, чтобы пройти по последовательности вместо цикла <b>for</b>. 
  С помощью итератора вам нет необходимости заботится о числе элементов в контейнере. 
  Об этом беспокоится за вас <b>hasNext(&#160;)</b> и <a name="Index940"></a><a name="Index941"></a><b>next(&#160;)</b>.</FONT></P>
<P><FONT FACE="Georgia">В качестве другого примера, рассмотрим создание метода 
  печати общего назначения:</FONT></P>
<DIV ALIGN="LEFT"></DIV>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:HamsterMaze.java</font>
<font color=#009900>// Использование итератора.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> Hamster {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> hamsterNumber;
  Hamster(<font color=#0000ff>int</font> i) { hamsterNumber = i; }
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> <font color=#004488>"This is Hamster #"</font> + hamsterNumber;
  }
}

<font color=#0000ff>class</font> Printer {
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> printAll(Iterator e) {
    <font color=#0000ff>while</font>(e.hasNext())
      System.out.println(e.next());
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> HamsterMaze {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    ArrayList v = <font color=#0000ff>new</font> ArrayList();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 3; i++)
      v.add(<font color=#0000ff>new</font> Hamster(i));
    Printer.printAll(v.iterator());
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Пристальнее всмотритесь в метод <b>printAll(&#160;)</b>. 
  Обратите внимание, что здесь нет информации о типе последовательности. Все что 
  у вас есть - это <b>Iterator</b>, и это все, что вам нужно знать о последовательности: 
  так как вы можете получить следующий объект и так как вы знаете, когда вы подойдете 
  к концу. Эта идея, получение контейнера объектов и прохождение по нему для выполнения 
  операции для каждого элемента - достаточно мощная и будет просматриваться повсюду 
  в этой книге.</FONT></P>
<P><A NAME="Index942"></A><A NAME="Index943"></A><A NAME="Index944"></A><FONT FACE="Georgia">Пример 
  является более общим, так как он косвенным образом использует метод <b>Object.toString(&#160;)</b>. 
  Метод <b>println(&#160;)</b> перегружается для всех примитивных типов так же, 
  как и для <b>Object</b>; в каждом случае автоматически производится <b>String</b> 
  путем вызова соответствующего метода <b>toString(&#160;)</b>.</FONT></P>
<P><FONT FACE="Georgia">Хотя в этом нет необходимости, но вы можете быть более 
  точны при использовании приведения, которое имеет тот же эффект, что и вызов 
  <B>toString(&#160;)</B>:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>System.out.println((String)e.next());</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Однако в общем случае вы захотите сделать что-то большее, 
  нежели вызов методов <b>Object</b>, так что вы вновь будете применять приведение 
  типов. Вы должны принимать во внимание, что вам интереснее получить <b>Iterator</b> 
  для последовательности определенного типа и приводить результирующие объекты 
  к этому типу (если вы ошиблись, получите исключение времени выполнения).</FONT></P>
<A NAME="Heading297"></A><FONT FACE = "Verdana">
<H4 ALIGN="LEFT"> Неумышленная рекурсия</H4>
</FONT> 
<P><FONT FACE="Georgia">Так как (как и со всеми классами) <a name="Index945"></a>стандартные 
  контейнеры Java наследованы от <b>Object</b>, они содержат метод <b>toString(&#160;)</b>. 
  Он был перегружен, так как он может производить <b>String</b> представление 
  самого себя, включая хранимые им объекты. Внутри <b>ArrayList</b>, например, 
  <b>toString(&#160;)</b> проходит по элементам <b>ArrayList</b> и вызывает <b>toString(&#160;)</b> 
  для каждого. Предположим, вы хотите напечатать адреса ваших классов. Кажется, 
  что имеет смысл просто обратится к <b>this</b> (обычно С++ программисты склонны 
  к этому подходу):</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:InfiniteRecursion.java</font>
<font color=#009900>// Неумышленная рекурсия.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> InfiniteRecursion {
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> <font color=#004488>" InfiniteRecursion address: "</font> 
      + <font color=#0000ff>this</font> + <font color=#004488>"\n"</font>;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    ArrayList v = <font color=#0000ff>new</font> ArrayList();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
      v.add(<font color=#0000ff>new</font> InfiniteRecursion());
    System.out.println(v);
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Если вы просто создадите объект <b>InfiniteRecursion</b>, 
  а затем напечатаете его, вы получите бесконечную последовательность исключений. 
  Это также верно, если вы поместите объект <b>InfiniteRecursion</b> в <b>ArrayList</b> 
  и напечатаете этот <b>ArrayList</b>, как показано здесь. Что случилось - это 
  автоматическое преобразование к <b>String</b>. Когда вы говорите:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#004488>"InfiniteRecursion address: "</font> + <font color=#0000ff>this</font></PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Компилятор смотрит на <b>String</b>, следующий за &#8216;<b>+</b>&#8217;, 
  а тут что-то не типа <b>String</b>, так что он пробует перевести <b>this</b> 
  в <b>String</b>. Он выполняет это преобразование с помощью вызова <b>toString(&#160;)</b>, 
  которое производит <a name="Index946"></a>рекурсивный вызов.</FONT></P>
<P><FONT FACE="Georgia">Если вы действительно хотите напечатать адрес объекта 
  в этом случае, решением может стать вызов метода <b>Object</b> <b>toString(&#160;)</b>, 
  который делает это. Так что вместо того, чтобы говорить <b>this</b>, вы должны 
  сказать <b>super.toString(&#160;)</b>. (Это работает только если вы прямо наследуете 
  от <b>Object</b>, или если ни один из родительских классов не перегрузил метод 
  <b>toString(&#160;)</b>.)</FONT><A NAME="_Toc375545359"></A><A NAME="_Toc481064683"></A></P>
<DIV ALIGN="LEFT"></DIV>
<A NAME="Heading298"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Таксономия контейнера</H2>
</FONT> 
<P><FONT FACE="Georgia"><B>Collection</B> и <B>Map</B> могут быть реализованы 
  разными способами в соответствии с требованиями вашей программы. Полезно взглянуть 
  на диаграмму контейнеров Java 2:</FONT></P>
<P align="center"><FONT FACE="Georgia"><IMG SRC="TIJ225.gif"></FONT><BR>
</P>
<DIV ALIGN="CENTER">
<p></P></DIV>
<P><FONT FACE="Georgia">Сперва эта диаграмма может немного ошеломить, но вы увидите, 
  что на самом деле есть только три контейнерных компоненты: <b>Map</b>, <b>List</b> 
  и <b>Set</b>, и только две из трех реализаций для каждого контейнера (обычно, 
  есть предпочтительная версия). Когда вы увидите это, контейнеры больше не будут 
  такими устрашающими.</FONT></P>
<P><FONT FACE="Georgia">Прямоугольники с точечной границей представляют <b>интерфейсы</b>, 
  прямоугольники с пунктирной границей представляют <b>абстрактные</b> классы, 
  а прямоугольники со сплошной границей - это обычные (конкретные) классы. Точечные 
  линии показывают, что определенные классы реализуют <b>интерфейс</b> (или в 
  случае <b>абстрактного</b> класса, частично реализуют <b>интерфейс</b>). Сплошная 
  линия показывает, что класс может производить объект того класса, на который 
  указывает стрелка. Например, любой <b>Collection</b> может производить <b>Iterator</b>, 
  а <b>List</b> может производить <b>ListIterator</b> (а также обычный <b>Iterator</b>, 
  так как <b>List</b> наследуется от <b>Collection</b>).</FONT></P>
<P><FONT FACE="Georgia">К интерфейсам, которые заботятся о хранении объектов, 
  относятся <b>Collection</b>, <b>List</b>, <b>Set</b> и <b>Map</b>. В идеальном 
  случае, большая часть кода, которую вы будете писать, это общение с этими интерфейсами, 
  и только в точке создания вы будете использовать определенный тип. Вы можете 
  создать <b>List</b> следующим образом:</FONT></P>
<DIV ALIGN="LEFT"></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>List x = <font color=#0000ff>new</font> LinkedList();</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Конечно, вы можете решить сделать <b>x </b>типа <b>LinkedList</b> 
  (вместо общего <b>List</b>) и вести точную информацию о типе <b>x</b>. Красота 
  использования интерфейса в том, что если вы решили, вы сможете поменять реализацию, 
  все что вам нужно сделать - это внести изменения в точке создания, как тут:</FONT> 
</P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>List x = <font color=#0000ff>new</font> ArrayList();</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Остальной ваш код может остаться нетронутым (часть этой 
  универсальности также можно получить с помощью итераторов).</FONT></P>
<P><FONT FACE="Georgia">В иерархии классов вы можете видеть несколько классов, 
  чьи имена начинаются со слова &#8220;<b>Abstract</b>&#8221;, и это может немного 
  смущать сначала. Они являются простыми инструментами, которые частично реализуют 
  определенные интерфейсы. Если вы создадите свой <b>Set</b>, например, вы должны 
  будете начать с интерфейса <b>Set</b> и реализовать все его методы. Вместо этого 
  вы наследуете от <a name="Index947"></a><b>AbstractSet</b> и выполняете минимально 
  необходимую работу для создания нового класса. Однако библиотека контейнеров 
  содержит достаточно функциональности для удовлетворения ваших требований, фактически, 
  в любое время. Так что, для наших целей, мы можем игнорировать любой класс, 
  который начинается с &#8220;<b>Abstract</b>&#8221;.</FONT></P>
<P><FONT FACE="Georgia">Поэтому, когда вы взглянете на диаграмму, вы реально заинтересуетесь 
  только теми интерфейсами, расположенными вверху диаграммы, и конкретными классами 
  (у которых прямоугольники со сплошной линией). Вы обычно будете создавать объекты 
  конкретных классов, приводить их к базовому классу соответствующего <b>интерфейса</b>, 
  а затем использовать <b>интерфейс</b> на протяжении всего оставшегося кода. 
  Кроме того, вам нет необходимости рассматривать допустимость элементов при написании 
  нового кода. Поэтому, диаграмма может быть сильно упрощена, и будет выглядеть 
  так:</FONT></P>
<P align="center"><FONT FACE="Georgia"><IMG SRC="TIJ226.gif"></FONT> </P>
<DIV ALIGN="CENTER">
<p></P></DIV>
<P><FONT FACE="Georgia">Теперь она включает только интерфейсы и классы, которые 
  имеют регулярную основу, а также те элементы, которым уделяется внимание этой 
  главы.</FONT></P>
<P><FONT FACE="Georgia">Вот простой пример, который заполняет <b>Collection</b> 
  (представленный классом <b>ArrayList</b>) объектами <b>String</b>, а затем печатает 
  каждый элемент из <b>Collection</b>:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:SimpleCollection.java</font>
<font color=#009900>// Простой пример использования Java 2 Collections.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SimpleCollection {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#009900>// Приводим к базовому типу, поскольку мы просто хотим</font>
    <font color=#009900>// работать с особенностями Collection</font>
    Collection c = <font color=#0000ff>new</font> ArrayList();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
      c.add(Integer.toString(i));
    Iterator it = c.iterator();
    <font color=#0000ff>while</font>(it.hasNext())
      System.out.println(it.next());
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Первая строка в <b>main(&#160;)</b> создает объект <a name="Index948"></a><b>ArrayList</b>, 
  а затем приводит его к базовому типу <b>Collection</b>. Так как этот пример 
  использует только методы <b>Collection</b>, любой объект класса, наследованный 
  от <b>Collection</b>, будет работать, а <b>ArrayList</b> - это типичная рабочая 
  лошадка <b>Collection</b>.</FONT></P>
<P><FONT FACE="Georgia">Метод <B>add(&#160;)</B>, как подсказывает его имя, помещает 
  новый элемент в <b>Collection</b>. Однако документация осторожно заявляет, что 
  <b>add(&#160;)</b> &#8220;гарантирует, что этот Контейнер содержит указанный 
  элемент&#8221;. При этом имеется в виду <b>Set</b>, который добавляет элемент, 
  если его еще нет в наборе. Для <b>ArrayList</b>, или любого сорта <b>List</b>, 
  метод <b>add(&#160;)</b> всегда означает &#8220;поместить внутрь&#8221;, потому 
  что списки не заботятся о возможном дублировании.</FONT></P>
<P><FONT FACE="Georgia">Все <B>Collection</B> могут производить <a name="Index949"></a><b>Iterator</b> 
  чрез свой метод <a name="Index950"></a><b>iterator(&#160;)</b>. Здесь <b>Iterator</b> 
  создается и используется для обхода и распечатки каждого элемента <b>Collection</b>.</FONT><A NAME="_Toc481064684"></A></P>
<DIV ALIGN="LEFT"></DIV>
<A NAME="Heading299"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Функциональность Collection</H2>
</FONT> 
<P><FONT FACE="Georgia">Приведенная ниже таблица показывает все, что вы можете 
  делать с <b>Collection</b> (за исключением тех методов, которые автоматически 
  приходят от <b>Object</b>), и таким образом, все, что вы можете делать с <b>Set</b> 
  или <b>List</b>. (<b>List</b> также5 имеет дополнительную функциональность.) 
  <b>Map</b> не наследуются от <b>Collection</b>, о нем будет рассказано отдельно.</FONT></P>
<TABLE BORDER width="100%">
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>boolean add(Object)</B></FONT></TD>
    <TD> <FONT FACE="Georgia">Гарантирует, что контейнер содержит аргумент. Возвращает 
      <b>false</b>, если не может добавить аргумент. (Это &#8220;необязательный&#8221; 
      метод описывается позже в этой главе.)</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>boolean </B></FONT><BR>
      <FONT FACE="Georgia"><B>addAll(Collection)</B></FONT></TD>
    <TD> <FONT FACE="Georgia">Добавляет все элементы аргумента. Возвращает <B>true</B>, 
      если любые элементы были добавлены. (&#8220;Необязательно&#8221;)</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>void clear(&#160;)</B></FONT></TD>
    <TD> <FONT FACE="Georgia">Удаляет все элементы контейнера. (&#8220;Необязательно&#8221;)</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>boolean </B></FONT><BR>
      <FONT FACE="Georgia"><B>contains(Object)</B></FONT></TD>
    <TD> <FONT FACE="Georgia"><B>true</B>, если контейнер содержит аргумент.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>boolean containsAll(Collection)</B></FONT></TD>
    <TD> <FONT FACE="Georgia"><B>true</B>, если контейнер содержит все элементы 
      аргумента.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>boolean isEmpty(&#160;)</B></FONT></TD>
    <TD> <FONT FACE="Georgia"><B>true</B>, если контейнер не имеет элементов.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>Iterator iterator(&#160;)</B></FONT></TD>
    <TD> <FONT FACE="Georgia">Возвращает <B>Iterator</B>, который вы можете использовать 
      для обхода элементов контейнера.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>boolean </B></FONT><BR>
      <FONT FACE="Georgia"><B>remove(Object)</B></FONT></TD>
    <TD> <FONT FACE="Georgia">Если аргумент присутствует в контейнере, один экземпляр 
      этого элемента будет удален. Возвращает <B>true</B>, если произошло удаление.</FONT> 
      <font face="Georgia">(&#8220;Необязательно&#8221;)</font></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>boolean removeAll(Collection)</B></FONT></TD>
    <TD> <FONT FACE="Georgia">Удаляет все элементы, содержащиеся в аргументе. 
      Возвращает <B>true</B>, если произошло любое удаление. </FONT><font face="Georgia">(&#8220;Необязательно&#8221;)</font></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>boolean retainAll(Collection)</B></FONT></TD>
    <TD> <FONT FACE="Georgia">Остаются только те элементы, которые содержатся 
      в аргументе (в теории множеств называется &#8220;пересечением&#8221;). Возвращает 
      <B>true</B>, если произошли любые изменения. (&#8220;Необязательно&#8221;)</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>int size(&#160;)</B></FONT></TD>
    <TD> Возвращает число элементов контейнера<FONT FACE="Georgia">.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>Object[] toArray(&#160;)</B></FONT></TD>
    <TD> <FONT FACE="Georgia">Возвращает массив, содержащий все элементы контейнера.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>Object[] </B></FONT><BR>
      <FONT FACE="Georgia"><B>toArray(Object[] a)</B></FONT></TD>
    <TD> <FONT FACE="Georgia">Возвращает массив, содержащий все элементы контейнера, 
      чей тип, скорее массив, а не простой <B>Object</B> (вы должны привести массив 
      к правильному типу).</FONT></TD>
  </TR>
</TABLE>
<p></P>
<P><FONT FACE="Georgia">Обратите внимание, что здесь нет функции <b>get(&#160;)</b> 
  для выбора элементов в случайном порядке. Это происходит потому, что <b>Collection</b> 
  также включает <b>Set</b>, который содержит свой внутренний механизм упорядочивания 
  (и это делает выборку в случайном порядке бессмысленной). Таким образом, если 
  вы хотите проверить все элементы <b>Collection</b>, вы должны использовать итератор; 
  это единственный способ получить вещи назад.</FONT></P>
<P><FONT FACE="Georgia">Приведенный ниже пример демонстрирует все эти методы. 
  Кроме того, он работает со всем, что наследовано от <b>Collection</b>, и <b>ArrayList</b> 
  используется в качестве &#8220;наиболее общего заменителя&#8221;:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:Collection1.java</font>
<font color=#009900>// То, что вы можете делать с  Collections.</font>
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Collection1 {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Collection c = <font color=#0000ff>new</font> ArrayList();
    Collections2.fill(c, 
      Collections2.countries, 10);    
    c.add(<font color=#004488>"ten"</font>);
    c.add(<font color=#004488>"eleven"</font>);
    System.out.println(c);
    <font color=#009900>// Создание массива из List:</font>
    Object[] array = c.toArray(); 
    <font color=#009900>// Создание массива String из List:</font>
    String[] str = 
      (String[])c.toArray(<font color=#0000ff>new</font> String[1]);
    <font color=#009900>// Нахождение максимального и минимального элементов; это</font>
    <font color=#009900>// имеет разный смысл в зависимости от способа</font>
    <font color=#009900>// реализации интерфейса Comparable:</font>
    System.out.println(<font color=#004488>"Collections.max(c) = "</font> +
      Collections.max(c));
    System.out.println(<font color=#004488>"Collections.min(c) = "</font> +
      Collections.min(c));
    <font color=#009900>// Добавление одного Collection в другой Collection</font>
    Collection c2 = <font color=#0000ff>new</font> ArrayList();
    Collections2.fill(c2, 
      Collections2.countries, 10);    
    c.addAll(c2);
    System.out.println(c);
    c.remove(CountryCapitals.pairs[0][0]);
    System.out.println(c);
    c.remove(CountryCapitals.pairs[1][0]);
    System.out.println(c);
    <font color=#009900>// Удаление всех компонентов, присутствующих в</font>
    <font color=#009900>// аргументе:</font>
    c.removeAll(c2);
    System.out.println(c);
    c.addAll(c2);
    System.out.println(c);
    <font color=#009900>// Есть ли элемент в этом  Collection?</font>
    String val = CountryCapitals.pairs[3][0];
    System.out.println(
      <font color=#004488>"c.contains("</font> + val  + <font color=#004488>") = "</font> 
      + c.contains(val));
    <font color=#009900>// Есть ли Collection в этом Collection?</font>
    System.out.println(
      <font color=#004488>"c.containsAll(c2) = "</font>+ c.containsAll(c2));
    Collection c3 = ((List)c).subList(3, 5);
    <font color=#009900>// Сохранить элементы, которые есть в обоих</font>
    <font color=#009900>// c2 и c3 (пересечение множеств):</font>
    c2.retainAll(c3);
    System.out.println(c);
    <font color=#009900>// Отбросить все элементы</font>
    <font color=#009900>// из c2, которые есть в c3:</font>
    c2.removeAll(c3);
    System.out.println(<font color=#004488>"c.isEmpty() = "</font> +
      c.isEmpty());
    c = <font color=#0000ff>new</font> ArrayList();
    Collections2.fill(c, 
      Collections2.countries, 10);    
    System.out.println(c);
    c.clear(); <font color=#009900>// Удалить все элементы</font>
    System.out.println(<font color=#004488>"after c.clear():"</font>);
    System.out.println(c);
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia"><B>ArrayList</B> создаются с различными наборами данных 
  и приводятся к базовому типу объекта <b>Collection</b>, так что достаточно ясно, 
  что ничего, кроме интерфейса <b>Collection</b> не будет использоваться. <b>main(&#160;)</b> 
  использует простые упражнения, чтобы показать все методы <b>Collection</b>.</FONT></P>
<P><FONT FACE="Georgia">Следующий </FONT><FONT FACE="Georgia">раздел описывает 
  различные реализации: <b>List</b>, <b>Set</b> и <b>Map</b> и для каждого случая 
  указывает (отмечено звездочкой) что вы должны выбирать по умолчанию. Вы заметите, 
  что допустимые классы <b>Vector</b>, <b>Stack</b> и <b>Hashtable</b> не включены, 
  потому что во всех случаях предпочтительней использовать контейнерные классы 
  Java 2.</FONT><A NAME="_Toc481064685"></A></P>
<DIV ALIGN="LEFT"></DIV>
<A NAME="Heading300"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Функциональность List<A NAME="Index951"></A><A NAME="Index952"></A><A NAME="Index953"></A><A NAME="Index954"></A></H2>
</FONT> 
<P><FONT FACE="Georgia">Основной <b>List</b> достаточно прост для использования, 
  по сравнению с <b>ArrayList</b>. Хотя большую часть времени вы будите просто 
  использовать <b>add(&#160;)</b> для вставление объектов, <b>get(&#160;)</b> 
  для получения их обратно в любое время и <b>iterator(&#160;)</b> для получения 
  <b>Iterator</b> последовательности, есть также набор других методов, которые 
  также полезны.</FONT></P>
<P>Кроме того, на самом деле есть два типа <font face="Georgia"><b>List</b>: основной 
  <b>ArrayList</b>, выделяется доступом к элементам в случайном порядке, и более 
  мощный <b>LinkedList</b> (который не предназначен для быстрого доступа в случайном 
  порядке, но имеет более общий набор методов).</font></P>
<TABLE BORDER width="100%">
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>List</B> (интерфейс)</FONT></TD>
    <TD> 
      <p><FONT FACE="Georgia">Порядок - наиболее важная особенность для <B>List</B>; 
        он обещает, что элементы будут храниться в определенной последовательности.</FONT><FONT FACE="Georgia"> 
        <B>List</B> добавляет несколько методов к набору <B>Collection</B>, которые 
        позволяют вставку и удаление элементов в середине списка <B>List</B>. 
        (Это рекомендуется только для <B>LinkedList</B>.) <B>List</B> производит 
        <B>ListIterator</B>, и, используя его, вы можете пройти весь <B>List</B> 
        в обоих направлениях, а также вставлять и извлекать элементы из середины 
        списка <B>List</B>.</FONT></p>
      </TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>ArrayList</B>*</FONT></TD>
    <TD> <FONT FACE="Georgia"> <B>List</B> реализуется массивом. Позволяет быстрый 
      доступ в случайном порядке к элементами, но медленный, когда вставляются 
      и удаляются элементы из середины списка. <B>ListIterator</B> должен использоваться 
      только для прямого и обратного движения по <B>ArrayList</B>, но не для вставления 
      и удаления элементов, что является очень дорогим, по сравнению с <B>LinkedList</B>.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>LinkedList</B></FONT></TD>
    <TD> <FONT FACE="Georgia">Обеспечивает оптимальный доступ к последовательности, 
      который недорогой при вставках и удаленьях из середины списка <B>List</B>. 
      Относительно медленный при случайном выборе элементов. (Используйте для 
      этого <B>ArrayList</B>.) Также имеются методы <B>addFirst(&#160;)</B>, <B>addLast(&#160;)</B>, 
      <B>getFirst(&#160;)</B>, <B>getLast(&#160;)</B>, <B>removeFirst(&#160;)</B> 
      и <B>removeLast(&#160;)</B> (которые не определены во всех интерфейсах или 
      базовых классах), позволяющие использовать связанный список как стек, очередь 
      и двойную очередь.</FONT></TD>
  </TR>
</TABLE>
<p></P>
<P><FONT FACE="Georgia">Методы из следующего примера охватывают различную группу 
  действий: то, что могут сделать все списки (<B>basicTest(&#160;)</B>), перемещение 
  с помощью <B>Iterator</B> (<B>iterMotion(&#160;)</B>)<B> </B> против изменения 
  с помощью <B>Iterator</B> (<B>iterManipulation(&#160;)</B>), просмотр результатов 
  манипуляции с <B>List</B> (<B>testVisual(&#160;)</B>), и операции, поддерживаемые 
  только для <B>LinkedList</B>.</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:List1.java</font>
<font color=#009900>// То, что вы можете сделать со списками.</font>
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> List1 {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> List fill(List a) {
    Collections2.countries.reset();
    Collections2.fill(a, 
      Collections2.countries, 10);
    <font color=#0000ff>return</font> a;
  }
  <font color=#0000ff>static</font> <font color=#0000ff>boolean</font> b;
  <font color=#0000ff>static</font> Object o;
  <font color=#0000ff>static</font> <font color=#0000ff>int</font> i;
  <font color=#0000ff>static</font> Iterator it;
  <font color=#0000ff>static</font> ListIterator lit;
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> basicTest(List a) {
    a.add(1, <font color=#004488>"x"</font>); <font color=#009900>// Вставка в позицию 1</font>
    a.add(<font color=#004488>"x"</font>); <font color=#009900>// Вставка в конец</font>
    <font color=#009900>// Добавление Сollection:</font>
    a.addAll(fill(<font color=#0000ff>new</font> ArrayList()));
    <font color=#009900>// Добавление Collection, начиная с 3 позиции:</font>
    a.addAll(3, fill(<font color=#0000ff>new</font> ArrayList())); 
    b = a.contains(<font color=#004488>"1"</font>); <font color=#009900>// Есть здесь?</font>
    <font color=#009900>// Есть ли вся Collection здесь?</font>
    b = a.containsAll(fill(<font color=#0000ff>new</font> ArrayList()));
    <font color=#009900>// Списки позволяют случайный доступ, который дешев</font>
    <font color=#009900>// для ArrayList, и дорог для LinkedList:</font>
    o = a.get(1); <font color=#009900>// Получить объект из позиции 1</font>
    i = a.indexOf(<font color=#004488>"1"</font>); <font color=#009900>// Узнать индекс объекта</font>
    b = a.isEmpty(); <font color=#009900>// Есть ли элементы внутри?</font>
    it = a.iterator(); <font color=#009900>// Обычный Iterator</font>
    lit = a.listIterator(); <font color=#009900>// ListIterator</font>
    lit = a.listIterator(3); <font color=#009900>// Начать с позиции 3</font>
    i = a.lastIndexOf(<font color=#004488>"1"</font>); <font color=#009900>// Последнее совпадение</font>
    a.remove(1); <font color=#009900>// Удалить из позиции 1</font>
    a.remove(<font color=#004488>"3"</font>); <font color=#009900>// Удалить этот объект</font>
    a.set(1, <font color=#004488>"y"</font>); <font color=#009900>// Установить позицию 1 на "y"</font>
    <font color=#009900>// Оставить все, что есть в аргументе</font>
    <font color=#009900>// (пересечение двух множеств):</font>
    a.retainAll(fill(<font color=#0000ff>new</font> ArrayList()));
    <font color=#009900>// Удаление всего, что есть в аргументе:</font>
    a.removeAll(fill(<font color=#0000ff>new</font> ArrayList()));
    i = a.size(); <font color=#009900>// Каков размер?</font>
    a.clear(); <font color=#009900>// Удаление всех элементов</font>
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> iterMotion(List a) {
    ListIterator it = a.listIterator();
    b = it.hasNext();
    b = it.hasPrevious();
    o = it.next();
    i = it.nextIndex();
    o = it.previous();
    i = it.previousIndex();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> iterManipulation(List a) {
    ListIterator it = a.listIterator();
    it.add(<font color=#004488>"47"</font>);
    <font color=#009900>// Должно произойти перемещение на элемент после добавления:</font>
    it.next();
    <font color=#009900>// Удалить элемент, который был только что выбран:</font>
    it.remove(); 
    <font color=#009900>// Должно переместится на элемент, после remove():</font>
    it.next();
    <font color=#009900>// Изменить элемент, который только что выбран:</font>
    it.set(<font color=#004488>"47"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> testVisual(List a) {
    System.out.println(a);
    List b = <font color=#0000ff>new</font> ArrayList();
    fill(b);
    System.out.print(<font color=#004488>"b = "</font>);
    System.out.println(b);
    a.addAll(b);
    a.addAll(fill(<font color=#0000ff>new</font> ArrayList()));
    System.out.println(a);
    <font color=#009900>// Вставка, удаление и замена элементов с
    // использованием</font> <font color=#009900>ListIterator:</font>
    ListIterator x = a.listIterator(a.size()/2);
    x.add(<font color=#004488>"one"</font>); 
    System.out.println(a);
    System.out.println(x.next());
    x.remove();
    System.out.println(x.next());
    x.set(<font color=#004488>"47"</font>);
    System.out.println(a);
    <font color=#009900>// Проход списка в обратном порядке:</font>
    x = a.listIterator(a.size());
    <font color=#0000ff>while</font>(x.hasPrevious())
      System.out.print(x.previous() + <font color=#004488>" "</font>);
    System.out.println();
    System.out.println(<font color=#004488>"testVisual finished"</font>);
  }
  <font color=#009900>// Есть некоторые вещи, которые</font>
  <font color=#009900>// может делать только LinkedList:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> testLinkedList() {
    LinkedList ll = <font color=#0000ff>new</font> LinkedList();
    fill(ll);
    System.out.println(ll);
    <font color=#009900>// Трактуем его, как стек, вталкиваем:</font>
    ll.addFirst(<font color=#004488>"one"</font>);
    ll.addFirst(<font color=#004488>"two"</font>);
    System.out.println(ll);
    <font color=#009900>// Аналогично "заглядыванию" в вершину стека:</font>
    System.out.println(ll.getFirst());
    <font color=#009900>// Аналогично выталкиванию из стека:</font>
    System.out.println(ll.removeFirst());
    System.out.println(ll.removeFirst());
    <font color=#009900>// Трактуем, как очередь, вталкиваем элементы</font>
    <font color=#009900>// и вытаскиваем с конца:</font>
    System.out.println(ll.removeLast());
    <font color=#009900>// С обеими приведенными выше операциями - это двойная очередь!</font>
    System.out.println(ll);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#009900>// Создаем и заполняем каждый раз новый список:</font>
    basicTest(fill(<font color=#0000ff>new</font> LinkedList()));
    basicTest(fill(<font color=#0000ff>new</font> ArrayList()));
    iterMotion(fill(<font color=#0000ff>new</font> LinkedList()));
    iterMotion(fill(<font color=#0000ff>new</font> ArrayList()));
    iterManipulation(fill(<font color=#0000ff>new</font> LinkedList()));
    iterManipulation(fill(<font color=#0000ff>new</font> ArrayList()));
    testVisual(fill(<font color=#0000ff>new</font> LinkedList()));
    testLinkedList();
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">В <B>basicTest(&#160;)</B> и <B>iterMotion(&#160;)</B> 
  вызовы сделаны для показа правильного синтаксиса, а полученное возвращаемое 
  значение нигде не используется. В некоторых случаях возвращаемое значение никуда 
  не присваивается, так как оно обычно не используется. Вы должны посмотреть полное 
  использование этих методов в онлайн документации на <i>java.sun.com</i> , прежде 
  чем начнете использовать их.</FONT><A NAME="_Toc481064686"></A></P>
<A NAME="Heading301"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Создание стека из LinkedList</H3>
</FONT> 
<P><FONT FACE="Georgia"> <A NAME="Index955"></A>Стек иногда называется контейнером, 
  типа &#8220;последний вошел, первый вышел&#8221; (<a name="Index956"></a>LIFO). 
  То есть, то, что вы &#8220;втолкнете&#8221; в стек последним, то будет первым, 
  что вы можете &#8220;вытолкнуть&#8221;. Как и все другие контейнеры Java, то, 
  что вы можете втолкнуть и вытолкнуть - это <b>Object</b>, так что вы должны 
  выполнить приведение типов для того, что вытолкните, если вы не используете 
  черты поведения, присущие классу <b>Object</b>.</FONT></P>
<P><FONT FACE="Georgia"> <B>LinkedList</B> имеет методы, которые напрямую реализуют 
  функциональность стека, так что вы можете просто использовать <b>LinkedList</b>, 
  а не создавать класс стека. Однако класс стека иногда может рассказать историю 
  лучше:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:StackL.java</font>
<font color=#009900>// Создание стека из LinkedList.</font>
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> StackL {
  <font color=#0000ff>private</font> LinkedList list = <font color=#0000ff>new</font> LinkedList();
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> push(Object v) {
    list.addFirst(v);
  }
  <font color=#0000ff>public</font> Object top() { <font color=#0000ff>return</font> list.getFirst(); }
  <font color=#0000ff>public</font> Object pop() { 
    <font color=#0000ff>return</font> list.removeFirst(); 
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    StackL stack = <font color=#0000ff>new</font> StackL();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
      stack.push(Collections2.countries.next());
    System.out.println(stack.top());
    System.out.println(stack.top());
    System.out.println(stack.pop());
    System.out.println(stack.pop());
    System.out.println(stack.pop());
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Если вам нужно только поведение стека, наследование не 
  подойдет, так как при этом получится класс со всеми методами, имеющимися в <b>LinkedList</b> 
  (позже вы увидите, что это наиболее распространенная ошибка была сделана разработчиками 
  библиотеки Java 1.0 при работе со</FONT><FONT FACE="Georgia"> <B>Stack</B>).</FONT><A NAME="_Toc481064687"></A></P>
<A NAME="Heading302"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Создание очереди из LinkedList</H3>
</FONT> 
<p><FONT FACE="Georgia"><A NAME="Index957"></A><i>Очередь</i> - это контейнер, 
  типа &#8220;<i>первый вошел, первый вышел</i>&#8221; (<A NAME="Index958"></A>FIFO). 
  То есть, вы помещаете вещь в конец, а получаете ее с другого конца. Таким образом, 
  порядок, в котором вы помещаете вещи в контейнер, остается тем же самым, в котором 
  они выходят. <a name="Index959"></a><b>LinkedList</b> имеет методы для поддержки 
  поведения очереди, так что он может быть использован для создания класса <b>Queue</b>:</FONT></p>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:Queue.java</font>
<font color=#009900>// Создание очереди из LinkedList.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Queue {
  <font color=#0000ff>private</font> LinkedList list = <font color=#0000ff>new</font> LinkedList();
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> put(Object v) { list.addFirst(v); }
  <font color=#0000ff>public</font> Object get() { 
    <font color=#0000ff>return</font> list.removeLast(); 
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> isEmpty() { 
    <font color=#0000ff>return</font> list.isEmpty(); 
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Queue queue = <font color=#0000ff>new</font> Queue();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
      queue.put(Integer.toString(i));
    <font color=#0000ff>while</font>(!queue.isEmpty())
      System.out.println(queue.get());
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<p><FONT FACE="Georgia">Вы также без труда создадите двустороннюю очередь из <b>LinkedList</b>. 
  Она такая же, как и очередь, но вы можете добавлять и удалять элементы с любого 
  конца.</FONT><A NAME="_Toc481064688"></A></p>
<A NAME="Heading303"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Функциональность Set<A NAME="Index960"></A></H2>
</FONT> 
<P><FONT FACE="Georgia"><B>Set</B> имеет точно такой же интерфейс, как и <b>Collection</b>, 
  но здесь нет дополнительной функциональности, как и в случае двух других списков. 
  Вместо этого <b>Set</b> - это точно <b>Collection</b>, он имеет отличающееся 
  поведение. (Это идеальное использование наследования и полиморфизма: для выражения 
  разницы в поведении.) <b>Set</b> отклоняет хранение нескольких экземпляров одного 
  значения объекта (что понимается под <b> </b> &#8220;значением&#8221; объекта 
  - это более сложный вопрос, как вы скоро увидите).</FONT><FONT FACE="Georgia"><A NAME="Index961"></A><A NAME="Index962"></A><A NAME="Index963"></A></FONT><BR>
</P>
<TABLE BORDER width="100%">
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>Set</B> (интерфейс)</FONT></TD>
    <TD> <FONT FACE="Georgia">Каждый элемент, который вы добавляете в <B>Set</B>, 
      должен быть уникальным; в противном случае <B>Set</B> не добавит дублирующий 
      элемент. <B>Object</B>, добавляемый в <B>Set</B>, должен определить <B>equals(&#160;)</B> 
      для установления уникальности объектов. <B>Set</B> имеет точно такой же 
      интерфейс, что и <B>Collection</B>. Интерфейс <B>Set</B> не гарантирует 
      сохранение порядка следования элементов в определенной последовательности.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>HashSet</B>*</FONT></TD>
    <TD> <FONT FACE="Georgia">Для <B>Set</B>, в которых важно время поиска. <B>Object</B> 
      должен определить <B>hashCode(&#160;)</B>.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>TreeSet</B></FONT></TD>
    <TD> <FONT FACE="Georgia">Упорядоченный <B>Set</B> поддерживаемый деревом. 
      Этим способом вы можете получить упорядоченную последовательность из <B>Set</B>.</FONT></TD>
  </TR>
</TABLE>
<p></P>
<P><FONT FACE="Georgia">Приводимый пример не показывает всего, что вы можете делать 
  с <b>Set</b>, так как его интерфейс тот же, что и у <b>Collection</b>, который 
  был использован в предыдущих примерах. Вместо этого демонстрируется поведение, 
  которое делает <b>Set</b> уникальным:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:Set1.java</font>
<font color=#009900>// То, что вы можете сделать с Set.</font>
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Set1 {
  <font color=#0000ff>static</font> Collections2.StringGenerator gen = 
    Collections2.countries;
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> testVisual(Set a) {
    Collections2.fill(a, gen.reset(), 10);    
    Collections2.fill(a, gen.reset(), 10);    
    Collections2.fill(a, gen.reset(), 10);    
    System.out.println(a); <font color=#009900>// Без дублирования!</font>
    <font color=#009900>// Добавление другого набора в этот:</font>
    a.addAll(a);
    a.add(<font color=#004488>"one"</font>); 
    a.add(<font color=#004488>"one"</font>); 
    a.add(<font color=#004488>"one"</font>);
    System.out.println(a);
    <font color=#009900>// Просмотр:</font>
    System.out.println(<font color=#004488>"a.contains(\"</font>one\<font color=#004488>"): "</font> +
      a.contains(<font color=#004488>"one"</font>));
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    System.out.println(<font color=#004488>"HashSet"</font>);
    testVisual(<font color=#0000ff>new</font> HashSet());
    System.out.println(<font color=#004488>"TreeSet"</font>);
    testVisual(<font color=#0000ff>new</font> TreeSet());
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Дублирующиеся значения добавляются в <B>Set</B>, но при 
  распечатке вы увидите, что <B>Set</B> принял только один экземпляр каждого значения.</FONT></P>
<P><FONT FACE="Georgia">Когда вы запустите программу, вы заметите, что порядок, 
  содержащийся в <b>HashSet</b>, отличается от <b>TreeSet</b>, так как каждый 
  из них имеет различные способы сортировки элементов, так чтобы они могли быть 
  найдены позднее. (<b>TreeSet</b> хранит их отсортированными, а <b>HashSet</b> 
  использует функцию хеширования, которая предназначена специально для многократного 
  поиска.) Когда создаете свои собственные типы, запомните, что для <b>Set</b> 
  необходим способ обработки порядка сортировки, что означает, что вы должны реализовать 
  интерфейс <b>Comparable </b>и определить метод <b>compareTo(&#160;)</b>. Вот 
  пример:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:Set2.java</font>
<font color=#009900>// Помещение своего типа в Set.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> MyType <font color=#0000ff>implements</font> Comparable {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> i;
  <font color=#0000ff>public</font> MyType(<font color=#0000ff>int</font> n) { i = n; }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> equals(Object o) {
    <font color=#0000ff>return</font> 
      (o <font color=#0000ff>instanceof</font> MyType) 
      &amp;&amp; (i == ((MyType)o).i);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> hashCode() { <font color=#0000ff>return</font> i; }
  <font color=#0000ff>public</font> String toString() { <font color=#0000ff>return</font> i + <font color=#004488>" "</font>; }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> compareTo(Object o) {
    <font color=#0000ff>int</font> i2 = ((MyType)o).i;
    <font color=#0000ff>return</font> (i2 &lt; i ? -1 : (i2 == i ? 0 : 1));
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Set2 {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> Set fill(Set a, <font color=#0000ff>int</font> size) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; size; i++)
      a.add(<font color=#0000ff>new</font> MyType(i));
    <font color=#0000ff>return</font> a;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> test(Set a) {
    fill(a, 10);
    fill(a, 10); <font color=#009900>// Попытка создать дублирование</font>
    fill(a, 10);
    a.addAll(fill(<font color=#0000ff>new</font> TreeSet(), 10));
    System.out.println(a);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    test(<font color=#0000ff>new</font> HashSet());
    test(<font color=#0000ff>new</font> TreeSet());
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><A NAME="Index964"></A><A NAME="Index965"></A><FONT FACE="Georgia">Форма определения 
  для <a name="Index966"></a><b>equals(&#160;)</b> и <b>hashCode(&#160;)</b> будет 
  описана позднее в этой главе. Вы должны определить <b>equals(&#160;)</b> в обоих 
  классах, а <b>hashCode(&#160;)</b> абсолютно необходима только если класс будет 
  помещен в <b>HashSet</b> (что предпочтительнее, так как он должен быть выбран 
  вами в первую очередь в качестве реализации <b>Set</b>). Однако, в качестве 
  стиля программирования, вы должны всегда перегружать <b>hashCode(&#160;)</b>, 
  когда вы перегружаете <b>equals(&#160;)</b>. Этот процесс будет позднее детализирован 
  в этой главе.</FONT></P>
<P><FONT FACE="Georgia">Обратите внимание, что в методе <B>compareTo(&#160;)</B> 
  я <i>не</i> использую &#8220;простую и очевидную&#8221; форму <b>return i-i2</b>. 
  Это общая ошибка программистов, это будет работать правильно, если <b>i</b> 
  и <b>i2</b> являются &#8220;беззнаковыми&#8221; целыми (если бы Java <i>имел</i> 
  ключевое слово &#8220;unsigned&#8221;, но это не так). Это неправильно для отрицательных 
  знаковых <b>int</b> в Java, который не достаточно велик, чтобы представить разность 
  между двумя знаковыми <b>int</b>. Если <b>i</b> - это большое положительное 
  целое, а <b>j</b> - это большое отрицательное целое, то при <b>i-j</b> будет 
  переполнение и возвратится отрицательное значение, и это не будет работать.</FONT><A NAME="_Toc481064689"></A></P>
<DIV ALIGN="LEFT"></DIV>
<A NAME="Heading304"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
SortedSet</H3>
</FONT> 
<P><FONT FACE="Georgia">Если вы имеете <b>SortedSet</b> (для которого поддерживается 
  только <b>TreeSet</b>), элементы будут гарантированно располагаться в упорядоченном 
  виде, что позволяет использовать дополнительную функциональность, обеспечиваемую 
  методами интерфейса <b>SortedSet</b>:</FONT></P>
<P><FONT FACE="Georgia"><B>Comparator comparator():</B> Производит <B>Comparator</B>, 
  используемый для этого <B>Set</B>, или <B>null</B> для естественного упорядочивания.</FONT></P>
<P><FONT FACE="Georgia"><B>Object first():</B> Производит низший элемент</FONT>.</P>
<P><FONT FACE="Georgia"><B>Object last():</B> Производит высший элемент.</FONT></P>
<P><FONT FACE="Georgia"><B>SortedSet subSet(fromElement, toElement):</B> Производит 
  вид этого <B>Set</B> с элементами от <B>fromElement</B>, включительно, по <B>toElement</B>, 
  исключительно.</FONT></P>
<P><FONT FACE="Georgia"><B>SortedSet headSet(toElement):</B> Производит вид этого 
  <B>Set</B> с элементами, меньшими <B>toElement</B>.</FONT></P>
<P><FONT FACE="Georgia"><B>SortedSet tailSet(fromElement):</B> Производит вид 
  этого <B>Set</B> с элементами большими, или равными <B>fromElement</B>.</FONT><A NAME="_Toc481064690"></A></P>
<A NAME="Heading305"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Функциональность Map<A NAME="Index967"></A><A NAME="Index968"></A><A NAME="Index969"></A></H2>
</FONT> 
<P><FONT FACE="Georgia"> <B>ArrayList</B> позволяет вам выбирать из последовательности 
  объектов, используя номер, другими словами, он ассоциирует номера с объектами. 
  Но что, если вы хотите выбирать из последовательности объектов, используя какой-то 
  другой критерий? Например, стек: его критерием выбора является &#8220;последняя 
  вещь, втолкнутая в стек&#8221;. Мощными поворотными моментами этой идеи &#8220;выборки 
  из последовательности&#8221; поочередно стали <a name="Index970"></a><i>карта 
  (map)</i>, <a name="Index971"></a><i>словарь (dictionary)</i> или <a name="Index972"></a><a name="Index973"></a><i>ассоциативный 
  массив (associative array)</i>. Концептуально они выглядят как <b>ArrayList</b>, 
  но вместо поиска объектов по номерам вы ищете их, используя <i>другой объект</i>. 
  Часто это является ключевым процессом в программе.</FONT></P>
<P><FONT FACE="Georgia">Эта концепция показана в Java как интерфейс <b>Map</b>. 
  Метод <b>put(Object key, Object value)</b> добавляет значение (то, что вы хотите) 
  и ассоциирует с ним ключ (то, по чем вы будете искать). <b>get(Object key)</b> 
  производит значение по соответствующему ключу. Вы также можете проверить <b>Map</b>, 
  узнав, содержится ли там ключ или значение с помощью <b>containsKey(&#160;)</b> 
  и <b>containsValue(&#160;)</b>. <b> </b></FONT></P>
<P><FONT FACE="Georgia">Стандартная библиотека Java содержит два различных типа 
  <b>Map</b>: <b>HashMap</b> и <b>TreeMap</b>. Оба они имеют один и тот же интерфейс 
  (так как они оба реализуют <b>Map</b>), но они отличаются одним способом: эффективностью. 
  Если вы думаете, что это должно выполнятся с помощью <b>get(&#160;)</b>, это 
  выглядит приятно медленным, например, при поиске в <b>ArrayList</b>, содержащем 
  ключи. <b>HashMap</b> - достаточно скоростной контейнер. Вместо медленного поиска 
  ключа, он использует специальное значение, называемое <a name="Index974"></a><i>хеш-код</i>. 
  Хэш-код - это способ получения определенной информации об объекте путем опроса 
  и включения &#8220;относительно уникального&#8221; <b>int</b> для этого объекта. 
  Все Java объекты могут производить хеш-код, а метод <a name="Index975"></a><b>hashCode(&#160;)</b> 
  - это метод корневого класса <a name="Index976"></a><b>Object</b>. <b>HashMap</b> 
  берет <b>hashCode(&#160;)</b> объекта и использует его для быстрого вылавливания 
  ключа. В результате получаем ощутимое прибавление производительности <a href="#fn50">[50]</a>.</FONT></P>
<TABLE BORDER>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>Map</B> (Интерфейс)</FONT></TD>
    <TD> <FONT FACE="Georgia">Содержит ассоциированные пары ключ-значение, так 
      что вы можете производить поиск значения, используя ключ.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>HashMap</B>*</FONT></TD>
    <TD> 
      <p><FONT FACE="Georgia">Реализация, основывающая на хеш-таблице. (Используйте 
        это вместо <B>Hashtable</B>.) Обеспечивает постоянную по времени производительность 
        при вставлении и поиске пар. Производительность может регулироваться конструктором, 
        который позволяет вам устанавливать <i>емкость</i> и <i>коэффициент загрузки</i> 
        хеш-таблицы.</FONT></p>
      </TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>TreeMap</B></FONT><BR>
    </TD>
    <TD> <FONT FACE="Georgia">Реализация, основывающаяся на красно-черном дереве. 
      Когда вы просматриваете ключи или пары, они будут упорядочены (определяется 
      <B>Comparable</B> или <B>Comparator</B>, будет обсуждаться позднее). Преимущество 
      <B>TreeMap</B> в том, что вы получаете результат отсортированным. <B>TreeMap</B> 
      - это просто <B>Map</B> с методом <B>subMap(&#160;)</B>, который позволяет 
      вам возвращать часть дерева.</FONT></TD>
  </TR>
</TABLE>
<p></P>
<P><FONT FACE="Georgia">Иногда вам также будет необходимо знать детали о работе 
  хеширования, так что мы рассмотрим это немного позже.</FONT></P>
<P><FONT FACE="Georgia">Приведенный пример использует метод <b>Collections2.fill(&#160;)</b> 
  и проверяет множества данных, которые только что были определены:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:Map1.java</font>
<font color=#009900>// То, что вы можете делать с  Maps.</font>
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Map1 {
  <font color=#0000ff>static</font> Collections2.StringPairGenerator geo = 
    Collections2.geography;
  <font color=#0000ff>static</font> Collections2.RandStringPairGenerator 
    rsp = Collections2.rsp;
  <font color=#009900>// Производим Set ключей:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> printKeys(Map m) {
    System.out.print(<font color=#004488>"Size = "</font> + m.size() +<font color=#004488>", "</font>);
    System.out.print(<font color=#004488>"Keys: "</font>);
    System.out.println(m.keySet());
  }
  <font color=#009900>// Производим Collection значений:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> printValues(Map m) {
    System.out.print(<font color=#004488>"Values: "</font>);
    System.out.println(m.values());
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> test(Map m) {
    Collections2.fill(m, geo, 25);
    <font color=#009900>// Map имеет поведение 'Set' для ключей:</font>
    Collections2.fill(m, geo.reset(), 25);
    printKeys(m);
    printValues(m);
    System.out.println(m);
    String key = CountryCapitals.pairs[4][0];
    String value = CountryCapitals.pairs[4][1];
    System.out.println(<font color=#004488>"m.containsKey(\"</font>" + key +
      <font color=#004488>"\"</font>): " + m.containsKey(key));
    System.out.println(<font color=#004488>"m.get(\"</font><font color=#004488>" + key + "</font>\<font color=#004488>"): "</font>
      + m.get(key));
    System.out.println(<font color=#004488>"m.containsValue(\"</font>" 
      + value + <font color=#004488>"\"</font>): " + 
      m.containsValue(value)); 
    Map m2 = <font color=#0000ff>new</font> TreeMap();
    Collections2.fill(m2, rsp, 25);
    m.putAll(m2);
    printKeys(m);
    key = m.keySet().iterator().next().toString();
    System.out.println(<font color=#004488>"First key in map: "</font>+key);
    m.remove(key);
    printKeys(m);
    m.clear();
    System.out.println(<font color=#004488>"m.isEmpty(): "</font> 
      + m.isEmpty());
    Collections2.fill(m, geo.reset(), 25);
    <font color=#009900>// Операции над Set меняют Map:</font>
    m.keySet().removeAll(m.keySet());
    System.out.println(<font color=#004488>"m.isEmpty(): "</font> 
      + m.isEmpty());
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    System.out.println(<font color=#004488>"Testing HashMap"</font>);
    test(<font color=#0000ff>new</font> HashMap());
    System.out.println(<font color=#004488>"Testing TreeMap"</font>);
    test(<font color=#0000ff>new</font> TreeMap());
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia"> Методы <B>printKeys(&#160;)</B> и <B>printValues(&#160;)</B> 
  не только полезные утилиты они также производят <b>Collection</b> из видов <b>Map</b>. 
  Метод <b>keySet(&#160;)</b> производит <b>Set</b> поддерживаемых ключей в <b>Map</b>. 
  Схожая трактовка дана <b>values(&#160;)</b>, который производит <b>Collection</b>, 
  содержащий все значения из <b>Map.</b> (Обратите внимание, что хотя ключи должны 
  быть уникальными, значения могут дублироваться.) Так как эти <b>Collection</b> 
  содержаться в <b>Map</b>, то любые изменения <b>Collection</b> отразятся и в 
  ассоциированном <b>Map</b>.</FONT></P>
<P><FONT FACE="Georgia">Оставшаяся часть программы приводит пример каждой операции 
  с <b>Map</b> и проверяет каждый тип <b>Map</b>.</FONT></P>
<P><FONT FACE="Georgia">В качестве использования <b>HashMap</b>, рассмотрим программу 
  для проверки случайности метода Java <a name="Index977"></a><a name="Index978"></a><b>Math.random(&#160;)</b>. 
  В идеале, он должен производить равномерно распределенные случайные числа, но 
  для проверки этого вам необходимо сгенерировать группу случайных чисел и посчитать 
  сколько из них попадет в различные пределы. <b>HashMap</b> лучше всего подходит 
  для этого, так как она ассоциирует объекты с объектами (в этом случае, значение 
  объекта содержит число, произведенное <b>Math.random(&#160;)</b> наряду с количеством 
  вхождений этого числа):</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:Statistics.java</font>
<font color=#009900>// Простая демонстрация HashMap.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> Counter { 
  <font color=#0000ff>int</font> i = 1; 
  <font color=#0000ff>public</font> String toString() { 
    <font color=#0000ff>return</font> Integer.toString(i); 
  }
}

<font color=#0000ff>class</font> Statistics {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    HashMap hm = <font color=#0000ff>new</font> HashMap();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10000; i++) {
      <font color=#009900>// Производим число от 0 до 20:</font>
      Integer r = 
        <font color=#0000ff>new</font> Integer((<font color=#0000ff>int</font>)(Math.random() * 20));
      <font color=#0000ff>if</font>(hm.containsKey(r))
        ((Counter)hm.get(r)).i++;
      <font color=#0000ff>else</font>
        hm.put(r, <font color=#0000ff>new</font> Counter());
    }
    System.out.println(hm);
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">В <B>main(&#160;)</B> при каждой генерации случайного 
  числа оно помещается в класс-оболочку <b>Integer</b>, так чтоб эта ссылка могла 
  использоваться <b>HashMap</b>. (Вы не можете использовать примитивные типы с 
  контейнером, только ссылки на объект.) Метод <b>containsKey(&#160;)</b> проверяет, 
  есть ли ключ уже в контейнере. (То есть, было ли число уже найдено?) Если это 
  так, метод <a name="Index979"></a><b>get(&#160;)</b> производит ассоциированное 
  значение для этого ключа, которое, в этом случае, является объектом <b>Counter</b>. 
  Значение <b>i</b> внутри счетчика инкрементируется, указывая, что определенное 
  случайное число было обнаружено еще раз.</FONT></P>
<P><FONT FACE="Georgia">Если ключ до сих пор не был найден, метод <a name="Index980"></a><b>put(&#160;)</b> 
  поместит новую пару ключ-значение в <b>HashMap</b>. Так как <b>Counter</b> автоматически 
  инициализирует свою переменную <b>i</b> при создании, это указывает на первое 
  появление определенного случайного числа.</FONT></P>
<P><FONT FACE="Georgia">Для отображения <b>HashMap</b>, он просто печатается. 
  Метод <b>HashMap</b> <b>toString(&#160;)</b> проходит по всем парам ключ-значение 
  и вызывает <b>toString(&#160;)</b> для каждого из них. <b>Integer.toString(&#160;)</b> 
  является предопределенным и вы можете видеть <b>toString(&#160;)</b> для <b>Counter</b>. 
  При запуска мы получим такой вывод (после добавления нескольких символов конец 
  строки):</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>{19=526, 18=533, 17=460, 16=513, 15=521, 14=495,
 13=512, 12=483, 11=488, 10=487, 9=514, 8=523,
 7=497, 6=487, 5=480, 4=489, 3=509, 2=503, 1=475,
 0=505}</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Вы можете быть удивлены необходимость класса <b>Counter,</b> 
  для которого кажется, что он не имеет даже функциональности класса-оболочки 
  <b>Integer</b>. Почему не использовать <b>int</b> или <b>Integer</b>? Хорошо, 
  мы не можем использовать <b>int</b> потому, что все контейнеры могут хранить 
  только ссылки на <b>Object</b>. После рассмотрения контейнеров классы-оболочки 
  могли бы иметь для вас больше смысла, так как вы не можете поместить любой примитивный 
  тип в контейнер. Однако есть только одна вещь, которую вы <i>можете</i> делать 
  с <a name="Index981"></a>оболочками в Java - это инициализация его определенным 
  значением и чтение этого значения. То есть, нет способа изменить значение, как 
  только оболочка будет создана. Это немедленно делает оболочку <b>Integer</b> 
  бесполезной для решения нашей проблемы, так что мы вынуждены создавать новый 
  класс, который удовлетворяет нашим требованиям.</FONT><A NAME="_Toc481064691"></A></P>
<A NAME="Heading306"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
SortedMap</H3></FONT>
<P><FONT FACE="Georgia">Если у вас есть </FONT> <FONT FACE="Georgia"> <B>SortedMap</B> 
  (из которых поддерживается только один <B>TreeMap</B>), то гарантируется, что 
  ключи будут храниться упорядоченными, что позволяет получить дополнительную 
  функциональность, которая обеспечивается методами интерфейса <B>SortedMap</B>:</FONT></P>
<P><FONT FACE="Georgia"><B>Comparator comparator():</B> Производит сравниватель, 
  используемый для этого <B>Map</B>, или <B>null</B> для естественного упорядочивания.</FONT></P>
<DIV ALIGN="LEFT"> 
  <P><FONT FACE="Georgia"><B>Object firstKey():</B> Производит низший ключ.</FONT></P>
</DIV>
<DIV ALIGN="LEFT">
  <P><FONT FACE="Georgia"><B>Object lastKey():</B> Производит высший ключ.</FONT></P>
</DIV>
<P><FONT FACE="Georgia"><B>SortedMap subMap(fromKey, toKey):</B> Производит вид 
  этого <b>Map</b> с ключами от <b>fromKey</b>, включительно, по <b>toKey</b>, 
  исключительно.</FONT></P>
<P><FONT FACE="Georgia"><B>SortedMap headMap(toKey):</B> Производит вид этого 
  <b>Map</b> с ключами, меньшими <B> toKey</B>.</FONT></P>
<P><FONT FACE="Georgia"><B>SortedMap tailMap(fromKey):</B> Производит вид этого 
  <b>Map</b> с ключами, большими или равными <B>fromKey</B>.</FONT><A NAME="_Toc481064692"></A></P>
<A NAME="Heading307"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Хеширование и хеш-коды</H3>
</FONT> 
<P><FONT FACE="Georgia">В предыдущем примере класс стандартной библиотеки (<b>Integer</b>) 
  использовался в качестве ключа для <b>HashMap</b>. Он великолепно работает в 
  качестве ключа, потому что он имеет все необходимые записи, чтобы корректно 
  работать в качестве ключа. Но основные ловушки, случающиеся с <b>HashMap</b>, 
  возникают тогда, когда вы создаете свой собственный класс для использования 
  в качестве ключа. Например, рассмотрим систему прогнозирования погоды, которая 
  ставит в соответствие объекты <b>Groundhog</b> с объектами <b>Prediction</b>. 
  Это кажется достаточно просто: вы создаете два класса и используете <b>Groundhog</b> 
  в качестве ключа, а <b>Prediction</b> в качестве значения:</FONT> </P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:SpringDetector.java</font>
<font color=#009900>// выглядит правдоподобно, но не работает.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> Groundhog {
  <font color=#0000ff>int</font> ghNumber;
  Groundhog(<font color=#0000ff>int</font> n) { ghNumber = n; }
}

<font color=#0000ff>class</font> Prediction {
  <font color=#0000ff>boolean</font> shadow = Math.random() &gt; 0.5;
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>if</font>(shadow)
      <font color=#0000ff>return</font> <font color=#004488>"Six more weeks of Winter!"</font>;
    <font color=#0000ff>else</font>
      <font color=#0000ff>return</font> <font color=#004488>"Early Spring!"</font>;
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SpringDetector {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    HashMap hm = <font color=#0000ff>new</font> HashMap();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
      hm.put(<font color=#0000ff>new</font> Groundhog(i), <font color=#0000ff>new</font> Prediction());
    System.out.println(<font color=#004488>"hm = "</font> + hm + <font color=#004488>"\n"</font>);
    System.out.println(
      <font color=#004488>"Looking up prediction for Groundhog #3:"</font>);
    Groundhog gh = <font color=#0000ff>new</font> Groundhog(3);
    <font color=#0000ff>if</font>(hm.containsKey(gh))
      System.out.println((Prediction)hm.get(gh));
    <font color=#0000ff>else</font>
      System.out.println(<font color=#004488>"Key not found: "</font> + gh);
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia"> Каждому <B>Groundhog</B> дан идентификационный номер, 
  так что вы можете искать <b>Prediction</b> в <b>HashMap</b>, говоря: &#8220;Дайте 
  мне <b>Prediction</b>, ассоциированный с <b> </b> <b>Groundhog</b> под номером 
  3&#8221;. Класс <b>Prediction</b> содержит <b>boolean</b>, который инициализируется 
  с использованием <b>Math.random(&#160;)</b>, и <b>toString(&#160;)</b>, который 
  интерпретирует результат для вас. В <b>main(&#160;)</b> заполняется <b>HashMap</b> 
  с помощью <b>Groundhog</b> и ассоциированными <b>Prediction</b>. <b>HashMap</b> 
  печатается, так что вы можете видеть, как он заполнен. Затем <b>Groundhog</b> 
  с идентификационным номером 3 используется в качестве ключа для поиска прогноза 
  для <b>Groundhog</b> №3 (который, как вы видите, должен быть в <b>Map</b>).</FONT></P>
<P><FONT FACE="Georgia">Это выглядит достаточным, но это не работает. Проблема 
  в том, что <b>Groundhog</b> наследуется от общего корневого класса <b>Object</b> 
  (что происходит в том случае, когда вы не указываете базовый класс, так как 
  все классы наследуются от <b>Object</b>). Этот метод <b>hashCode(&#160;)</b> 
  класса <b>Object</b> используется для генерации хеш кода для каждого объекта, 
  а по умолчанию он просто использует адрес этого объекта. Таким образом, первый 
  экземпляр <b>Groundhog(3)</b> не производит хеш код, равный хеш коду для второго 
  экземпляра <b>Groundhog(3)</b> который мы пробуем использовать для поиска.</FONT></P>
<P><FONT FACE="Georgia">Вы можете подумать, что все, что вам нужно сделать, это 
  написать соответствующую перегрузку для <a name="Index982"></a><b>hashCode(&#160;)</b>. 
  Но это все равно не будет работать, пока вы не сделаете еще одну вещь: перегрузка 
  метода <a name="Index983"></a><b>equals(&#160;)</b>, который тоже является частью 
  <b>Object</b>. Этот метод используется <b>HashMap</b> когда происходит попытка 
  определить, что ваш ключ равен ключу из таблицы. Опять таки, по умолчанию <b>Object.equals(&#160;)</b> 
  просто сравнивает адреса объектов, так что один <b>Groundhog(3)</b> не равен 
  другому <b>Groundhog(3)</b>.</FONT></P>
<P><FONT FACE="Georgia">Таким образом, для использования вашего собственного класса 
  в качестве ключа в <b>HashMap</b>, вы должны перегрузить и <b>hashCode(&#160;)</b>, 
  и <b>equals(&#160;)</b>, как показано в следующем решении возникшей выше проблемы:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:SpringDetector2.java</font>
<font color=#009900>// Класс, который используется в качестве ключа в HashMap,</font>
<font color=#009900>// должен перегружать  hashCode() и equals().</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> Groundhog2 {
  <font color=#0000ff>int</font> ghNumber;
  Groundhog2(<font color=#0000ff>int</font> n) { ghNumber = n; }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> hashCode() { <font color=#0000ff>return</font> ghNumber; }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> equals(Object o) {
    <font color=#0000ff>return</font> (o <font color=#0000ff>instanceof</font> Groundhog2)
      &amp;&amp; (ghNumber == ((Groundhog2)o).ghNumber);
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SpringDetector2 {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    HashMap hm = <font color=#0000ff>new</font> HashMap();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
      hm.put(<font color=#0000ff>new</font> Groundhog2(i),<font color=#0000ff>new</font> Prediction());
    System.out.println(<font color=#004488>"hm = "</font> + hm + <font color=#004488>"\n"</font>);
    System.out.println(
      <font color=#004488>"Looking up prediction for groundhog #3:"</font>);
    Groundhog2 gh = <font color=#0000ff>new</font> Groundhog2(3);
    <font color=#0000ff>if</font>(hm.containsKey(gh))
      System.out.println((Prediction)hm.get(gh));
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Обратите внимание, что здесь используется класс <b>Prediction</b> 
  из предыдущего примера, так что <b>SpringDetector.java</b> должен быть откомпилирован 
  первым или вы получите ошибку времени компиляции, когда попробуете откомпилировать 
  <b>SpringDetector2.java</b>.</FONT></P>
<P><FONT FACE="Georgia"><B>Groundhog2.hashCode(&#160;)</B> возвращает номер groundhog 
  в качестве идентификатора. В этом примере программист отвечает за то, что не 
  будет существовать два одинаковых groundhog с одним и тем же идентификационным 
  номером. <b>hashCode(&#160;) </b>не требует возврата уникального идентификатора 
  (кое-что вы поймете лучше позднее в этой главе), но метод <b>equals(&#160;)</b> 
  должен быть способен точно определить равны два объекта или нет.</FONT></P>
<P><FONT FACE="Georgia">Даже притом, что метод <b>equals(&#160;)</b> только проверяет, 
  является ли аргумент экземпляром <b>Groundhog2</b> (использование ключевого 
  слова <b>instanceof</b> будет полностью объяснено в <a href="Chapter12.html">Главе 
  12</a>), <b>instanceof</b> на самом деле спокойно выполняет вторую необходимую 
  проверку, проверяет, что объект - это не <b>null</b>, так как <b>instanceof</b> 
  производит <b>false</b>, если левый аргумент - это <b>null</b>. Принимая это 
  во внимание, получаем, что необходимо соответствие типов и не <b>null</b>, сравнение 
  основывается на реальных <b>ghNumber</b>. Когда вы запустите программу, вы увидите 
  что получаете на выходе правильный результат.</FONT></P>
<P><FONT FACE="Georgia">Когда создаете ваши собственные класса для использования 
  в <b>HashSet</b>, вы должны уделять внимание тем же проблемам, что и при использовании 
  в качестве ключей в <b>HashMap</b>.</FONT></P>
<A NAME="Heading308"></A><FONT FACE = "Verdana">
<H4 ALIGN="LEFT"> Понимание hashCode(&#160;)</H4>
</FONT> 
<P><FONT FACE="Georgia">Приведенный выше пример - это только первый шаг на пути 
  правильного решения проблемы. Он показывает, что если вы не перегрузите <a name="Index984"></a><b>hashCode(&#160;)</b> 
  и <a name="Index985"></a><b>equals(&#160;)</b> для вашего ключа, хешируемые 
  структуры данных (<b>HashSet</b> или <b>HashMap</b>) не будут способны иметь 
  дело с вашими ключами. Однако для получения хорошего решения проблемы вам необходимо 
  понимать, что происходит внутри хешируемой структуры данных.</FONT></P>
<P><FONT FACE="Georgia">Во-первых, рассмотрим мотивацию хеширования: вы хотите 
  искать объект, используя другой объект. Но вы также можете выполнить это с помощью 
  <b>TreeSet</b> или <b>TreeMap</b>. Также возможно реализовать свой собственный 
  <b>Map</b>. Для этого должен прилагаться метод <b>Map.entrySet(&#160;)</b>, 
  для производства множества объектов <b>Map.Entry</b>. <b>MPair</b> будет определен 
  как новый тип <a name="Index987"></a><b>Map.Entry</b>. Для правильной работы 
  при помещении в <b>TreeSet</b> должен быть реализован метод <b>equals(&#160;)</b> 
  и должен быть </FONT><FONT FACE="Georgia"> <B>Comparable</B>:</FONT></P>
<DIV ALIGN="LEFT"></DIV>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:MPair.java</font>
<font color=#009900>// Map реализованный с помощью ArrayLists.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> MPair 
<font color=#0000ff>implements</font> Map.Entry, Comparable {
  Object key, value;
  MPair(Object k, Object v) {
    key = k;
    value = v;
  }
  <font color=#0000ff>public</font> Object getKey() { <font color=#0000ff>return</font> key; }
  <font color=#0000ff>public</font> Object getValue() { <font color=#0000ff>return</font> value; }
  <font color=#0000ff>public</font> Object setValue(Object v){
    Object result = value;
    value = v;
    <font color=#0000ff>return</font> result;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> equals(Object o) {
    <font color=#0000ff>return</font> key.equals(((MPair)o).key);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> compareTo(Object rv) {
    <font color=#0000ff>return</font> ((Comparable)key).compareTo(
      ((MPair)rv).key);
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>

<p><font face="Georgia">Обратите внимание, что сравнение интересует только для 
  ключей, так что допустимы дублирующие значения.</font></p>
<P><FONT FACE="Georgia">Приведенный пример реализует <B>Map</B>, используя пары 
  из <B>ArrayList</B>:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:SlowMap.java</font>
<font color=#009900>// A Map implemented with ArrayLists.</font>
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SlowMap <font color=#0000ff>extends</font> AbstractMap {
  <font color=#0000ff>private</font> ArrayList
    keys = <font color=#0000ff>new</font> ArrayList(),
    values = <font color=#0000ff>new</font> ArrayList();
  <font color=#0000ff>public</font> Object put(Object key, Object value) {
    Object result = get(key);
    <font color=#0000ff>if</font>(!keys.contains(key)) {
      keys.add(key);
      values.add(value);
    } <font color=#0000ff>else</font>
      values.set(keys.indexOf(key), value);
    <font color=#0000ff>return</font> result;
  }
  <font color=#0000ff>public</font> Object get(Object key) {
    <font color=#0000ff>if</font>(!keys.contains(key))
      <font color=#0000ff>return</font> <font color=#0000ff>null</font>;
    <font color=#0000ff>return</font> values.get(keys.indexOf(key));
  }
  <font color=#0000ff>public</font> Set entrySet() {
    Set entries = <font color=#0000ff>new</font> HashSet();
    Iterator
      ki = keys.iterator(),
      vi = values.iterator();
    <font color=#0000ff>while</font>(ki.hasNext())
      entries.add(<font color=#0000ff>new</font> MPair(ki.next(), vi.next()));
    <font color=#0000ff>return</font> entries;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    SlowMap m = <font color=#0000ff>new</font> SlowMap();
    Collections2.fill(m, 
      Collections2.geography, 25);
    System.out.println(m);    
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Метод <B>put(&#160;)</B> просто помещает ключ и значение 
  в соответствующий <b>ArrayList</b>. В <b>main(&#160;)</b> загружается <b>SlowMap</b>, 
  а затем печатается так же медленно, как и работает.</FONT></P>
<P><FONT FACE="Georgia">Это показывает, что не так сложно произвести новый тип 
  <b>Map</b>. Но как подсказывает имя, <b>SlowMap</b> не является быстрым, так 
  что вы, вероятно, не будите использовать его, если вы имеете альтернативные 
  варианты. Проблема заключается в поиске ключа: здесь нет упорядочивания, поэтому 
  используется простой линейный поиск, являющийся самым медленным способом поиска.</FONT></P>
<P><FONT FACE="Georgia">Главное преимущество хеширования - скорость: хеширование 
  позволяет искать исключительно быстро. Так как узкое место в скорости поиска 
  ключа, одно из решений проблемы может быть в хранении ключей в отсортированном 
  порядке и использование <b>Collections.binarySearch(&#160;)</b> для выполнения 
  поиска (упражнения в конце этой главы проведут вас по этому процессу).</FONT></P>
<P><FONT FACE="Georgia">Хеширование идет дальше, говоря, что все, что вы хотите 
  делать - это хранить ключи <i>где угодно</i> так, чтобы они могли быть быстро 
  найдены. Как вы увидите в этой главе, самая быстрая структура, в которой хранится 
  группа элементов - </FONT>это массив, который будет использован для представления 
  информации о ключах (обратите особое внимание, что я сказал <font face="Georgia">&#8220;ключевой 
  информации&#8221;, а не самих ключей). Также вы увидите в этой главе, что однажды 
  выделенный массив не может изменить размер, так что мы имеем проблему: мы хотим 
  быть способны хранить любое число значений в <b>Map</b>, но если число ключей 
  фиксировано размером массива, как мы это можем сделать?</font></P>
<P><FONT FACE="Georgia">Ответ заключается в том, что массив не хранит ключи. Из 
  объекта ключа получается число, которое будет индексироваться в массиве. Это 
  число является <a name="Index988"></a><i>хеш кодом</i>, производимым методом 
  <b>hashCode(&#160;)</b> (на научном компьютерном языке - это <i>хеш-функция</i>), 
  определенном в <b>Object</b> и, предположительно, перегруженная вашим классом. 
  Для решения проблемы фиксированного размера массива: один и тот же индекс может 
  производиться разными ключами. То есть, здесь могут быть <a name="Index990"></a>коллизии. 
  Поэтому, не имеет значения, насколько велик массив, потому что каждый объект 
  ключа будет пребывать где-то в этом массиве.</FONT></P>
<P><FONT FACE="Georgia">Таким образом, процесс поиска значения начинается с подсчета 
  хеш кода и использовании его в качестве индекса в массиве. Если вы можете гарантировать, 
  что не будет коллизий (которые возможны из-за фиксированного числа значений), 
  то вы имеете <a name="Index991"></a><a name="Index992"></a><i>точную функцию 
  хеширования</i>, но это особый случай. Во всех остальных случаях коллизии обрабатываются 
  <a name="Index993"></a><i>внешней привязкой</i>: массив не прямо указывает на 
  значение, а вместо этого указывает на список значений. Эти значения ищутся линейным 
  способом, с помощью метода <b>equals(&#160;)</b>. Конечно эта сторона замедляет 
  поиск, но если у вас хорошая функция хеширования, то в большинстве случаев будет 
  лишь несколько значений в каждой ячейке. Так что вместо поиска во всем списке 
  вы быстро перепрыгиваете на ячейку, в которой лишь несколько включений для нахождения 
  значения. Это намного быстрее, поэтому <b>HashMap</b> такой быстрый.</FONT></P>
<P><FONT FACE="Georgia"> </FONT><FONT FACE="Georgia">Зная основы хеширования, 
  можно реализовать простой хешированный класс <B>Map</B>:</FONT></P>
<DIV ALIGN="LEFT"></DIV>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:SimpleHashMap.java</font>
<font color=#009900>// Демонстрация хешированного Map.</font>
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SimpleHashMap <font color=#0000ff>extends</font> AbstractMap {
  <font color=#009900>// Выбираем главное число размера хеш-таблицы</font>
  <font color=#009900>// для получения равномерного распределения:</font>
  <font color=#0000ff>private</font> <font color=#0000ff>final</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> SZ = 997;
  <font color=#0000ff>private</font> LinkedList[] bucket= <font color=#0000ff>new</font> LinkedList[SZ];
  <font color=#0000ff>public</font> Object put(Object key, Object value) {
    Object result = <font color=#0000ff>null</font>;
    <font color=#0000ff>int</font> index = key.hashCode() % SZ;
    <font color=#0000ff>if</font>(index &lt; 0) index = -index;
    <font color=#0000ff>if</font>(bucket[index] == <font color=#0000ff>null</font>)
      bucket[index] = <font color=#0000ff>new</font> LinkedList();
    LinkedList pairs = bucket[index];
    MPair pair = <font color=#0000ff>new</font> MPair(key, value);
    ListIterator it = pairs.listIterator();
    <font color=#0000ff>boolean</font> found = <font color=#0000ff>false</font>;
    <font color=#0000ff>while</font>(it.hasNext()) {
      Object iPair = it.next();
      <font color=#0000ff>if</font>(iPair.equals(pair)) {
        result = ((MPair)iPair).getValue();
        it.set(pair); <font color=#009900>// Замена старого новым</font>
        found = <font color=#0000ff>true</font>;
        <font color=#0000ff>break</font>;
      }
    }
    <font color=#0000ff>if</font>(!found)
      bucket[index].add(pair);
    <font color=#0000ff>return</font> result;
  }
  <font color=#0000ff>public</font> Object get(Object key) {
    <font color=#0000ff>int</font> index = key.hashCode() % SZ;
    <font color=#0000ff>if</font>(index &lt; 0) index = -index;
    <font color=#0000ff>if</font>(bucket[index] == <font color=#0000ff>null</font>) <font color=#0000ff>return</font> <font color=#0000ff>null</font>;
    LinkedList pairs = bucket[index];
    MPair match = <font color=#0000ff>new</font> MPair(key, <font color=#0000ff>null</font>);
    ListIterator it = pairs.listIterator();
    <font color=#0000ff>while</font>(it.hasNext()) {
      Object iPair = it.next();
      <font color=#0000ff>if</font>(iPair.equals(match))
        <font color=#0000ff>return</font> ((MPair)iPair).getValue();
    }
    <font color=#0000ff>return</font> <font color=#0000ff>null</font>;
  }
  <font color=#0000ff>public</font> Set entrySet() {
    Set entries = <font color=#0000ff>new</font> HashSet();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; bucket.length; i++) {
      <font color=#0000ff>if</font>(bucket[i] == <font color=#0000ff>null</font>) <font color=#0000ff>continue</font>;
      Iterator it = bucket[i].iterator();
      <font color=#0000ff>while</font>(it.hasNext())
        entries.add(it.next());
    }
    <font color=#0000ff>return</font> entries;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    SimpleHashMap m = <font color=#0000ff>new</font> SimpleHashMap();
    Collections2.fill(m, 
      Collections2.geography, 25);
    System.out.println(m);    
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Так как &#8220;ячейки&#8221; в хеш-таблице часто называются 
  <i>ковшом</i>, массив, который на самом деле представляет таблицу, называется 
  <b>bucket</b>. Для обеспечения лучшего распределения, число ковшей обычно является 
  простым числом. Обратите внимание, что это массив типа <b>LinkedList</b>, который 
  автоматически обеспечивает механизм для коллизий: каждый новый элемент он просто 
  добавляет в конец списка.</FONT></P>
<P><FONT FACE="Georgia"> </FONT><FONT FACE="Georgia">Возвращаемое значение для 
  <b>put(&#160;)</b> - это <b>null</b>, если ключ уже есть в списке и старое значение 
  уже ассоциировано с этим ключом. Возвращаемое значение равно <b>result</b>, 
  которое инициализируется значением <b>null</b>, но если ключ обнаружен в списке, 
  но этот ключ присваивается <b>result</b>.</FONT></P>
<P><FONT FACE="Georgia">Для <B>put(&#160;)</B> и <B>get(&#160;)</B> первое, что 
  выполняется - это вызов <b>hashCode(&#160;)</b> для ключа, а результат ограничивается 
  положительными значениями. Затем он ограничивается размерами массива <b>bucket</b> 
  с помощью оператора остатка от деления. Если это место - <b>null</b>, это означает, 
  что нет элементов предназначенных для этого места, поэтому создается новый <b>LinkedList</b> 
  для хранения полученного объекта. Однако нормальный процесс поиска проверяет 
  есть ли дубликаты, и если они есть, старое значение помещается в <b>result</b>, 
  а новое значение замещает старое. Флаг <b>found</b> хранит информацию о том, 
  была ли найдена старая пара ключ-значение и, если нет, новая пара добавляется 
  в конец списка.</FONT></P>
<P><FONT FACE="Georgia">В <B>get(&#160;)</B> вы увидите очень похожий код, что 
  и в <b>put(&#160;)</b>, но упрощенный. Рассчитывается индекс для массива <b>bucket</b>, 
  и если существует <b>LinkedList</b>, происходит поиск до совпадения.</FONT></P>
<P><FONT FACE="Georgia"><B>entrySet(&#160;)</B> должен 
  находить и обходить все списки, добавляя их в результирующий <b>Set</b>. Как 
  только этот метод был создан, <b>Map</b> может быть протестирован путем заполнения 
  его значениями и распечатыванием их.</FONT></P>
<A NAME="Heading309"></A><FONT FACE = "Verdana">
<H4 ALIGN="LEFT"> Фактор производительности HashMap</H4>
</FONT> 
<P><FONT FACE="Georgia">Для понимания проблемы необходима следующая терминология:</FONT></P>
<P><A NAME="Index994"></A><FONT FACE="Georgia"><B><I>Емкость</I></B>: Число 
  ковшей в таблице.</FONT></P>
<P><A NAME="Index995"></A><FONT FACE="Georgia"><B><I>Начальная емкость</I></B>: 
  Число ковшей при создании таблицы. <B>HashMap</B> и <B>HashSet</B> имеют конструкторы, 
  который позволяют вам указать начальную емкость.</FONT></P>
<P><A NAME="Index996"></A><FONT FACE="Georgia"><i><B>Размер</B></i>: Число вхождений, 
  имеющихся в таблице на данный момент.</FONT></P>
<P><A NAME="Index997"></A><FONT FACE="Georgia"><B><I>Коэффициент загрузки</I></B>: 
  размер/емкость. Коэффициент загрузки пустой таблицы равен 0, для заполненной 
  на половину равен 0,5, и т.д. мало заполненная таблица будет иметь мало коллизий, 
  что оптимально для вставки и поиска (но это замедляет процесс обхода с помощью 
  итератора). <B>HashMap</B> и <B>HashSet</B> имеют конструкторы, которые позволяют 
  указать коэффициент загрузки, который означает, что когда коэффициент загрузки 
  будет достигнут, контейнер автоматически увеличит емкость (число ковшей) грубым 
  удвоением и перераспределит существующие объекты в новый набор ковшей (это называется 
  <i>повторным хешированием</i>).</FONT></P>
<P><FONT FACE="Georgia">Коэффициент загрузки по умолчанию, используемый для <b>HashMap</b>,<b> 
  </b>равен 0.75 (это означает отсутствие повторного хеширования, пока таблица 
  не заполнена на &#190;). Это кажется хорошим соглашением между временем и затратами 
  места. Больший коэффициент загрузки уменьшает требуемое место для таблицы, но 
  увеличивает стоимость поиска, который важен, поскольку поиск - это то, что вы 
  делаете большую часть времени (включая и <b>get(&#160;)</b>, и <b>put(&#160;)</b>).</FONT></P>
<P><FONT FACE="Georgia">Если вы знаете, что будите хранить много вхождений в <b>HashMap</b>, 
  создавайте ее с достаточно большой начальной емкостью, это предотвратит превышение 
  размера и автоматическое повторное хеширование.</FONT><A NAME="_Toc481064693"></A></P>
<A NAME="Heading310"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Перегрузка hashCode(&#160;)</H3>
</FONT>
<P><FONT FACE="Georgia">Теперь, так как вы понимаете что подразумевается под функцией 
  <B>HashMap</B>, проблема написания <A NAME="Index998"></A><B>hashCode(&#160;)</B> 
  становится более ощутимой.</FONT></P>
<P><FONT FACE="Georgia">Прежде всего у вас нет инструмента контроля за созданием 
  реального значения, которое используется для индексирования массива ковшей. 
  Так как он зависит от емкости определенного объекта <b>HashMap</b>, а эта емкость 
  меняется в зависимости от того, насколько полон контейнер и каков коэффициент 
  загрузки. Значение, производимое вашим методом <b>hashCode(&#160;)</b> в будущем 
  будет использоваться для создания индекса ковша (в <b>SimpleHashMap</b> это 
  просто вычисление на основе остатка от деления на размер массива ковшей).</FONT></P>
<P><FONT FACE="Georgia">Более важный фактор при создании <b>hashCode(&#160;)</b> 
  это то, что независимо от времени вызова <b>hashCode(&#160;)</b> он производил 
  бы одно и то же значение для определенного объекта при каждом вызове. Если вы 
  работаете с объектом, для которого <b>hashCode(&#160;)</b> произвел одно значение 
  в методе <b>put(&#160;)</b> для <b>HashMap</b>, а другое в методе <b>get(&#160;)</b>, 
  вы не будете способны получить объект назад. Так что, если ваш <b>hashCode(&#160;)</b> 
  зависит от непостоянства данных объекта, пользователь должен быть уверен, что 
  при изменении данных будет результативно произведен новый ключ, сгенерированный 
  другим <b>hashCode(&#160;)</b>.</FONT></P>
<P><FONT FACE="Georgia">Кроме того, вероятно, вы <i>не</i> захотите генерировать 
  <b>hashCode(&#160;)</b>, который базируется на уникальной информации объекта, 
  обычно это значение <b>this</b>, которое делает плохой <b>hashCode(&#160;)</b>, 
  потому что вы не сможете сгенерировать новый ключ, идентичный использованному 
  в <b>put(&#160;) </b>в качестве исходной пары ключ-значение. Эта проблема случилась 
  в <b>SpringDetector.java</b>, потому что реализация по умолчанию <b>hashCode(&#160;) 
  </b><i>использует</i> адрес объекта. Поэтому вы захотите использовать информацию, 
  которая идентифицирует объект осмысленным образом.</FONT></P>
<P><FONT FACE="Georgia">Один пример найден в классе <b>String</b>. <b>String</b> 
  имеет специальную характеристику, так что если программа имеет несколько объектов 
  <b>String</b>, содержащих идентичную последовательность символов, то эти объекты 
  <b>String</b> ссылаются на одну и ту же память (этот механизм описан в <a href="AppendixA.html">Приложении 
  A</a>). Таким образом, имеет смысл, чтобы <b>hashCode(&#160;)</b>, производимый 
  двумя различными экземплярами <b>new String(&#8220;hello&#8221;)</b> были идентичными. 
  Вы можете проверить это, запустив программу.</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:StringHashCode.java</font>
<font color=#0000ff>public</font> <font color=#0000ff>class</font> StringHashCode {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    System.out.println(<font color=#004488>"Hello"</font>.hashCode());
    System.out.println(<font color=#004488>"Hello"</font>.hashCode());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Чтобы это работало, <B>hashCode(&#160;)</B> для <B>String</B> 
  должен базироваться на содержимом <B>String</B>.</FONT></P>
<P><FONT FACE="Georgia">Для эффективного <B>hashCode(&#160;)</B> необходим быстрый 
  и осмысленный механизм: то есть, он должен генерировать значение, основываясь 
  на содержимом объекта. Помните, что это значение не обязательно должно быть 
  уникальным &#8212; вы должны больше внимания уделить скорости, а не уникальности 
  &#8212; но с помощью <b>hashCode(&#160;)</b> и <b>equals(&#160;)</b> идентичность 
  должна быть полностью установлена.</FONT></P>
<P><FONT FACE="Georgia">Поскольку <B>hashCode(&#160;)</B> вызывается до того, 
  как будет произведен индекс ковша, диапазон значений не важен; просто должно 
  генерироваться число типа <B>int</B>.</FONT></P>
<P><FONT FACE="Georgia">Есть еще один фактор: хороший <b>hashCode(&#160;)</b> 
  должен возвращать хорошо распределенные значения. Если значения группируются, 
  то <b>HashMap</b> или <b>HashSet</b> будут тяжелее загружаться в некоторых областях 
  и не будут так же быстры, как это могло быть с функцией с хорошим распределением.</FONT></P>
<P><FONT FACE="Georgia">Вот пример, который следует этим руководящим принципам:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:CountedString.java</font>
<font color=#009900>// Создание хорошего hashCode().</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> CountedString {
  <font color=#0000ff>private</font> String s;
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> id = 0;
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> ArrayList created = 
    <font color=#0000ff>new</font> ArrayList();
  <font color=#0000ff>public</font> CountedString(String str) {
    s = str;
    created.add(s);
    Iterator it = created.iterator();
    <font color=#009900>// Id - это полное число экземпляров</font>
    <font color=#009900>// строки, используемой CountedString:</font>
    <font color=#0000ff>while</font>(it.hasNext())
      <font color=#0000ff>if</font>(it.next().equals(s))
        id++;
  }
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> <font color=#004488>"String: "</font> + s + <font color=#004488>" id: "</font> + id +
      <font color=#004488>" hashCode(): "</font> + hashCode() + <font color=#004488>"\n"</font>;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> hashCode() { 
    <font color=#0000ff>return</font> s.hashCode() * id;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> equals(Object o) {
    <font color=#0000ff>return</font> (o <font color=#0000ff>instanceof</font> CountedString)
      &amp;&amp; s.equals(((CountedString)o).s)
      &amp;&amp; id == ((CountedString)o).id;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    HashMap m = <font color=#0000ff>new</font> HashMap();
    CountedString[] cs = <font color=#0000ff>new</font> CountedString[10];
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; cs.length; i++) {
      cs[i] = <font color=#0000ff>new</font> CountedString(<font color=#004488>"hi"</font>);
      m.put(cs[i], <font color=#0000ff>new</font> Integer(i));
    }
    System.out.println(m);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; cs.length; i++) {
      System.out.print(<font color=#004488>"Looking up "</font> + cs[i]);
      System.out.println(m.get(cs[i]));
    }
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia"><B>CountedString</B> включает <B>String</B> и <B>id</B>, 
  который представляет число объектов <b>CountedString</b>, содержащих идентичный 
  <b>String</b>. Подсчет совершается в конструкторе при продвижение по <b>static 
  ArrayList</b>, где хранятся все <b>String</b>.</FONT></P>
<P><FONT FACE="Georgia"> </FONT><FONT FACE="Georgia">И <B>hashCode(&#160;)</B>, 
  и <B>equals(&#160;)</B> производят результат, базируясь на обоих полях; если 
  бы они базировались только на одном <b>String</b> или на одном <b>id</b>, то 
  были бы дублирующие совпадения для разных значений.</FONT></P>
<P><FONT FACE="Georgia">Обратите внимание насколько прост <b>hashCode(&#160;)</b>: 
  <b>hashCode(&#160;)</b> объекта <b>String</b> умножается на <b>d</b>. Краткость 
  обычно лучше (и быстрее) для <b>hashCode(&#160;)</b>.</FONT></P>
<P><FONT FACE="Georgia">В <B>main(&#160;)</B> создается группа объектов <b>CountedString</b>, 
  использующих один и тот же <b>String</b>, чтобы показать, что при дублировании 
  создаются уникальные значения, потому что используется счет <b>id</b>. <b>HashMap</b> 
  отображается так, что вы можете видеть как он хранится внутри (нет видимого 
  порядка), а затем каждый ключ ищется индивидуально, чтобы продемонстрировать, 
  что механизм поиска работает правильно.</FONT><A NAME="_Toc481064694"></A></P>
<A NAME="Heading311"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Хранение ссылок</H2>
</FONT> 
<P><FONT FACE="Georgia">Библиотека <B>java.lang.ref</B> содержит множество классов, 
  которые придают большую гибкость сборщику мусора, что особенно полезно, когда 
  у вас есть огромные объекты, могущие стать причиной нехватки памяти. Есть три 
  класса, наследованные от абстрактного класса <a name="Index999"></a><b>Reference</b>: 
  <a name="Index1000"></a><b>SoftReference</b>,<b> <a name="Index1001"></a>WeakReference</b> 
  и<b> <a name="Index1002"></a>PhantomReference</b>. Каждый из них обеспечивает 
  различный уровень обхода для сборщика мусора, если <i>только</i> рассматриваемый 
  объект достижим через один из этих объектов <b>Reference</b>.</FONT></P>
<P><FONT FACE="Georgia">Если объект <a name="Index1003"></a><a name="Index1004"></a>достижим, 
  это означает, что где-то в вашей программе этот объект может быть найден. Это 
  может означать, что вы имеете обычную ссылку в стеке, которая указывает прямо 
  не объект, но вы также можете иметь ссылку на объект, который имеет ссылку на 
  рассматриваемый объект; здесь может быть много промежуточных связей. Если объект 
  достижим, сборщик мусора не может освободить его, поскольку он все еще используется 
  вашей программой. Если объект не достижим, для вашей программы нет способа использовать 
  его, поэтому безопасно произвести сборку мусора за этим объектом.</FONT></P>
<P><FONT FACE="Georgia">Вы используете объекты <b>Reference</b> когда хотите продолжить 
  хранить в ссылке такой объект &#8212; вы хотите быть способны достигнуть объекта 
  &#8212; но вы также хотите позволить сборщику мусора освободить такой объект. 
  Таким образом, вы имеете способ перейти к использованию объекта, но если <a name="Index1005"></a>память 
  истощится, это грозит вам тем, что объект будет освобожден.</FONT></P>
<P><FONT FACE="Georgia">Вы выполните это, используя объект <b>Reference</b>, как 
  промежуточную ступень между вами и обычной ссылкой, и при этом не должно быть 
  обычных ссылок на объект (за исключением той, которая помещена внутрь объекта 
  <b>Reference</b>). Если сборщик мусора обнаруживает, что объект достижим через 
  обычную ссылку, он не освободит такой объект.</FONT></P>
<P><FONT FACE="Georgia">В порядке следования объектов <b>SoftReference</b>,<b> 
  WeakReference</b> и<b> PhantomReference</b>, каждый из них &#8220;слабее&#8221; 
  последнего и соответствует различному уровню достижимости. Мягкие (Soft) ссылки 
  предназначены для реализации чувствительного к памяти кэширования. Слабые (Weak) 
  ссылки предназначены для реализации &#8220;канонического преобразования&#8221; 
  &#8212; когда экземпляры объектов могут быть одновременно использованы в разных 
  местах программы, для сохранения хранилища &#8212; что не предотвращает ключи 
  (или значения) от замены. Фантомные (Phantom) ссылки предназначены для назначения 
  действий предсмертной очистки более гибким способом, чем это возможно с механизмом 
  финализации.</FONT></P>
<P><FONT FACE="Georgia">Для <B>SoftReference</B> и<B> WeakReference</B> у вас 
  есть выбор поместить ли их в <b>ReferenceQueue</b> (устройство, используемое 
  для предсмертных действий по очистке), а <b>PhantomReference</b> могут быть 
  построены только в <b>ReferenceQueue</b>. Вот пример простой демонстрации:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:References.java</font>
<font color=#009900>// Демонстрация объектов Reference</font>
<font color=#0000ff>import</font> java.lang.ref.*;

<font color=#0000ff>class</font> VeryBig {
  <font color=#0000ff>static</font> <font color=#0000ff>final</font> <font color=#0000ff>int</font> SZ = 10000;
  <font color=#0000ff>double</font>[] d = <font color=#0000ff>new</font> <font color=#0000ff>double</font>[SZ];
  String ident;
  <font color=#0000ff>public</font> VeryBig(String id) { ident = id; }
  <font color=#0000ff>public</font> String toString() { <font color=#0000ff>return</font> ident; }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> finalize() {
    System.out.println(<font color=#004488>"Finalizing "</font> + ident);
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> References {
  <font color=#0000ff>static</font> ReferenceQueue rq= <font color=#0000ff>new</font> ReferenceQueue();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> checkQueue() {
    Object inq = rq.poll();
    <font color=#0000ff>if</font>(inq != <font color=#0000ff>null</font>)
      System.out.println(<font color=#004488>"In queue: "</font> + 
        (VeryBig)((Reference)inq).get());
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>int</font> size = 10;
    <font color=#009900>// или выберите размер через командную строку:</font>
    <font color=#0000ff>if</font>(args.length &gt; 0)
      size = Integer.parseInt(args[0]);    
    SoftReference[] sa =
      <font color=#0000ff>new</font> SoftReference[size];
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; sa.length; i++) {
      sa[i] = <font color=#0000ff>new</font> SoftReference(
        <font color=#0000ff>new</font> VeryBig(<font color=#004488>"Soft "</font> + i), rq);
      System.out.println(<font color=#004488>"Just created: "</font> +
        (VeryBig)sa[i].get());
      checkQueue();
    }
    WeakReference[] wa =
      <font color=#0000ff>new</font> WeakReference[size];
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; wa.length; i++) {
      wa[i] = <font color=#0000ff>new</font> WeakReference(
        <font color=#0000ff>new</font> VeryBig(<font color=#004488>"Weak "</font> + i), rq);
      System.out.println(<font color=#004488>"Just created: "</font> +
        (VeryBig)wa[i].get());
      checkQueue();
    }
    SoftReference s = <font color=#0000ff>new</font> SoftReference(
      <font color=#0000ff>new</font> VeryBig(<font color=#004488>"Soft"</font>));
    WeakReference w = <font color=#0000ff>new</font> WeakReference(
      <font color=#0000ff>new</font> VeryBig(<font color=#004488>"Weak"</font>));
    System.gc();
    PhantomReference[] pa =
      <font color=#0000ff>new</font> PhantomReference[size];
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; pa.length; i++) {
      pa[i] = <font color=#0000ff>new</font> PhantomReference(
        <font color=#0000ff>new</font> VeryBig(<font color=#004488>"Phantom "</font> + i), rq);
      System.out.println(<font color=#004488>"Just created: "</font> +
        (VeryBig)pa[i].get());
      checkQueue();
    }
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Когда вы запустите эту программу (вам нужно перенаправить 
  вывод через утилиту &#8220;more&#8221;, так чтобы вы смогли просмотреть вывод 
  по страницам), вы увидите, что объекты обработаны сборщиком мусора, даже если 
  вы все еще имели доступ к ним через объекты <b>Reference</b> (для получения 
  реальной ссылки, вы должны использовать <b>get(&#160;)</b>). Вы также увидите, 
  что <b>ReferenceQueue</b> всегда производит <b>Reference</b>, содержащую <b>null</b> 
  объект. Чтобы использовать его, вы можете наследовать от обычного класса <b>Reference</b>, 
  который вас интересует и добавить больше полезных методов в новый тип </FONT><FONT FACE="Georgia"><B>Reference</B>.</FONT><A NAME="_Toc481064695"></A></P>
<A NAME="Heading312"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> WeakHashMap</H3>
</FONT> 
<P><FONT FACE="Georgia">Библиотека контейнеров имеет специальный <b>Map</b> для 
  хранения слабых ссылок: <a name="Index1006"></a><b>WeakHashMap</b>. Этот класс 
  предназначен для облегчения создания канонизированного преобразования. В таком 
  преобразовании вы сохраняете хранилище, создавая только один экземпляр определенного 
  значения. Когда программе нужно это значение, она ищет существующий объект в 
  преобразовании, использует его (а не создает еще один). Преобразование может 
  сделать значение частью своей инициализации, но это больше похоже на создание 
  значение по требованию.</FONT></P>
<P><FONT FACE="Georgia">Так как это техника содержания-хранения, то очень последовательным 
  является тот факт, что <b>WeakHashMap</b> позволяет сборщику мусора автоматически 
  очищать ключи и значения. Ван ничего не нужно делать специально с теми ключами 
  и значениями, которые вы хотите поместить в <b>WeakHashMap</b>; они автоматически 
  помещаются в класс-оболочку <b>WeakReference</b>. Признаком того, что можно 
  производить очистку является тот факт, что ключ более не используется, как показано 
  здесь:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:CanonicalMapping.java</font>
<font color=#009900>// Демонстрация WeakHashMap.</font>
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> java.lang.ref.*;

<font color=#0000ff>class</font> Key {
  String ident;
  <font color=#0000ff>public</font> Key(String id) { ident = id; }
  <font color=#0000ff>public</font> String toString() { <font color=#0000ff>return</font> ident; }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> hashCode() { 
    <font color=#0000ff>return</font> ident.hashCode();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> equals(Object r) {
    <font color=#0000ff>return</font> (r <font color=#0000ff>instanceof</font> Key)
      &amp;&amp; ident.equals(((Key)r).ident);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> finalize() {
    System.out.println(<font color=#004488>"Finalizing Key "</font>+ ident);
  }
}

<font color=#0000ff>class</font> Value {
  String ident;
  <font color=#0000ff>public</font> Value(String id) { ident = id; }
  <font color=#0000ff>public</font> String toString() { <font color=#0000ff>return</font> ident; }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> finalize() {
    System.out.println(<font color=#004488>"Finalizing Value "</font>+ident);
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> CanonicalMapping {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>int</font> size = 1000;
    <font color=#009900>// Или выбираем размер из командной строки:</font>
    <font color=#0000ff>if</font>(args.length &gt; 0)
      size = Integer.parseInt(args[0]);    
    Key[] keys = <font color=#0000ff>new</font> Key[size];
    WeakHashMap whm = <font color=#0000ff>new</font> WeakHashMap();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; size; i++) {
      Key k = <font color=#0000ff>new</font> Key(Integer.toString(i));
      Value v = <font color=#0000ff>new</font> Value(Integer.toString(i));
      <font color=#0000ff>if</font>(i % 3 == 0)
        keys[i] = k; <font color=#009900>// Сохраняем как "реальную" ссылку</font>
      whm.put(k, v);
    }
    System.gc();
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Класс <B>Key</B> должен иметь <B>hashCode(&#160;)</B> 
  и <B>equals(&#160;)</B>, так как он используется в качестве ключа в хешированной 
  структуре данных, как было описано ранее в этой главе.</FONT></P>
<P><FONT FACE="Georgia">Когда вы запустите программу, вы увидите, что сборщик 
  мусора пропустит только третий ключ, потому что он обычным образом указывает 
  на тот ключ, который был помещен в массив <b>keys</b> и поэтому эти объекты 
  не могут быть почищены.</FONT><A NAME="_Toc375545358"></A><A NAME="_Toc481064696"></A></P>
<A NAME="Heading313"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Снова об итераторах</H2>
</FONT> 
<P><FONT FACE="Georgia">Теперь мы продемонстрировать полную мощь <a name="Index1007"></a><b>Iterator</b>: 
  способность разделять операции прохода последовательности от базовой структуры 
  последовательности. В приведенном ниже примере класс <b>PrintData</b> использует 
  <b>Iterator</b> для перемещения по последовательности и вызова метода <a name="Index1008"></a><b>toString(&#160;)</b> 
  для каждого объекта. Создаются два разных типа контейнеров &#8212; <a name="Index1009"></a><b>ArrayList</b> 
  и <a name="Index1010"></a><b>HashMap</b> &#8212; и каждый из них заполняется 
  объектами <b>Mouse </b>и <b>Hamster</b>, соответственно. (Эти классы определены 
  раньше в этой главе.) Поскольку <b>Iterator </b>прячет структуру используемого 
  контейнера, <b>PrintData</b> не знает и не заботится о виде контейнера, от которого 
  получен <b>Iterator</b>:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:Iterators2.java</font>
<font color=#009900>// Снова об итераторах.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> PrintData {
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> print(Iterator e) {
    <font color=#0000ff>while</font>(e.hasNext())
      System.out.println(e.next());
  }
}

<font color=#0000ff>class</font> Iterators2 {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    ArrayList v = <font color=#0000ff>new</font> ArrayList();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 5; i++)
      v.add(<font color=#0000ff>new</font> Mouse(i));
    HashMap m = <font color=#0000ff>new</font> HashMap();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 5; i++)
      m.put(<font color=#0000ff>new</font> Integer(i), <font color=#0000ff>new</font> Hamster(i));
    System.out.println(<font color=#004488>"ArrayList"</font>);
    PrintData.print(v.iterator());
    System.out.println(<font color=#004488>"HashMap"</font>);
    PrintData.print(m.entrySet().iterator());
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Для <B>HashMap</B> метод <b>entrySet(&#160;)</b> производит 
  <b>Set</b> из объектов <b>Map.entry</b>, которые содержат ключ и значение для 
  каждого вхождения, так что вы видите, что они оба напечатаются.</FONT></P>
<P><FONT FACE="Georgia">Обратите внимание, что <b>PrintData.print(&#160;)</b> 
  берет в помощь тот факт, что объекты в этом контейнере класса <b>Object</b>, 
  так что вызов <b>toString(&#160;)</b> из <b>System.out.println(&#160;) </b>происходит 
  автоматически. Это лучше для вашей проблемы, вы должны принять во внимание, 
  что ваш <b>Iterator</b> обходит весь контейнер определенного типа. Например, 
  вы можете принять во внимание, что все в контейнере - это <b>Shape</b> с методом 
  <b>draw(&#160;)</b>. Затем в должны выполнить обратное приведение от типа <b>Object</b>, 
  который возвращает <b>Iterator.next(&#160;)</b>, для получения типа </FONT><FONT FACE="Georgia"><B>Shape</B>.</FONT><A NAME="_Toc481064697"></A></P>
<DIV ALIGN="LEFT"></DIV>
<A NAME="Heading314"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Выбор реализации</H2>
</FONT> 
<P><FONT FACE="Georgia">Теперь вы должны понимать, что на самом деле есть только 
  три компоненты контейнера: <b>Map</b>, <b>List</b> и <b>Set</b>, и только два 
  из трех реализуют каждый интерфейс. Если вам необходимо использовать функциональность, 
  предлагаемую определенным интерфейсом, как вам решить какую именно реализацию 
  использовать?</FONT></P>
<P><FONT FACE="Georgia">Для понимания ответа вы должны усвоить, что каждая из 
  реализаций имеет свои особенности, странности и слабости. Например, вы можете 
  увидеть на диаграмме, что эти &#8220;особенности&#8221; <b>Hashtable</b>, <b>Vector</b> 
  и <b>Stack</b> являются допустимыми для класса ни не вредят старому коду. С 
  другой стороны, лучше, если вы не используете этого для новый код (Java 2).</FONT></P>
<P><FONT FACE="Georgia">Различия между контейнерами часто исходят из того, что 
  они &#8220;обслуживают&#8221;; то есть, структуры данных, которые физически 
  реализуют необходимый <b>интерфейс</b>. Это означает, например, что <b>ArrayList</b> 
  и<b> LinkedList</b> реализуют интерфейс <b>List</b>, поэтому ваша программа 
  будет выдавать одинаковый результат независимо от того, что вы используете. 
  Однако <b>ArrayList</b> обслуживается массивом, а <b>LinkedList</b> реализован 
  обычным способом для списков с двойным связыванием, в котором есть индивидуальные 
  объекты, каждый из которых содержит данные наряду со ссылками на предыдущий 
  и следующий элемент списка. По этой причине, если вы хотите выполнять много 
  вставок и удалений в середину списка, наиболее подходящим выбором будет <b>LinkedList</b>. 
  (<b>LinkedList</b> также имеет дополнительную функциональность, которая основывается 
  на <a name="Index1011"></a><b>AbstractSequentialList</b>.) Если это не нужно, 
  то <b>ArrayList</b> обычно быстрее.</FONT></P>
<P><FONT FACE="Georgia">В качестве другого примера, <b>Set</b> может быть реализован 
  либо как <b>TreeSet</b>, либо как <b>HashSet</b>. <b>TreeSet</b> основывается 
  на <b>TreeMap</b> и предназначается для производства постоянно упорядоченного 
  множества. Однако, если вы будете использовать большой набор данных для вашего 
  <b>Set</b>, производительность вставки в <b>TreeSet</b> уменьшится. Когда вы 
  пишите программу, в которой нужен <b>Set</b>, вы должны выбрать по умолчанию 
  <b>HashSet</b> и изменить на <b>TreeSet</b>, если более важной задачей является 
  получение постоянного упорядочивания множества.</FONT><A NAME="_Toc481064698"></A></P>
<DIV ALIGN="LEFT"></DIV>
<A NAME="Heading315"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Выбор между списками (List)</H3>
</FONT> 
<p>Наиболее убедительный способ увидеть различия между реализациями <font face="Georgia"><b>List</b> 
  - это с помощью теста производительности. Следующий код создает внутренний базовый 
  класс для использования в качестве тестовой структуры, затем создается массив 
  <a name="Index1012"></a><a name="Index1013"></a><a name="Index1014"></a>анонимных 
  внутренних классов, каждый из которых для различных тестов. Каждый из этих внутренних 
  классов вызывается методом <b>test(&#160;)</b>. Этот метод позволяет вам легко 
  добавлять и удалять новые виды тестов.</font></p>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:ListPerformance.java</font>
<font color=#009900>// Демонстрация разницы производительности разных списков.</font>
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ListPerformance {
  <font color=#0000ff>private</font> <font color=#0000ff>abstract</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> Tester {
    String name;
    <font color=#0000ff>int</font> size; <font color=#009900>// Тест качества</font>
    Tester(String name, <font color=#0000ff>int</font> size) { 
      <font color=#0000ff>this</font>.name = name;
      <font color=#0000ff>this</font>.size = size;
    }
    <font color=#0000ff>abstract</font> <font color=#0000ff>void</font> test(List a, <font color=#0000ff>int</font> reps);
  }
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Tester[] tests = {
    <font color=#0000ff>new</font> Tester(<font color=#004488>"get"</font>, 300) { 
      <font color=#0000ff>void</font> test(List a, <font color=#0000ff>int</font> reps) {
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; reps; i++) {
          <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; a.size(); j++)
            a.get(j);
        }
      }
    },
    <font color=#0000ff>new</font> Tester(<font color=#004488>"iteration"</font>, 300) { 
      <font color=#0000ff>void</font> test(List a, <font color=#0000ff>int</font> reps) {
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; reps; i++) {
          Iterator it = a.iterator();
          <font color=#0000ff>while</font>(it.hasNext())
            it.next();
        }
      }
    },
    <font color=#0000ff>new</font> Tester(<font color=#004488>"insert"</font>, 5000) { 
      <font color=#0000ff>void</font> test(List a, <font color=#0000ff>int</font> reps) {
        <font color=#0000ff>int</font> half = a.size()/2;
        String s = <font color=#004488>"test"</font>;
        ListIterator it = a.listIterator(half);
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; size * 10; i++)
          it.add(s);
      }
    },
    <font color=#0000ff>new</font> Tester(<font color=#004488>"remove"</font>, 5000) { 
      <font color=#0000ff>void</font> test(List a, <font color=#0000ff>int</font> reps) {
        ListIterator it = a.listIterator(3);
        <font color=#0000ff>while</font>(it.hasNext()) {
          it.next();
          it.remove();
        }
      }
    },
  };
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> test(List a, <font color=#0000ff>int</font> reps) {
    <font color=#009900>// Отслеживание с помощью печати имени класса:</font>
    System.out.println(<font color=#004488>"Testing "</font> + 
      a.getClass().getName());
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; tests.length; i++) {
      Collections2.fill(a, 
        Collections2.countries.reset(),
        tests[i].size);
      System.out.print(tests[i].name);
      <font color=#0000ff>long</font> t1 = System.currentTimeMillis();
      tests[i].test(a, reps);
      <font color=#0000ff>long</font> t2 = System.currentTimeMillis();
      System.out.println(<font color=#004488>": "</font> + (t2 - t1));
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> testArray(<font color=#0000ff>int</font> reps) {
    System.out.println(<font color=#004488>"Testing array as List"</font>);
    <font color=#009900>// Можно выполнить только два первых теста из массива:</font>
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 2; i++) {
      String[] sa = <font color=#0000ff>new</font> String[tests[i].size];
      Arrays2.fill(sa, 
        Collections2.countries.reset());
      List a = Arrays.asList(sa);
      System.out.print(tests[i].name);
      <font color=#0000ff>long</font> t1 = System.currentTimeMillis();
      tests[i].test(a, reps);
      <font color=#0000ff>long</font> t2 = System.currentTimeMillis();
      System.out.println(<font color=#004488>": "</font> + (t2 - t1));
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>int</font> reps = 50000;
    <font color=#009900>// Или выбираем число повторов</font>
    <font color=#009900>// из командной строки:</font>
    <font color=#0000ff>if</font>(args.length &gt; 0)
      reps = Integer.parseInt(args[0]);
    System.out.println(reps + <font color=#004488>" repetitions"</font>);
    testArray(reps);
    test(<font color=#0000ff>new</font> ArrayList(), reps);
    test(<font color=#0000ff>new</font> LinkedList(), reps);
    test(<font color=#0000ff>new</font> Vector(), reps);
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Внутренний класс <b>Tester</b> является абстрактным для 
  обеспечения базового класса специальными тестами. Он содержит <b>String</b> 
  для печать, когда начнется тест, параметр <b>size</b> для использования тестом 
  для определения количества элементов или количества повторов, конструктор для 
  инициализации полей и абстрактный метод <b>test(&#160;)</b>, который выполняет 
  работу. Все различные типы тестов собраны в одном месте, в массиве <b>tests</b>, 
  который инициализируется различными анонимными внутренними классами, наследованными 
  от <b>Tester</b>. Для добавления или удаления тестов просто добавьте или удалите 
  определение внутреннего класса из массива, а все остальное произойдет автоматически.</FONT></P>
<P><FONT FACE="Georgia">Для сравнения доступа к массиву и доступа к контейнеру 
  (первоначально с <b>ArrayList</b>), создан специальный тес для массивов, вложенный 
  в <b>List</b> с помощью <b>Arrays.asList(&#160;)</b>. Обратите внимание, что 
  только первые два теста могут быть выполнены в этом случае, потому что вы не 
  можете вставлять или удалять элементы из массива.</FONT></P>
<p><FONT FACE="Georgia"> <B>List</B>, обрабатываемый <b>test(&#160;)</b>, сначала 
  заполняется элементами, затем пробуется каждый тест из массива <b>tests</b>. 
  Результаты варьируются в зависимости от машины; они предназначены лишь дать 
  сравнительный порядок между производительностями разных контейнеров. Вот сводный 
  результат одного запуска:</FONT></p>
<FONT FACE="Georgia">
<p align="CENTER"> 
  <TABLE BORDER>
    <TR VALIGN="TOP"> 
      <TD><B>Type</B></TD>
      <TD> <B>Get</B></TD>
      <TD> <B>Iteration</B></TD>
      <TD> <B>Insert</B></TD>
      <TD> <B>Remove</B></TD>
    </TR>
    <TR VALIGN="TOP"> 
      <TD> Массив</TD>
      <TD> 1430</TD>
      <TD> 3850</TD>
      <TD> нет</TD>
      <TD>нет</TD>
    </TR>
    <TR VALIGN="TOP"> 
      <TD> <B>ArrayList</B></TD>
      <TD> 3070</TD>
      <TD> 12200</TD>
      <TD> 500</TD>
      <TD> 46850</TD>
    </TR>
    <TR VALIGN="TOP"> 
      <TD> <B>LinkedList</B></TD>
      <TD> 16320 </TD>
      <TD>9110</TD>
      <TD> 110</TD>
      <TD> 60</TD>
    </TR>
    <TR VALIGN="TOP"> 
      <TD> <B>Vector</B></TD>
      <TD> 4890</TD>
      <TD> 16250</TD>
      <TD> 550</TD>
      <TD> 46850</TD>
    </TR>
  </TABLE>
<p></p>
</FONT> 
<p><FONT FACE="Georgia">Как и ожидалось, массивы быстрее контейнеров при доступе 
  в случайном порядке и итерациях. Вы можете видеть, что случайный доступ (<b>get(&#160;)</b>) 
  дешевле для <b>ArrayList</b> и дороже для <b>LinkedList</b>. (Странно, но итерации 
  <i>быстрее</i> для <a name="Index1015"></a><b>LinkedList</b>, чем для <a name="Index1016"></a><b>ArrayList</b>, 
  что немного противоречит интуиции.) С другой стороны, вставка и удаление из 
  середины списка значительно дешевле для <b>LinkedList</b>, чем для <b>ArrayList</b> 
  &#8212; особенно удаление. <a name="Index1017"></a><b>Vector</b> обычно не так 
  быстр, как <b>ArrayList</b>, и его нужно избегать; он остался в библиотеки только 
  по соглашению о поддержке (объяснение того, что он работает в этой программе, 
  в том, что он был адаптирован для <b>List</b> в Java 2). Лучший подход, вероятно, 
  это выбор по умолчанию <b>ArrayList</b> и замена его на <b>LinkedList</b>, если 
  вы обнаружите проблемы производительности при многочисленных вставках и удалениях 
  из середины списка. И Конечно, если вы работаете с группой элементов фиксированного 
  размера, используйте массив.</FONT><A NAME="_Toc481064699"></A></p>
<DIV ALIGN="LEFT"></DIV>
<A NAME="Heading316"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Выбор между множествами (Set)</H3>
</FONT> 
<P><FONT FACE="Georgia">Вы можете выбирать между <a name="Index1018"></a><b>TreeSet 
  </b>и <a name="Index1019"></a><b>HashSet</b>, в зависимости от размера множества 
  <a name="Index1020"></a><b>Set</b> (если вам необходимо производить упорядоченную 
  последовательность из <b>Set</b>, используйте <b>TreeSet</b>). Следующая тестовая 
  программа дает оценить затраты:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"> 
  <PRE><font color=#009900>//: c09:SetPerformance.java</font>
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SetPerformance {
  <font color=#0000ff>private</font> <font color=#0000ff>abstract</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> Tester {
    String name;
    Tester(String name) { <font color=#0000ff>this</font>.name = name; }
    <font color=#0000ff>abstract</font> <font color=#0000ff>void</font> test(Set s, <font color=#0000ff>int</font> size, <font color=#0000ff>int</font> reps);
  }
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Tester[] tests = {
    <font color=#0000ff>new</font> Tester(<font color=#004488>"add"</font>) { 
      <font color=#0000ff>void</font> test(Set s, <font color=#0000ff>int</font> size, <font color=#0000ff>int</font> reps) {
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; reps; i++) {
          s.clear();
          Collections2.fill(s, 
            Collections2.countries.reset(),size);
        }
      }
    },
    <font color=#0000ff>new</font> Tester(<font color=#004488>"contains"</font>) { 
      <font color=#0000ff>void</font> test(Set s, <font color=#0000ff>int</font> size, <font color=#0000ff>int</font> reps) {
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; reps; i++)
          <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; size; j++)
            s.contains(Integer.toString(j));
      }
    },
    <font color=#0000ff>new</font> Tester(<font color=#004488>"iteration"</font>) { 
      <font color=#0000ff>void</font> test(Set s, <font color=#0000ff>int</font> size, <font color=#0000ff>int</font> reps) {
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; reps * 10; i++) {
          Iterator it = s.iterator();
          <font color=#0000ff>while</font>(it.hasNext())
            it.next();
        }
      }
    },
  };
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  test(Set s, <font color=#0000ff>int</font> size, <font color=#0000ff>int</font> reps) {
    System.out.println(<font color=#004488>"Testing "</font> + 
      s.getClass().getName() + <font color=#004488>" size "</font> + size);
    Collections2.fill(s, 
      Collections2.countries.reset(), size);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; tests.length; i++) {
      System.out.print(tests[i].name);
      <font color=#0000ff>long</font> t1 = System.currentTimeMillis();
      tests[i].test(s, size, reps);
      <font color=#0000ff>long</font> t2 = System.currentTimeMillis();
      System.out.println(<font color=#004488>": "</font> + 
        ((<font color=#0000ff>double</font>)(t2 - t1)/(<font color=#0000ff>double</font>)size));
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>int</font> reps = 50000;
    <font color=#009900>// Или выбираем число повторов</font>
    <font color=#009900>// из командной строки:</font>
    <font color=#0000ff>if</font>(args.length &gt; 0)
      reps = Integer.parseInt(args[0]);
    <font color=#009900>// Маленький:</font>
    test(<font color=#0000ff>new</font> TreeSet(), 10, reps);
    test(<font color=#0000ff>new</font> HashSet(), 10, reps);
    <font color=#009900>// Средний:</font>
    test(<font color=#0000ff>new</font> TreeSet(), 100, reps);
    test(<font color=#0000ff>new</font> HashSet(), 100, reps);
    <font color=#009900>// Большой:</font>
    test(<font color=#0000ff>new</font> TreeSet(), 1000, reps);
    test(<font color=#0000ff>new</font> HashSet(), 1000, reps);
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Следующая таблица показывает результаты одного запуска. 
  (Конечно они будут различаться в зависимости от компьютера и используемой JVM; 
  вы должны запустить тест сами):</FONT></P>
<p align="center"> <FONT FACE="Georgia"> 
  <TABLE BORDER>
    <TR VALIGN="TOP"> 
      <TD> <B>Тип</B></TD>
      <TD> <B>Тестовый размер</B></TD>
      <TD><B>Добавление</B></TD>
      <TD> <B>Содержится</B></TD>
      <TD><B>Итерации</B></TD>
    </TR>
    <TR VALIGN="TOP"> 
      <TD>&nbsp; </TD>
      <TD> 10</TD>
      <TD> 138.0 </TD>
      <TD> 115.0</TD>
      <TD> 187.0</TD>
    </TR>
    <TR VALIGN="TOP"> 
      <TD> <B>TreeSet</B> </TD>
      <TD> 100</TD>
      <TD> 189.5 </TD>
      <TD> 151.1</TD>
      <TD> 206.5</TD>
    </TR>
    <TR VALIGN="TOP"> 
      <TD>&nbsp; </TD>
      <TD> 1000</TD>
      <TD> 150.6 </TD>
      <TD> 177.4</TD>
      <TD> 40.04</TD>
    </TR>
    <TR VALIGN="TOP"> 
      <TD>&nbsp; </TD>
      <TD> 10</TD>
      <TD> 55.0</TD>
      <TD> 82.0</TD>
      <TD> 192.0</TD>
    </TR>
    <TR VALIGN="TOP"> 
      <TD> <B>HashSet</B> </TD>
      <TD>100</TD>
      <TD> 45.6</TD>
      <TD> 90.0</TD>
      <TD> 202.2</TD>
    </TR>
    <TR VALIGN="TOP"> 
      <TD>&nbsp; </TD>
      <TD> 1000</TD>
      <TD> 36.14</TD>
      <TD> 106.5</TD>
      <TD> 39.39</TD>
    </TR>
  </TABLE>
  </FONT><p></p>
<P><FONT FACE="Georgia">Производительность <b>HashSet</b> значительно отличается 
  от <b>TreeSet</b> для всех операций (но обычно при добавлении и поиске, это 
  две наиболее важные операции). Причина использования <b>TreeSet</b> в том, что 
  он содержит се содержимое упорядоченным, так что используйте его только если 
  вам нужно отсортированное множество.</FONT><A NAME="_Toc481064700"></A></P>
<A NAME="Heading317"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Выбор между картами (Map)</H3>
</FONT> 
<P><FONT FACE="Georgia">Когда выбираете между реализациями <a name="Index1021"></a><b>Map</b>, 
  размер <b>Map</b> - это то, что сильно влияет на производительность и приведенная 
  ниже программа показывает необходимые затраты:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"> 
  <PRE><font color=#009900>//: c09:MapPerformance.java</font>
<font color=#009900>// Демонстрация различий в производительности для Maps.</font>
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> MapPerformance {
  <font color=#0000ff>private</font> <font color=#0000ff>abstract</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> Tester {
    String name;
    Tester(String name) { <font color=#0000ff>this</font>.name = name; }
    <font color=#0000ff>abstract</font> <font color=#0000ff>void</font> test(Map m, <font color=#0000ff>int</font> size, <font color=#0000ff>int</font> reps);
  }
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Tester[] tests = {
    <font color=#0000ff>new</font> Tester(<font color=#004488>"put"</font>) { 
      <font color=#0000ff>void</font> test(Map m, <font color=#0000ff>int</font> size, <font color=#0000ff>int</font> reps) {
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; reps; i++) {
          m.clear();
          Collections2.fill(m, 
            Collections2.geography.reset(), size);
        }
      }
    },
    <font color=#0000ff>new</font> Tester(<font color=#004488>"get"</font>) { 
      <font color=#0000ff>void</font> test(Map m, <font color=#0000ff>int</font> size, <font color=#0000ff>int</font> reps) {
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; reps; i++)
          <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; size; j++)
            m.get(Integer.toString(j));
      }
    },
    <font color=#0000ff>new</font> Tester(<font color=#004488>"iteration"</font>) { 
      <font color=#0000ff>void</font> test(Map m, <font color=#0000ff>int</font> size, <font color=#0000ff>int</font> reps) {
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; reps * 10; i++) {
          Iterator it = m.entrySet().iterator();
          <font color=#0000ff>while</font>(it.hasNext())
            it.next();
        }
      }
    },
  };
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  test(Map m, <font color=#0000ff>int</font> size, <font color=#0000ff>int</font> reps) {
    System.out.println(<font color=#004488>"Testing "</font> + 
      m.getClass().getName() + <font color=#004488>" size "</font> + size);
    Collections2.fill(m, 
      Collections2.geography.reset(), size);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; tests.length; i++) {
      System.out.print(tests[i].name);
      <font color=#0000ff>long</font> t1 = System.currentTimeMillis();
      tests[i].test(m, size, reps);
      <font color=#0000ff>long</font> t2 = System.currentTimeMillis();
      System.out.println(<font color=#004488>": "</font> + 
        ((<font color=#0000ff>double</font>)(t2 - t1)/(<font color=#0000ff>double</font>)size));
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>int</font> reps = 50000;
    <font color=#009900>// Или выбираем число повторов</font>
    <font color=#009900>// из командной строки:</font>
    <font color=#0000ff>if</font>(args.length &gt; 0)
      reps = Integer.parseInt(args[0]);
    <font color=#009900>// Маленький:</font>
    test(<font color=#0000ff>new</font> TreeMap(), 10, reps);
    test(<font color=#0000ff>new</font> HashMap(), 10, reps);
    test(<font color=#0000ff>new</font> Hashtable(), 10, reps);
    <font color=#009900>// Средний:</font>
    test(<font color=#0000ff>new</font> TreeMap(), 100, reps);
    test(<font color=#0000ff>new</font> HashMap(), 100, reps);
    test(<font color=#0000ff>new</font> Hashtable(), 100, reps);
    <font color=#009900>// Большой:</font>
    test(<font color=#0000ff>new</font> TreeMap(), 1000, reps);
    test(<font color=#0000ff>new</font> HashMap(), 1000, reps);
    test(<font color=#0000ff>new</font> Hashtable(), 1000, reps);
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Потому что размер карты является критичным, вы увидите, 
  что время тестов, деленное на размер, нормализует каждое измерение. Здесь приведено 
  множество результатов. (Ваши пробы будут отличаться.)</FONT></P>
<p align="CENTER"> <FONT FACE="Georgia"> 
  <TABLE BORDER>
    <TR VALIGN="TOP"> 
      <TH WIDTH=76 COLSPAN=1 ROWSPAN=1 VALIGN="TOP"> <B>Тип</B></TH>
      <TH WIDTH=45 COLSPAN=1 ROWSPAN=1 VALIGN="TOP"> <B>Тестовый размер</B> </TH>
      <TH WIDTH=45 COLSPAN=1 ROWSPAN=1 VALIGN="TOP"> <B>Put</B></TH>
      <TH WIDTH=53 COLSPAN=1 ROWSPAN=1 VALIGN="TOP"> <B>Get</B></TH>
      <TH WIDTH=72 COLSPAN=1 ROWSPAN=1 VALIGN="TOP"> <B>Iteration</B></TH>
    </TR>
    <TR VALIGN="TOP"> 
      <TD>&nbsp; </TD>
      <TD> 10</TD>
      <TD> 143.0</TD>
      <TD> 110.0</TD>
      <TD> 186.0</TD>
    </TR>
    <TR VALIGN="TOP"> 
      <TD> <B>TreeMap</B></TD>
      <TD> 100</TD>
      <TD> 201.1</TD>
      <TD> 188.4</TD>
      <TD> 280.1</TD>
    </TR>
    <TR VALIGN="TOP"> 
      <TD>&nbsp; </TD>
      <TD> 1000</TD>
      <TD> 222.8</TD>
      <TD> 205.2</TD>
      <TD> 40.7</TD>
    </TR>
    <TR VALIGN="TOP"> 
      <TD>&nbsp; </TD>
      <TD> 10</TD>
      <TD> 66.0</TD>
      <TD> 83.0</TD>
      <TD> 197.0</TD>
    </TR>
    <TR VALIGN="TOP"> 
      <TD> <B>HashMap</B></TD>
      <TD> 100</TD>
      <TD> 80.7</TD>
      <TD> 135.7</TD>
      <TD> 278.5</TD>
    </TR>
    <TR VALIGN="TOP"> 
      <TD>&nbsp; </TD>
      <TD> 1000</TD>
      <TD> 48.2</TD>
      <TD> 105.7</TD>
      <TD> 41.4</TD>
    </TR>
    <TR VALIGN="TOP"> 
      <TD>&nbsp; </TD>
      <TD> 10</TD>
      <TD> 61.0</TD>
      <TD> 93.0</TD>
      <TD> 302.0</TD>
    </TR>
    <TR VALIGN="TOP"> 
      <TD> <B>Hashtable</B></TD>
      <TD> 100</TD>
      <TD> 90.6</TD>
      <TD> 143.3</TD>
      <TD> 329.0</TD>
    </TR>
    <TR VALIGN="TOP"> 
      <TD>&nbsp; </TD>
      <TD> 1000</TD>
      <TD> 54.1</TD>
      <TD> 110.95</TD>
      <TD> 47.3</TD>
    </TR>
  </TABLE>
  </FONT><p></p>
<p align="left"><FONT FACE="Georgia">Как вы можете ожидать, производительность 
  <a name="Index1022"></a><b>Hashtable</b> примерно равна производительности <b>HashMap</b>. 
  (Вы так же можете заметить, что <b>HashMap</b> в общем немного быстрее. <b>HashMap</b> 
  предназначена заменить <b>Hashtable</b>.) <a name="Index1023"></a><b>TreeMap 
  </b>обычно медленнее, чем <b>HashMap</b>, так почему же вы должны использовать 
  ее? Так как вы можете использовать ее не как <b>Map</b>, а как способ создания 
  упорядоченного списка. Поведение дерева такое, что оно всегда упорядочено и 
  не требует специального упорядочивания. Как только вы заполните <b>TreeMap</b>, 
  вы можете вызвать <a name="Index1024"></a><b>keySet(&#160;)</b>, чтобы получить 
  <b>Set</b> представление ключей, а затем <a name="Index1025"></a><b>toArray(&#160;)</b> 
  для производства массива этих ключей. Затем вы можете использовать статический 
  метод <b>Arrays.binarySearch(&#160;)</b> (будет обсужден позже) для повторного 
  поиска объектов в вашем сохраненном массиве. Конечно, вам, вероятно, нужно будет 
  делать это, если, по каким-то причинам, поведение <b>HashMap</b> будет неприемлемым, 
  так как <b>HashMap </b>предназначена для повторного поиска вещей. Так же вы 
  можете легко создать <b>HashMap </b>из <b>TreeMap</b> путем создания единственного 
  объекта. В конце концов, при использовании <b>Map</b>, вашим первым выбором 
  должен быть класс <b>HashMap</b>, и только если вам нужно постоянно упорядоченная 
  <b>Map</b>, вам нужен </FONT><FONT FACE="Georgia"> <B>TreeMap</B>.</FONT><A NAME="_Toc481064701"></A></p>
<DIV ALIGN="LEFT"></DIV>
<A NAME="Heading318"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Сортировка и поиск в списках<A NAME="Index1026"></A><A NAME="Index1027"></A></H2>
</FONT> 
<P><FONT FACE="Georgia">Утилиты для выполнения сортировки и поиска для списков 
  (<a name="Index1028"></a><b>List</b>) имеют те же имена и сигнатуры, что и для 
  отсортированных массивов, но это статические методы класса <a name="Index1029"></a><b>Collections</b>, 
  а не <b>Arrays</b>. Вот пример, модифицированный из <b>ArraySearching.java</b>:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:ListSortSearch.java</font>
<font color=#009900>// Сортировка и поиск в списках с помощью 'Collections'.</font>
<font color=#0000ff>import</font> com.bruceeckel.util.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ListSortSearch {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    List list = <font color=#0000ff>new</font> ArrayList();
    Collections2.fill(list, 
      Collections2.capitals, 25);
    System.out.println(list + <font color=#004488>"\n"</font>);
    Collections.shuffle(list);
    System.out.println(<font color=#004488>"After shuffling: "</font>+list);
    Collections.sort(list);
    System.out.println(list + <font color=#004488>"\n"</font>);
    Object key = list.get(12);
    <font color=#0000ff>int</font> index = 
      Collections.binarySearch(list, key);
    System.out.println(<font color=#004488>"Location of "</font> + key + 
      <font color=#004488>" is "</font> + index + <font color=#004488>", list.get("</font> + 
      index + <font color=#004488>") = "</font> + list.get(index));
    AlphabeticComparator comp =
      <font color=#0000ff>new</font> AlphabeticComparator();
    Collections.sort(list, comp);
    System.out.println(list + <font color=#004488>"\n"</font>);
    key = list.get(12);
    index = 
      Collections.binarySearch(list, key, comp);
    System.out.println(<font color=#004488>"Location of "</font> + key + 
      <font color=#004488>" is "</font> + index + <font color=#004488>", list.get("</font> + 
      index + <font color=#004488>") = "</font> + list.get(index));
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Использование этих методов идентично соответствующим методам 
  класса <b>Arrays</b>, но вместо массива вы используете <b>List</b>. Точно так 
  же, как и в случае сортировки и поиска для массивов, если вы сортируете с помощью 
  <b>Comparator</b>, вы должны использовать <b>binarySearch(&#160;)</b>, используя 
  тот же самый <b>Comparator</b>.</FONT></P>
<P><FONT FACE="Georgia">Эта программа также демонстрирует метод <a name="Index1030"></a><b>shuffle(&#160;)</b> 
  класса <b>Collections</b>, который смешивает порядок в </FONT><FONT FACE="Georgia"><B>List</B>.</FONT><A NAME="_Toc481064702"></A></P>
<A NAME="Heading319"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Утилиты</H2>
</FONT> 
<P><FONT FACE="Georgia">Есть несколько других полезных утилит в классе <B>Collections</B>:<A NAME="Index1031"></A><A NAME="Index1032"></A></FONT></P>
<TABLE BORDER width="100%">
  <TR VALIGN="TOP"> 
    <TD width="27%"> <FONT FACE="Georgia"><B>enumeration(Collection)</B></FONT></TD>
    <TD width="73%"> Производит <B>Enumeration</B> старого стиля для аргумента.</TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD width="27%"> 
      <p><B>max(Collection)</B></p>
      <p> <B>min(Collection)</B></p>
    </TD>
    <TD width="73%"> Производит максимальный или минимальный элемент для аргумента, 
      используя естественный метод сравнения для объектов <B>Collection</B>.</TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD width="27%"> 
      <P><B>max(Collection, Comparator)</B></P>
      <P><B>min(Collection, Comparator)</B></P>
      </TD>
    <TD width="73%"> Производит максимальный или минимальный элемент <B>Collection</B>, 
      используя <B>Comparator</B>.</TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD width="27%"> <B>reverse(&#160;)</B></TD>
    <TD width="73%"> Переворачивает все элементы на местах.</TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD width="27%"> <B>copy(List dest, List src)</B></TD>
    <TD width="73%"> Копирует элементы из src в dest.</TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD width="27%"> <B>fill(List list, Object o)</B></TD>
    <TD width="73%"> Заменяет все элементы списка на o.</TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD width="27%"> <B>nCopies(int n, Object o) </B></TD>
    <TD width="73%"> Возвращает неизменный <B>List</B> размера n, чьи ссылки будут 
      указывать o.</TD>
  </TR>
</TABLE>
<p></P>
<DIV ALIGN="LEFT"> 
  <P><FONT FACE="Georgia">Обратите внимание, что <b>min(&#160;)</b> и <b>max(&#160;)</b> 
    работают с объектами <b>Collection</b>, а не с <b>List</b>, так что вам нет 
    необходимости беспокоится о том, отсортирован <b>Collection</b> или нет. (Как 
    упоминалось ранее, вам не нужно вызывать <b>sort(&#160;)</b> для <b>List</b> 
    или для массива перед вызовом </FONT><FONT FACE="Georgia"> <B>binarySearch(&#160;)</B>.)</FONT><A NAME="_Toc481064703"></A></P>
</DIV>
<A NAME="Heading320"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Как сделать Collection или Map неизменяемой<A NAME="Index1033"></A></H3>
</FONT> 
<P><FONT FACE="Georgia">Часто необходимо создавать версию только для чтения <b>Collection</b> 
  или <b>Map</b>. Класс <b>Collections</b> позволяет вам сделать это, передав 
  оригинальный контейнер в метод, который вернет версию только для чтения. Есть 
  четыре варианта этого метода, каждый них для <b>Collection </b>(если вы не хотите 
  трактовать <b>Collection</b>, как более специфический тип), <b>List</b>, <b>Set</b> 
  и <b>Map</b>. Этот пример показывает правильный способ построения версии только 
  для чтения для каждого класса:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"> 
  <PRE><font color=#009900>//: c09:ReadOnly.java</font>
<font color=#009900>// Использование методов Collections.unmodifiable.</font>
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ReadOnly {
  <font color=#0000ff>static</font> Collections2.StringGenerator gen = 
    Collections2.countries;
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Collection c = <font color=#0000ff>new</font> ArrayList();
    Collections2.fill(c, gen, 25); <font color=#009900>// Вставление данных</font>
    c = Collections.unmodifiableCollection(c);
    System.out.println(c); <font color=#009900>// Чтение закончилось удачно</font>
    c.add(<font color=#004488>"one"</font>); <font color=#009900>// Не могу изменить это</font>
    
    List a = <font color=#0000ff>new</font> ArrayList();
    Collections2.fill(a, gen.reset(), 25);
    a = Collections.unmodifiableList(a);
    ListIterator lit = a.listIterator();
    System.out.println(lit.next()); <font color=#009900>// </font><font color=#009900>Чтение закончилось удачно</font>
    lit.add(<font color=#004488>"one"</font>); <font color=#009900>// Не могу изменить это</font>

    Set s = <font color=#0000ff>new</font> HashSet();
    Collections2.fill(s, gen.reset(), 25);
    s = Collections.unmodifiableSet(s);
    System.out.println(s); <font color=#009900>// </font><font color=#009900>Чтение закончилось удачно</font>
    <font color=#009900>//! s.add("one"); // </font><font color=#009900>Не могу изменить это</font>
    
    Map m = <font color=#0000ff>new</font> HashMap();
    Collections2.fill(m,
      Collections2.geography, 25);
    m = Collections.unmodifiableMap(m);
    System.out.println(m); <font color=#009900>// </font><font color=#009900>Чтение закончилось удачно</font>
    <font color=#009900>//! m.put("Ralph", "Howdy!");</font>
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">В каждом случае вы должны заполнить контейнер значимыми 
  данными <i>прежде</i>, чем будете делать его только для чтения. Как только он 
  будет загружен, лучший подход состоит в замене существующей ссылки на ссылку, 
  произведенную вызовом метода, запрещающим изменения. Это способ позволяет вам 
  избежать риска случайного изменения, так как вы делаете контейнер не изменяемым. 
  С другой стороны, этот инструмент также позволяет вам сделать ваш неизменяемый 
  контейнер, как <b>private</b> внутри класса и возвращать ссылку только для чтения 
  на этот контейнер из вызова метода. Так что вы можете менять его внутри класса, 
  но все остальные смогут только читать его.</FONT></P>
<P><FONT FACE="Georgia">Вызов &#8220;неизменяемого&#8221; метода для определенного 
  типа не является причиной проверки во время компиляции, но как только будет 
  вызвана трансформация, то любой вызов метода, изменяющегося содержимое определенного 
  контейнера, станет причиной возникновения </FONT><FONT FACE="Georgia"> <B>UnsupportedOperationException</B>.</FONT><A NAME="_Toc481064704"></A></P>
<A NAME="Heading321"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Синхронизация Collection или Map</H3>
</FONT> 
<P><FONT FACE="Georgia">Ключевое слово <A NAME="Index1034"></A><B>synchronized</B> 
  - это важная часть для темы <a name="Index1035"></a>многопотчности - это более 
  сложная тема, которая не обсуждается до <a href="Chapter14.html">Главы 14</a>. 
  Здесь я буду уделять внимание только классу <b>Collections</b>, который содержит 
  способ автоматической синхронизации всего контейнера. Синтаксис похож на &#8220;не 
  изменяемый&#8221; метод:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:Synchronization.java</font>
<font color=#009900>// Использование метода Collections.synchronized.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Synchronization {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Collection c = 
      Collections.synchronizedCollection(
        <font color=#0000ff>new</font> ArrayList());
    List list = Collections.synchronizedList(
      <font color=#0000ff>new</font> ArrayList());
    Set s = Collections.synchronizedSet(
      <font color=#0000ff>new</font> HashSet());
    Map m = Collections.synchronizedMap(
      <font color=#0000ff>new</font> HashMap());
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">В этом случае вы немедленно передаете новый контейнер 
  через соответствующий &#8220;синхронизирующий&#8221; метод; этот способ не дает 
  шансов случайному выставлению не синхронизированной версии.</FONT></P>
<A NAME="Heading322"></A><FONT FACE = "Verdana">
<H4 ALIGN="LEFT"> Провалившееся ускорение<A NAME="Index1036"></A><A NAME="Index1037"></A></H4>
</FONT> 
<P><FONT FACE="Georgia">Контейнеры Java также имеют механизм, предотвращающий 
  возникновение более одного процесса для изменения содержимого контейнера. Эта 
  проблема возникает, если вы используете итерации контейнера в некоторых других 
  процессах для прохода, вставки, удаления или изменения объектов контейнера. 
  Возможно, вы уже прошли тот объект, возможно, он перед вами, возможно размер 
  контейнера сократился после того, как вы вызвали <b>size(&#160;)</b> &#8212; 
  есть много способов для бедствия. Библиотека контейнеров Java разработала механизм 
  провала ускорения, который следит за изменениями контейнера, происходящие в 
  более чем одном процессе. Если определяется, что кто-то еще изменяет контейнер, 
  немедленно возникает <b>ConcurrentModificationException</b>. Это аспект &#8220;провала 
  ускорения&#8221;, означающий, что не нужно пробовать определять проблему или 
  использовать более сложный алгоритм.</FONT></P>
<P><FONT FACE="Georgia">Достаточно просто увидеть работу механизма провала ускорения 
  &#8212; все, что вам нужно сделать, это создать итератор, а затем добавить кое-что 
  к коллекции, на которую указывает итератор, как в этом примере:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:FailFast.java</font>
<font color=#009900>// Демонстрация поведения "проваливания ускорения".</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> FailFast {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Collection c = <font color=#0000ff>new</font> ArrayList();
    Iterator it = c.iterator();
    c.add(<font color=#004488>"An object"</font>);
    <font color=#009900>// Причина исключения:</font>
    String s = (String)it.next();
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Исключение возникает из-за того, что что-то помещается 
  в контейнер <i>после</i> того, как итератор запрошен из контейнера. Возможность 
  того, что две части программы могут модифицировать один и тот же контейнер, 
  производит нежелательное состояние, так что исключение предупреждает вас, что 
  вы должны изменить ваш код &#8212; в этом случае, запрашивайте итератор <i>после</i> 
  того, как добавите все элементы в контейнер.</FONT></P>
<P><FONT FACE="Georgia">Обратите, что вы не можете извлечь пользу из этого рода 
  слежения, когда вы получаете доступ к элементам <b>List</b>, используя </FONT><FONT FACE="Georgia"><B>get(&#160;)</B>.</FONT><A NAME="_Toc481064705"></A></P>
<DIV ALIGN="LEFT"></DIV>
<A NAME="Heading323"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Неподдерживаемые операции<A NAME="Index1038"></A><A NAME="Index1039"></A><A NAME="Index1040"></A></H2>
</FONT>
<P><FONT FACE="Georgia">Есть возможность включить массив в <B>List</B> с помощью 
  метода <B>Arrays.asList(&#160;)</B>:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"> 
  <PRE><font color=#009900>//: c09:Unsupported.java</font>
<font color=#009900>// Иногда метод, определенный в</font>
<font color=#009900>// интерфейсе Collection не работает!</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Unsupported {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> String[] s = {
    <font color=#004488>"one"</font>, <font color=#004488>"two"</font>, <font color=#004488>"three"</font>, <font color=#004488>"four"</font>, <font color=#004488>"five"</font>,
    <font color=#004488>"six"</font>, <font color=#004488>"seven"</font>, <font color=#004488>"eight"</font>, <font color=#004488>"nine"</font>, <font color=#004488>"ten"</font>,
  };
  <font color=#0000ff>static</font> List a = Arrays.asList(s);
  <font color=#0000ff>static</font> List a2 = a.subList(3, 6);
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    System.out.println(a);
    System.out.println(a2);
    System.out.println(
      <font color=#004488>"a.contains("</font> + s[0] + <font color=#004488>") = "</font> + 
      a.contains(s[0]));
    System.out.println(
      <font color=#004488>"a.containsAll(a2) = "</font> + 
      a.containsAll(a2));
    System.out.println(<font color=#004488>"a.isEmpty() = "</font> +
      a.isEmpty());
    System.out.println(
      <font color=#004488>"a.indexOf("</font> + s[5] + <font color=#004488>") = "</font> + 
      a.indexOf(s[5]));
    <font color=#009900>// Проход в обратном порядке:</font>
    ListIterator lit = a.listIterator(a.size());
    <font color=#0000ff>while</font>(lit.hasPrevious())
      System.out.print(lit.previous() + <font color=#004488>" "</font>);
    System.out.println();
    <font color=#009900>// Установка другого значения элемента:</font>
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; a.size(); i++)
      a.set(i, <font color=#004488>"47"</font>);
    System.out.println(a);
    <font color=#009900>// Компилируется, но не работает:</font>
    lit.add(<font color=#004488>"X"</font>); <font color=#009900>// Неподдерживаемая операция</font>
    a.clear(); <font color=#009900>// Не поддерживается</font>
    a.add(<font color=#004488>"eleven"</font>); <font color=#009900>// Не поддерживается</font>
    a.addAll(a2); <font color=#009900>// Не поддерживается</font>
    a.retainAll(a2); <font color=#009900>// Не поддерживается</font>
    a.remove(s[0]); <font color=#009900>// Не поддерживается</font>
    a.removeAll(a2); <font color=#009900>// Не поддерживается</font>
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Вы обнаружите, что реализована только часть интерфейсов 
  <b>Collection</b> и <b>List</b>. Оставшиеся методы являются причиной нежелательного 
  появления того, что называется <b>UnsupportedOperationException</b>. Вы выучите 
  все об исключениях в следующей главе, но если сказать коротко, то <b>Collection</b> 
  <b>interface</b> &#8212; как и многие интерфейсы в библиотеки контейнеров Java 
  &#8212; содержит &#8220;необязательные&#8221; методы, которые могут поддерживаться, 
  но могут и не поддерживаться классом контейнера, который реализует такой интерфейс. 
  Вызов неподдерживаемого метода является причиной <b>UnsupportedOperationException</b>, 
  указывающий ошибку программы.</FONT></P>
<P><FONT FACE="Georgia">&#8220;Что?!?&#8221; - скажете вы, удивленно. - &#8220;Все 
  обещанные методы интерфейсов и базовых классов, делают что-либо полезное! Это 
  нарушает обещание &#8212; это говорит о том, что вызов некоторых методов не 
  только <i>не обеспечит</i> значимое поведение, но и остановит программу! Безопасный 
  текст просто выбросит из окна!&#8221;</FONT></P>
<P><FONT FACE="Georgia">Это не совсем плохо. При использовании <b>Collection</b>, 
  <b>List</b>, <b>Set</b> или <b>Map</b>, компилятор все еще ограничивает вас 
  в вызове методов только этого интерфейса, так как это не как в Smalltalk (в 
  котором вы можете вызвать метод для любого объекта и выйти за пределы только 
  если вы запускаете программу, в которой ваш вызов ничего не значит). Кроме того, 
  большинство методов, принимающий <b>Collection</b> в качестве аргумента только 
  читают из <b>Collection </b>&#8212; все методы &#8220;чтения&#8221; для <b>Collection 
  </b><i>не являются</i> не обязательными.</FONT></P>
<P><FONT FACE="Georgia">Этот подход предотвращает крушение интерфейсов при разработке. 
  Другие дизайны для библиотеки контейнеров всегда заканчивают запутывающим числом 
  интерфейсов, описывающих каждый вариант главной темы, и становятся сложными 
  в изучении. Даже невозможно собрать все возможные особые случаи для интерфейсов, 
  потому что кто-то может всегда инвертировать новый интерфейс. Подход &#8220;неподдерживаемого 
  действия&#8221; позволяет достигнуть важной цели библиотеки контейнеров Java: 
  контейнеры просты в изучении; не поддерживаемые операции - особый случай, который 
  может быть выучен позднее. Однако, для этого подхода работает:</FONT></P>
<OL>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia"> <B>UnsupportedOperationException</B> 
    должно быть редким событием. То есть, для большинства классов все операции 
    будут работать, только в редких случаях операции будут не поддерживаемыми. 
    Это так для библиотеки контейнеров Java, так как 99% используемых вами классов 
    &#8212; это <b>ArrayList</b>, <b>LinkedList</b>, <b>HashSet</b> и <b>HashMap</b> 
    и их конкретные реализации &#8212; поддерживают все операции. Дизайн не поддерживает 
    &#8220;черный ход&#8221;, если вы захотите создать новый <b>Collection</b>, 
    без обеспечения значимых определений для всех методов <b>Collection</b> <b>interface</b>, 
    и после этого добавите его к существующей библиотеке.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Когда операция является 
    не поддерживаемой, должна быть определенная вероятность появления <b>UnsupportedOperationException</b> 
    во время реализации, даже после того, как вы продадите продукт покупателю. 
    Кроме всего прочего, оно указывает на ошибку программы: вы используете реализацию 
    неправильно. Такое случается достаточно редко в тех местах где экстремальная 
    природа вступает в силу. Только через какое-то время мы выясним, как хорошо 
    это работает.</FONT>
</OL>
<P><FONT FACE="Georgia">В приведенном выше примере <a name="Index1041"></a><b>Arrays.asList(&#160;)</b> 
  производит <b>List</b>, который основывается на массиве фиксированного размера. 
  Поэтому, тут имеется в виду, что поддерживаются операции, которые не изменяют 
  размер массива. С другой стороны, если новый интерфейс будет требовать выражения 
  поведения другого рода (возможно, называемого &#8220;<b>FixedSizeList</b>&#8221;), 
  это откроет дорогу сложности и вскоре вы не будете знать откуда начинать использовать 
  библиотеку.</FONT></P>
<P><FONT FACE="Georgia">Документация для метода, получающего <b>Collection</b>, 
  <b>List</b>, <b>Set</b> или <b>Map</b> в качестве аргумента, должна указывать 
  какие дополнительные методы должны быть реализованы. Например, сортировка требует 
  методов <b>set(&#160;)</b> и <b>Iterator.set(&#160;),</b> но не требует </FONT><FONT FACE="Georgia"> 
  <B>add(&#160;)</B> и <B>remove(&#160;)</B>. </FONT><A NAME="_Toc481064706">.</A></P>
<DIV ALIGN="LEFT"></DIV>
<A NAME="Heading324"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Контейнеры Java 1.0/1.1</H2>
</FONT> 
<P><FONT FACE="Georgia">К сожалению, большинство кода было написано с использованием 
  контейнеров Java 1.0/1.1 и каждый новый код иногда пишется с использованием 
  этих классов. Так что, хотя вы не должны использовать старые контейнеры при 
  написании нового кода, вам все равно нужно знать о нем. Однако старые контейнеры 
  были достаточно ограничены, так что о них можно сказать не много. (Так как они 
  уже в прошлом, я попробую удержаться от чрезмерного подчеркивания некоторых 
  отвратительных черт дизайна.)</FONT><A NAME="_Toc375545355"></A><A NAME="_Toc481064707"></A></P>
<A NAME="Heading325"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Vector и Enumeration</H3>
</FONT> 
<P><FONT FACE="Georgia">Единственной саморасширяющейся последовательность в Java 
  1.0/1.1 был <a name="Index1042"></a><b>Vector</b>, и поэтому он часто использовался. 
  Его недостатки слишком многочисленны, чтобы описывать их здесь (смотрите первую 
  редакцию этой книги, доступной на CD ROM, прилагаемый к этой книге, и свободно 
  доступную на <i>ww.BruceEckel.com</i>). В основном, вы можете думать о нем, 
  как о <b>ArrayList</b> с длинными, неудобными именами методов. В библиотеке 
  контейнеров Java 2 <b>Vector</b> был адаптирован так, что он может соответствовать 
  <b>Collection </b>и <b>List</b>, так что в приведенном примере метод <b>Collections2.fill(&#160;)</b> 
  может успешно использоваться. Это оказалось немного извращенно, так как многие 
  люди могут быть сконфужены, думая о <b>Vector</b> лучше, в то время, когда он 
  включает только поддержку кода, предыдущего для Java 2.</FONT></P>
<P><FONT FACE="Georgia">Версия Java 1.0/1.1 итератора выбрала новое имя - &#8220;enumeration&#8221;, 
  вместо использования хорошо всем знакомого термина. Интерфейс <a name="Index1043"></a><b>Enumeration</b> 
  меньше, чем <b>Iterator</b>, он имеет только два метода и использует длинные 
  имена методов: <b>boolean</b> <b>hasMoreElements(&#160;)</b> выдающий <b>true</b>, 
  если это перечисление содержит еще элементы, и <b>Object nextElement(&#160;),</b> 
  возвращающий следующий элемент этого перечисления, если он есть (в противном 
  случае выбрасывается исключение).</FONT></P>
<P><FONT FACE="Georgia"><B>Enumeration</B> - это только интерфейс, а не реализация, 
  и даже новые библиотеки все еще используют старый <b>Enumeration</b> &#8212; 
  что очень жалко, но безвредно. Несмотря на то, что в вашем новом коде вам всегда 
  нужно использовать <b>Iterator</b>, если вы можете, вы должны быть готовы, что 
  нужные вам библиотеки используют <b>Enumeration</b>.</FONT></P>
<DIV ALIGN="LEFT"></DIV>
<P><A NAME="Index1044"></A><FONT FACE="Georgia">кроме того, вы можете производить 
  <b>Enumeration</b> для любого <b>Collection</b>, используя метод <b>Collections.enumeration(&#160;)</b>, 
  как показано в этом примере:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:Enumerations.java</font>
<font color=#009900>// Java 1.0/1.1 Vector и Enumeration.</font>
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>class</font> Enumerations {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Vector v = <font color=#0000ff>new</font> Vector();
    Collections2.fill(
      v, Collections2.countries, 100);
    Enumeration e = v.elements();
    <font color=#0000ff>while</font>(e.hasMoreElements())
      System.out.println(e.nextElement());
    <font color=#009900>// Производит Enumeration для Collection:</font>
    e = Collections.enumeration(<font color=#0000ff>new</font> ArrayList());
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia"> Java 1.0/1.1 <B>Vector</B> имеет только метод <b>addElement(&#160;)</b>, 
  но <b>fill(&#160;)</b> использует метод <b>add(&#160;)</b>, который был введен 
  в <b>Vector</b> после перехода к <b>List</b>. Для получения <b>Enumeration</b>, 
  вы вызываете <b>elements(&#160;)</b>, а затем используете его для выполнения 
  прямого прохода.</FONT></P>
<P><FONT FACE="Georgia">Последняя строка создает <b>ArrayList</b> и использует 
  <b>enumeration(&#160;)</b> tдля приспосабливания <b>Enumeration</b> для <b>ArrayList</b> 
  <b>Iterator</b>. Таким образом, если вы имеете старый код, которому нужен <b>Enumeration</b>, 
  вы все равно можете использовать новые контейнеры.</FONT><A NAME="_Toc481064708"></A></P>
<DIV ALIGN="LEFT"></DIV>
<A NAME="Heading326"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Hashtable</H3>
</FONT> 
<P><FONT FACE="Georgia">Как вы видели сравнение производительности в этой главе, 
  основной <a name="Index1045"></a><b>Hashtable</b> очень похож на <b>HashMap</b>, 
  даже по именам методов. Нет причин использовать <b>Hashtable</b> вместо <b>HashMap</b> 
  в новом коде.</FONT><A NAME="_Toc375545356"></A><A NAME="_Toc481064709"></A></P>
<A NAME="Heading327"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Stack</H3>
</FONT> 
<P><FONT FACE="Georgia">Концепция стека была введена ранее с классом <b>LinkedList</b>.<b> 
  </b>Что является довольно странным для <b>Stack</b> из Java 1.0/1.1, это то, 
  что вместо использования <a name="Index1046"></a><b>Vector</b> в качестве основы, 
  <a name="Index1047"></a><b>Stack </b><i>наследуется</i> от <b>Vector</b>. Так 
  что он имеет все характеристики и поведение, свойственное для <b>Vector</b>, 
  плюс несколько дополнительных свойств <b>Stack</b>. Трудно понять: решили ли 
  разработчики, что это будет очень полезный способ создания вещей, или это просто 
  был наивный дизайн.</FONT></P>
<P><FONT FACE="Georgia">Здесь приведена простая демонстрация для <B>Stack</B>, 
  которая помещает строки из массива <B>String</B>:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:Stacks.java</font>
<font color=#009900>// Демонстрация класса Stack.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Stacks {
  <font color=#0000ff>static</font> String[] months = { 
    <font color=#004488>"January"</font>, <font color=#004488>"February"</font>, <font color=#004488>"March"</font>, <font color=#004488>"April"</font>,
    <font color=#004488>"May"</font>, <font color=#004488>"June"</font>, <font color=#004488>"July"</font>, <font color=#004488>"August"</font>, <font color=#004488>"September"</font>,
    <font color=#004488>"October"</font>, <font color=#004488>"November"</font>, <font color=#004488>"December"</font> };
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Stack stk = <font color=#0000ff>new</font> Stack();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; months.length; i++)
      stk.push(months[i] + <font color=#004488>" "</font>);
    System.out.println(<font color=#004488>"stk = "</font> + stk);
    <font color=#009900>// Трактование стека, как Vector:</font>
    stk.addElement(<font color=#004488>"The last line"</font>);
    System.out.println(
      <font color=#004488>"element 5 = "</font> + stk.elementAt(5));
    System.out.println(<font color=#004488>"popping elements:"</font>);
    <font color=#0000ff>while</font>(!stk.empty())
      System.out.println(stk.pop());
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Каждая строка из массива <b>months </b>вставляется в <b>Stack</b> 
  с помощью <b>push(&#160;)</b>, а позднее достается из вершины стека с помощью 
  <b>pop(&#160;)</b>. Чтобы получить указатель, операции <b>Vector </b>также выполняются 
  над объектами <b>Stack</b>. Это возможно потому, что свойства <b>Stack</b> наследованы 
  <i>от</i> <b>Vector</b>. Таким образом, все операции, выполняемые для <b>Vector</b> 
  могут, так же быть выполнены для <b>Stack</b>, такие как <b>elementAt(&#160;)</b>.</FONT></P>
<P><FONT FACE="Georgia">Как упомянуто ранее, вы можете использовать <b>LinkedList</b>, 
  когда захотите получить поведение стека.</FONT><A NAME="_Toc481064710"></A></P>
<DIV ALIGN="LEFT"></DIV>
<A NAME="Heading328"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> BitSet</H3>
</FONT>
<P><FONT FACE="Georgia"> <A NAME="Index1048"></A><B>BitSet</B> используется, если 
  вы хотите эффективно хранить много информации. Эта эффективность относится к 
  размеру; если вам нужен эффективный доступ, это немного медленнее, чем использование 
  массива некоторого простого типа.</FONT></P>
<P><FONT FACE="Georgia">Кроме того, минимальный размер <b>BitSet</b> имеет размер 
  <b>long</b>: 64 бит. Это подразумевает, что если вы храните что-то маленькое, 
  длиной 8 бит, <b>BitSet</b> будет расточительным; лучше вам будет создать ваш 
  собственный класс, или просто массив, для хранения ваших флагов, если размер 
  имеет значение.</FONT></P>
<P><FONT FACE="Georgia">Обычный контейнер растягивается, когда вы добавляете больше 
  элементов, и <b>BitSet</b> так же делает это. Следующий пример демонстрирует 
  работу <b>BitSet</b>:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c09:Bits.java</font>
<font color=#009900>// Демонстрация BitSet.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Bits {
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> printBitSet(BitSet b) {
    System.out.println(<font color=#004488>"bits: "</font> + b);
    String bbits = <font color=#0000ff>new</font> String();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; b.size() ; j++)
      bbits += (b.get(j) ? <font color=#004488>"1"</font> : <font color=#004488>"0"</font>);
    System.out.println(<font color=#004488>"bit pattern: "</font> + bbits);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Random rand = <font color=#0000ff>new</font> Random();
    <font color=#009900>// Получение младшего байта  nextInt():</font>
    <font color=#0000ff>byte</font> bt = (<font color=#0000ff>byte</font>)rand.nextInt();
    BitSet bb = <font color=#0000ff>new</font> BitSet();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 7; i &gt;=0; i--)
      <font color=#0000ff>if</font>(((1 &lt;&lt; i) &amp;  bt) != 0)
        bb.set(i);
      <font color=#0000ff>else</font>
        bb.clear(i);
    System.out.println(<font color=#004488>"byte value: "</font> + bt);
    printBitSet(bb);

    <font color=#0000ff>short</font> st = (<font color=#0000ff>short</font>)rand.nextInt();
    BitSet bs = <font color=#0000ff>new</font> BitSet();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 15; i &gt;=0; i--)
      <font color=#0000ff>if</font>(((1 &lt;&lt; i) &amp;  st) != 0)
        bs.set(i);
      <font color=#0000ff>else</font>
        bs.clear(i);
    System.out.println(<font color=#004488>"short value: "</font> + st);
    printBitSet(bs);

    <font color=#0000ff>int</font> it = rand.nextInt();
    BitSet bi = <font color=#0000ff>new</font> BitSet();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 31; i &gt;=0; i--)
      <font color=#0000ff>if</font>(((1 &lt;&lt; i) &amp;  it) != 0)
        bi.set(i);
      <font color=#0000ff>else</font>
        bi.clear(i);
    System.out.println(<font color=#004488>"int value: "</font> + it);
    printBitSet(bi);

    <font color=#009900>// Test bitsets &gt;= 64 bits:</font>
    BitSet b127 = <font color=#0000ff>new</font> BitSet();
    b127.set(127);
    System.out.println(<font color=#004488>"set bit 127: "</font> + b127);
    BitSet b255 = <font color=#0000ff>new</font> BitSet(65);
    b255.set(255);
    System.out.println(<font color=#004488>"set bit 255: "</font> + b255);
    BitSet b1023 = <font color=#0000ff>new</font> BitSet(512);
    b1023.set(1023);
    b1023.set(1024);
    System.out.println(<font color=#004488>"set bit 1023: "</font> + b1023);
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Генератор случайных чисел используется для создания случайным 
  образом <b>byte</b>, <b>short</b> и <b>int</b>, и каждое из них трансформируется 
  в битовый шаблон в <b>BitSet</b>. Это хорошо работает, потому что <b>BitSet</b> 
  - это 64 бита, и никакой из этих типов не заставит увеличиться в размере. Затем 
  создается <b>BitSet</b> из 512 бит. Конструктор резервирует хранилище для удвоенного 
  такого числа бит. Однако, вы все равно можете установить 1024 бита или больше.</FONT><A NAME="_Toc481064711"></A></P>
<A NAME="Heading329"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Резюме</H2>
</FONT>
<P><FONT FACE="Georgia">Для обзора контейнеров, обеспечиваемых стандартной библиотекой 
  Java:</FONT></P>
<OL>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Массив ассоциирует с индексом 
    цифровой индекс. Он хранит объекты известного типа, так что вам не нужно выполнять 
    приведение результата, когда вы ищите объект. Он может быть многомерным и 
    он может содержать примитивные типы. Однако, его размер не может изменяться 
    после создания.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia"> <B>Collection</B> содержит 
    единичные элементы, а <B>Map</B> содержит ассоциированные пары.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Как и массив, <b>List</b> 
    также ассоциирует с объектом цифровые индексы &#8212; вы можете думать о массивах 
    и <b>List</b>, как об упорядоченных контейнерах. <b>List</b> автоматически 
    сам изменяет размер, когда вы добавляете дополнительные элементы. Но <b>List</b> 
    может хранить только <b>ссылки</b> на <b>Object</b>, поэтому он не может хранить 
    примитивные типы и вы должны всегда выполнять приведение, когда вытягиваете 
    ссылку на <b>Object </b>из контейнера.</FONT> 
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Используйте <b>ArrayList</b>, 
    если вы выполняете много обращений в случайном порядке, а <b>LinkedList</b>, 
    если будете выполнять много вставок и удалений из середины списка.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Поведение очереди, двойной 
    очереди и стека организуется через <B>LinkedList</B>.</FONT>
  <LI><FONT FACE="Georgia"> <B>Map</B> - это способ ассоциации не чисел, а объектов 
    с другими объектами. Дизайн <b>HashMap</b> фокусируется на повторном доступе, 
    а <b>TreeMap</b> хранит свои ключи в упорядоченном виде и поэтому не так быстр, 
    как <b>HashMap</b>.</FONT> 
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia"> <B>Set</B> принимает 
    объекты только одного типа. <b>HashSet</b> обеспечивает максимально быстрый 
    поиск, а <b>TreeSet</b> хранит свои элементы в упорядоченном виде.</FONT> 
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Нет необходимости использовать 
    допустимые классы <B>Vector</B>, <B>Hashtable</B> и <B>Stack</B> в новом коде.</FONT>
</OL>
<P><FONT FACE="Georgia">Контейнеры являются инструментами, которые вы можете использовать 
  как основу день ото дня, делая вашу программу проще, более мощной и более эффективной</FONT><FONT FACE="Georgia">.</FONT><A NAME="_Toc375545360"></A><A NAME="_Toc481064712"></A></P>
<A NAME="Heading330"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Упражнения</H2>
</FONT> 
<P><FONT FACE="Georgia" SIZE=2>Решения для выбранных упражнений могут быть найдены 
  в электронной документации &quot;<i>The Thinking in Java Annotated Solution 
  Guide</i>&quot;, доступной за малую плату на <i>www.BruceEckel.com</i>.</FONT></P>
<OL>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Создайте массив <b>double</b> 
    и заполните его (<b>fill(&#160;)</b>), используя <b>RandDoubleGenerator</b>. 
    Результат напечатайте.</FONT> 
  <LI><FONT FACE="Georgia">Создайте новый класс, называемый <b>Gerbil</b> с полем 
    <b>int gerbilNumber, </b> которое инициализируется конструктором (аналогично 
    примеру <b>Mouse </b>в этой главе). Создайте метод, называемый <b>hop(&#160;)</b>, 
    который печатает номер и какое это обращение. Создайте <b>ArrayList</b> и 
    добавьте группу объектов <b>Gerbil</b> в <b>List</b>. Теперь, используйте 
    метод <b>get(&#160;)</b> для прохода по списку и вызова <b>hop(&#160;)</b> 
    для каждого <b>Gerbil</b>.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Измените Упражнение 2 
    так, чтобы вы использовали <B>Iterator</B> для обхода <B>List</B> и вызова 
    <B>hop(&#160;)</B>.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Возьмите класс <b>Gerbil</b> 
    из Упражнения 2 и поместите его в <b>Map</b>, ассоциируя имя каждого <b>Gerbil</b>, 
    как строку (ключ) для каждого <b>Gerbil </b>(значение), поместите их в таблицу. 
    Получите <b>Iterator</b> для <b>keySet(&#160;)</b> и используйте его для прохода 
    <b>Map</b>, поиска <b>Gerbil</b> для каждого ключа и печать ключа и вызова 
    <b>hop(&#160;)</b> для <b>Gerbil.</b></FONT> 
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Создайте <B>List</B> (попробуйте 
    и <b>ArrayList, </b>и <b>LinkedList</b>) и заполните их, используя <b>Collections2.countries</b>. 
    Отсортируйте список и напечатайте его, затем примените <b>Collections.shuffle(&#160;)</b> 
    к списку несколько раз, печатайте каждый раз, чтобы увидеть, как вызовы метода 
    <b>shuffle(&#160;)</b> смешивает список по новому каждый раз.</FONT> 
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Продемонстрируйте, что 
    вы не можете ничего добавить в <b>MouseList</b>, кроме <B>Mouse</B>.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Измените <B>MouseList.java</B> 
    так, чтобы он наследовался от <b>ArrayList</b> вместо использования композиции. 
    Покажите проблему, которая при этом возникает.</FONT>
  <LI><FONT FACE="Georgia">Восстановите <B>CatsAndDogs.java</B>, создав контейнер 
    <b>Cats</b> (использующий <b>ArrayList</b>), который принимает и возвращает 
    только объекты <b>Cat.</b></FONT>
  <LI><FONT FACE="Georgia">Создайте контейнер, который инкапсулирует массив <b>String</b>, 
    и который добавляет только <b>String</b>, и возвращает только <b>String</b>, 
    так чтобы не нужно было приведение типов при использовании. Если ваш внутренний 
    массив недостаточно велик для добавления следующего элемента, ваш контейнер 
    автоматически мог бы изменять размер. В <b>main(&#160;)</b> сравните производительность 
    вашего контейнера и <b>ArrayList</b>, хранящего <b>String</b>.</FONT>
  <LI><FONT FACE="Georgia">Повторите Упражнение 9 для контейнера <b>int</b>, и 
    сравните с производительностью <b>ArrayList</b>, содержащим объекты <b>Integer</b>. 
    В ваш процесс сравнения включите процесс инкрементирования каждого объекта 
    контейнера.</FONT>
  <LI><FONT FACE="Georgia">Использую утилиты <b>com.bruceeckel.util</b>, создайте 
    массивы каждого из примитивных типов и <b>String</b>, затем заполните каждый, 
    используя соответствующий генератор, и напечатайте каждый массив, используя 
    соответствующий метод </FONT><FONT FACE="Georgia"> <B>print(&#160;)</B>.</FONT>
  <LI><FONT FACE="Georgia">Создайте генератор, который производит символьные имена 
    ваших любимых фильмов (вы можете использовать &quot;<i>Матрица</i>&quot; или 
    &quot;<i>Звездные войны</i>&quot; для сигнализации), и зациклите его на начало, 
    когда имена закончатся. Используйте утилиту в <b>com.bruceeckel.util</b> для 
    заполнения массива, <b>ArrayList</b>, <b>LinkedList</b> и обоих типов <b>Set</b>, 
    затем напечатайте каждый контейнер.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Создайте класс, содержащий 
    два объекта <b>String</b>, и сделайте его <b>Comparable</b>, так чтобы сравнение 
    происходило только по первым <b>String</b>. Заполните все массивы и <b>ArrayList 
    </b>объектами вашего класса, используя генератор <b>geography</b>. Продемонстрируйте, 
    что сортировка работает правильно. Теперь создайте <b>Comparator</b>, который 
    заботится только о вторых <b>String</b> и продемонстрируйте, что сортировка 
    работает правильно; также выполните бинарный поиск, используя ваш <b>Comparator</b>.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Измените Упражнение 13 
    так, чтобы использовалась алфавитная сортировка.</FONT>
  <LI><FONT FACE="Verdana">Используйте</FONT><FONT FACE="Georgia"> <B>Arrays2.RandStringGenerator</B> 
    для заполнения <b>TreeSet</b>, но используйте алфавитный порядок. Напечатайте 
    <b>TreeSet</b> для проверки порядка сортировки.</FONT>
  <LI><FONT FACE="Georgia">Создайте <B>ArrayList</B> и <B>LinkedList</B>, и заполните 
    каждый из них, используя генератор <b>Collections2.capitals</b>. Напечатайте 
    каждый список, используя обычный <b>Iterator</b>, затем вставьте один список 
    в другой, используя <b>ListIterator</b>, вставьте в любое другое место. Теперь 
    выполните вставление, начав с конца первого списка, перемещайтесь назад.</FONT> 
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Напишите метод, который 
    использует <b>Iterator</b> для прохода по <b>Collection</b> и печатайте <b>hashCode(&#160;)</b> 
    каждого объекта контейнера. Заполните все остальные типы <b>Collection</b> 
    объектами и примените ваш метод к каждому контейнеру.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Повторите проблему из 
    <B>InfiniteRecursion.java</B>.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Создайте класс, затем 
    создайте инициализированный массив объектов вашего класса. Заполните <b>List</b> 
    из вашего массива. Создайте подмножество вашего <b>List</b>, используя <b>subList(&#160;)</b>, 
    а затем удалите подмножество из вашего <b>List</b>, используя <b>removeAll(&#160;)</b>.</FONT><a name="B"></a>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Измените Упражнение 6 
    в Главе 7, чтобы программа использовала <b>ArrayList</b> для хранения <b>Rodent</b>, 
    и <b>Iterator</b> для перемещения по последовательности объектов <b>Rodent</b>. 
    Помните, что <b>ArrayList</b> хранит только <b>Object</b>, поэтому вы должны 
    выполнять приведение, когда получаете доступ к индивидуальному объекту <b>Rodent</b>.</FONT> 
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Следуя примеру <B>Queue.java</B>, 
    создайте класс <B>Deque</B> и проверьте его.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Используйте <b>TreeMap</b> 
    в <b>Statistics.java</b>. Теперь добавьте код, который проверяет различия 
    производительности <b>HashMap</b> и <b>TreeMap</b> в этой программе.</FONT>
  <LI><FONT FACE="Georgia">Постройте <B>Map</B> и <B>Set</B>, содержащих все страны, 
    начинающиеся с буквы &#8216;A&#8217;.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Используя <B>Collections2.countries</B>, 
    заполните <B>Set</B> несколько раз одними и теми же данными и проверьте, что 
    <b>Set</b> содержит только одну копию. Попробуйте проделать это с обоими видами 
    </FONT><FONT FACE="Georgia"> <B>Set</B>.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Начиная с <B>Statistics.java</B>, 
    создайте программу, которая несколько раз запускает тест и проверяет, что 
    одни номера появляются в результате чаще других.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Перепишите <B>Statistics.java</B>, 
    используя <B>HashSet</B> объектов <B>Counter</B> (измените <B>Counter</B> 
    так, чтобы он работал в <B>HashSet</B>). Какой подход кажется лучше?</FONT> 
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Измените класс из Упражнения 
    13 так, чтобы он работал с <B>HashSet</B> и как ключ с <B>HashMap</B>.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Используя <B>SlowMap.java</B> 
    для вдохновения, создайте <B>SlowSet</B>.</FONT> 
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Примените тесты в <B>Map1.java</B> 
    к <B>SlowMap</B> для проверки его работы. Найдите что-нибудь в <B>SlowMap</B>, 
    что не работает правильно.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Реализуйте оставшуюся 
    часть интерфейса <B>Map</B> для <B>SlowMap</B>.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Измените <B>MapPerformance.java</B> 
    для включения в проверку <B>SlowMap</B>.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Измените <B>SlowMap</B> 
    так, чтобы вместо двух <b>ArrayList</b>, он содержал один <b>ArrayList</b> 
    из объектов <b>MPair</b>. Проверьте, что измененная версия работает правильно. 
    Используя <b>MapPerformance.java</b>, проверьте скорость вашего нового объекта 
    <b>Map</b>. Теперь измените метод <b>put(&#160;)</b> так, чтобы он выполнял 
    сортировку после введения каждой пары, и измените <b>get(&#160;)</b>, чтобы 
    он использовал <b>Collections.binarySearch(&#160;)</b> для поиска ключа. Сравните 
    производительность новой версии и старой.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Добавьте поле <B>char</B> 
    в <B>CountedString</B>, которое будет инициализироваться в конструкторе, и 
    измените методы <B>hashCode(&#160;)</B> и <B>equals(&#160;)</B>, чтобы они 
    включали значение этого <B>char</B>.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Измените <B>SimpleHashMap</B> 
    так, чтобы он сообщал о коллизиях, и проверьте это, добавив одни и те же данные 
    дважды, чтобы вы могли вдеть коллизии.</FONT> 
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Измените <B>SimpleHashMap</B> 
    так, чтобы он сообщал число необходимых &#8220;проб&#8221; при возникновении 
    коллизий. То есть, сколько вызовов <b>next(&#160;)</b> должно быть выполнено 
    итератором для прохода по <b>LinkedList</b> и поиску совпадений</FONT><FONT FACE="Georgia">?</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Реализуйте методы <B>clear(&#160;)</B> 
    и <B>remove(&#160;)</B> для <B>SimpleHashMap</B>.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Реализуйте оставшуюся 
    часть интерфейса <B>Map</B> для <B>SimpleHashMap</B>.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Добавьте метод <B>private</B> 
    <B>rehash(&#160;)</B> для <B>SimpleHashMap</B>, который вызывается, когда 
    коэффициент загрузки превышает 0.75. Во время повторного хеширования удвойте 
    число ковшей, затем выполните поиск первого простого числа большего, чем определенное 
    новое число ковшей.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Следуя примеру в <B>SimpleHashMap.java</B>, 
    создайте и проверьте <B>SimpleHashSet</B>.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Измените <B>SimpleHashMap</B> 
    для использования <b>ArrayList</b> вместо <b>LinkedList</b>. Измените <b>MapPerformance.java</b> 
    для сравнения производительности двух реализаций.</FONT>
  <LI><FONT FACE="Georgia">Используя HTML документацию JDK (доступную на <i>java.sun.com</i>), 
    найдите класс <b>HashMap</b>. Создайте <b>HashMap</b>, наполните ее элементами 
    и определите коэффициент загрузки. Проверьте скорость поиска этой карты, затем 
    попробуйте увеличить скорость, создав новый <b>HashMap</b>, с большей начальной 
    емкостью, и скопируйте старую карту в новую, запустите ваш тест проверки скорости 
    для новой карты.</FONT> 
  <LI><FONT FACE="Georgia">В <a href="Chapter08.html">Главе 8</a>, найдите пример 
    <B>GreenhouseControls.java</B>, который состоит из трех файлов. В <B>Controller.java</B> 
    класс <B>EventSet</B> - это просто контейнер. </FONT> Измените код на использование 
    <FONT FACE="Georgia"><B>LinkedList</B> вместо <B>EventSet</B>. Это потребует 
    больше, чем простой замены <B>EventSet</B> на <B>LinkedList</B>; вы также 
    должны использовать <B>Iterator</B> для прохода по множеству событий.</FONT> 
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">(Сомнения). Напишите ваш 
    собственный класс карты, подстроенный для определенного типа ключа: например, 
    <B>String</B>. Не наследуйте его от <B>Map</B>. Вместо этого, дублируйте методы, 
    чтобы методы <B>put(&#160;)</B> и <B>get(&#160;)</B> принимал только объекты 
    <B>String</B> в качестве ключей, а не <B>Object</B>. Все, что затрагивает 
    ключи, не должно использовать общий тип, а вместо этого работать со <B>String</B>, 
    для предотвращения затрат на приведение и обратное приведение. Ваша цель в 
    создании максимально быстрой реализации. Измените <B>MapPerformance.java</B> 
    для проверки вашей реализации с <B>HashMap</B>.</FONT> 
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">(Сомнения). Найдите исходный 
    код для <B>List</B> в исходном коде библиотеки Java, которая поставляется 
    со всеми дистрибутивами Java. Скопируйте этот код и сделайте специальную версию, 
    назвав ее <b>intList</b>, которая содержит только <b>int</b>. Рассмотрите 
    что нужно сделать для создания специальных версии списков для всех примитивных 
    типов. Теперь рассмотрите что случится, если вы захотите создать связанный 
    список, который работает со всеми примитивными типами. Если бы параметризованные 
    типы уже были бы реализованы в Java, они обеспечивали бы способ выполнить 
    эту работу за вас автоматически (как и многие другие полезные действия).</FONT>
</OL>
<HR>
<P><A NAME="fn44">[44]</a><FONT FACE="Georgia" SIZE=2> Однако, можно спросить 
  насколько велик <B>vector</B>, а метод <B>at(&#160;)</B> <i>выполняет</i> проверку 
  границ.</FONT></P>
<P><A NAME="fn45">[45]</a><FONT FACE="Georgia" SIZE=2> Это одно из тех мест, где 
  C++ явно превосходит Java, так как C++ поддерживает <i>параметризированные типы</i> 
  с ключевым словом <B>template</B>.</FONT></P>
<P><A NAME="fn46">[46]</a><FONT FACE="Georgia" SIZE=2> Программист C++ заметит, 
  сколько много кода может уйти при использовании аргументов по умолчанию и шаблонов. 
  Программист Python заметит, что вся эта библиотека могла быть излишне большой 
  в этом языке.</FONT></P>
<P><A NAME="fn47">[47]</a><FONT FACE="Georgia" SIZE=2> По словам Joshua Bloch 
  из Sun.</FONT></P>
<P><A NAME="fn48">[48]</a><FONT FACE="Georgia" SIZE=2> Эти данные были найдены 
  в Internet, затем обработаны, путем создания программы на Python (смотрите <I>www.Python.org</I>).</FONT></P>
<P><A NAME="fn49">[49]</a><FONT FACE="Georgia" SIZE=2> Это то место, где перегрузка 
  операторов могла бы объявляться.</FONT></P>
<P><A NAME="fn50">[50]</a><FONT FACE="Georgia" SIZE=2> Если эти ускорения производительности 
  все еще не удовлетворяют ваши требования, вы можете еще ускорить поиск в таблице, 
  написав свой собственный <B>Map</B> и настроив его под ваш определенный тип 
  для предотвращения задержек на приведение типа от <B>Object</B>. Для получения 
  еще большего уровня производительности, энтузиасты скорости могут использовать 
  книгу Donald Knuth <I>The Art of Computer Programming, Volume 3: Sorting and 
  Searching, Second Edition</I> для замены перегруженного списка ковшей на массив, 
  который имеет два дополнительных полезных свойства: он может быть оптимизирован 
  для хранения характеристик на диске и он может сохранить много времени при создании 
  и сборке мусора индивидуальных записей.</FONT></P>
<DIV ALIGN="CENTER"> <FONT FACE="Verdana" size = "-1"> </FONT><font face="Verdana" size = "-1">[ 
  <a href="Chapter08.html">Предыдущая глава </a> ] [ <a href="SimpleContents.html">Оглавление</a> 
  ] [ <a href="Contents.html">Содержание</a> ] [ <a href="DocIndex.html">Индекс</a> 
  ] [ <a href="Chapter10.html">Следующая глава </a> ]</font></DIV>

</BODY>

</HTML>
