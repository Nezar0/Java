<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD lang="en"><META http-equiv="Content-Type" content="text/html; charset=windows-1251">
<TITLE>10: Обработка ошибок с помощью исключений</TITLE>
</HEAD>

<BODY  BGCOLOR="#FFFFFF">
<DIV ALIGN="CENTER"> <FONT FACE="Verdana" size = "-1"> </FONT> 
  <CENTER>
    <H2><FONT FACE="Verdana">
  Thinking in Java, 2nd edition, Revision 11</FONT></H2>
  <H3><FONT FACE="Verdana">&copy;2000 by Bruce Eckel</FONT></H3>
  
    <p><FONT FACE="Verdana" size = "-1"> </FONT><font face="Verdana" size = "-1">[ 
      <a href="Chapter09.html">Предыдущая глава </a> ] [ <a href="SimpleContents.html">Оглавление</a> 
      ] [ <a href="Contents.html">Содержание</a> ] [ <a href="DocIndex.html">Индекс</a> 
      ] [ <a href="Chapter11.html">Следующая глава </a> ]</font></p>
    <p align="left"><A NAME="_Toc375545361"></A><A NAME="_Toc477690730"></A><A NAME="_Toc481064713"></A><A NAME="Heading331"></A><FONT FACE = "Verdana"></FONT></p>
  </CENTER>
</DIV>
<div align="left"><FONT FACE = "Verdana"> </FONT></div>
<FONT FACE = "Verdana"> 
<H1 ALIGN="LEFT"> 10: Обработка ошибок с помощью исключений<A NAME="OLE_LINK1"></A></H1>
</FONT> 
<p><FONT FACE="Georgia" SIZE=4>Основная философия Java в том, что &#8220;плохо 
  сформированный код не будет работать&#8221;.</FONT></p>
<P><FONT FACE="Georgia">Идеальное время для поимки <A NAME="Index1049"></A><A NAME="Index1050"></A>ошибки 
  - это время компиляции, прежде чем вы попробуете даже запустить программу. Однако 
  не все ошибки могут быть определены во время компиляции. Оставшиеся проблемы 
  должны быть обработаны во время выполнения, с помощью некоторого правила, которая 
  позволяет источнику ошибки передавать соответствующую информацию приемщику, 
  который будет знать, как правильно обрабатывать затруднение.</FONT></P>
<P><FONT FACE="Georgia">В C и других ранних языках могло быть несколько таких 
  правил, и они обычно устанавливались соглашениями, а не являлись частью языка 
  программирования. Обычно вы возвращали специальное значение или устанавливали 
  флаг, а приемщику предлагалось взглянуть на это значение или на флаг и определить, 
  было ли что-нибудь неправильно. Однако, по прошествии лет, было обнаружено, 
  что программисты, использующие библиотеки, имеют тенденцию думать о себе, как 
  о непогрешимых, например: &#8220;Да, ошибки могут случаться с другими, но не 
  в <i>моем</i> коде&#8221;. Так что, не удивительно, что они не проверяют состояние 
  ошибки (а иногда состояние ошибки бывает слишком глупым, чтобы проверять </FONT><a href="#fn51">[51]</a><FONT FACE="Georgia">). 
  Если вы всякий раз проверяли состояние ошибки при вызове метода, ваш код мог 
  превратиться нечитаемый ночной кошмар. Поскольку программисты все еще могли 
  уговорить систему в этих языках, они были стойки к принятию правды: Этот подход 
  обработки ошибок имел большие ограничения при создании больших, устойчивых, 
  легких в уходе программ.</FONT></P>
<P><FONT FACE="Georgia">Решением является упор на причинную натуру обработки ошибок 
  и усиление правил. Это действительно имеет долгую историю, так как реализация 
  обработки исключений возвращает нас к операционным системам 1960-х и даже к 
  бейсиковому &#8220;<B>on error goto</B>&#8221; (переход по ошибке). Но исключения 
  C++ основывались на Ada, а Java напрямую базируется на C++ (хотя он больше похож 
  на Object Pascal).</FONT></P>
<P><FONT FACE="Georgia">Слово &#8220;исключение&#8221; используется в смысле &#8220;Я 
  беру исключение из этого&#8221;. В том месте, где возникает проблема, вы можете 
  не знать, что делать с ней, но вы знаете, что вы не можете просто весело продолжать; 
  вы должны остановиться и кто-то, где-то должен определить, что делать. Но у 
  вас нет достаточно информации в текущем контексте для устранения проблемы. Так 
  что вы передаете проблему в более высокий контекст, где кто-то будет достаточно 
  квалифицированным, чтобы принять правильное решение (как в цепочке команд).</FONT></P>
<P><FONT FACE="Georgia">Другая, более значимая выгода исключений в том, что они 
  очищают код обработки ошибок. Вместо проверки всех возможных ошибок и выполнения 
  этого в различных местах вашей программы, вам более нет необходимости проверять 
  место вызова метода (так как исключение гарантирует, что кто-то поймает его). 
  И вам необходимо обработать проблему только в одном месте, называемом <a name="Index1051"></a><i>обработчик 
  исключения</i>. Это сохранит ваш код и разделит код, описывающий то, что вы 
  хотите сделать, от кода, который выполняется, если что-то случается не так. 
  В общем, чтение, запись и отладка кода становится яснее при использовании исключений, 
  чем при использовании старого способа обработки ошибок.</FONT></P>
<P><FONT FACE="Georgia">Так как обработка исключений навязывается компилятором 
  Java, то есть так много примеров, которые могут быть написаны в этой книге без 
  изучения обработки исключений. Эта глава вводит вас в код, который вам необходим 
  для правильной обработки исключений, и способы, которыми вы можете генерировать 
  свои собственные исключения, если ваш метод испытывает затруднения.</FONT><A NAME="_Toc481064714"></A></P>
<A NAME="Heading332"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Основные исключения</H2>
</FONT> 
<P><FONT FACE="Georgia"> <A NAME="Index1052"></A><I>Исключительное состояние</I> 
  - это проблема, которая мешает последовательное исполнение метода или ограниченного 
  участка, в котором вы находитесь. Важно различать исключительные состояния и 
  обычные проблемы, в которых вы имеете достаточно информации в текущем контексте, 
  чтобы как-то справиться с трудностью. В исключительном состоянии вы не можете 
  продолжать обработку, потому что вы не имете необходимой информации, чтобы разобраться 
  с проблемой <i>в текущем контексте</i>. Все, что вы можете сделать - это выйти 
  из текущего контекста и отослать эту проблему к высшему контексту. Это то, что 
  случается, когда вы выбрасываете исключение.</FONT></P>
<P><FONT FACE="Georgia">Простой пример - деление. Если вы делите на ноль, стоит 
  проверить, чтобы убедиться, что вы пройдете вперед и выполните деление. Но что 
  это значит, что делитель равен нулю? Может быть, вы знаете, в контексте проблемы 
  вы пробуете решить это в определенном методе, как поступать с делителем, равным 
  нулю. Но если это не ожидаемое значение, вы не можете это определить внутри 
  и раньше должны выбросить исключение, чем продолжать свой путь.</FONT></P>
<P><FONT FACE="Georgia">Когда вы выбрасываете <A NAME="Index1053"></A>исключение, 
  случается несколько вещей. Во-первых, создается объект исключения тем же способом, 
  что и любой Java объект: в куче, с помощью <B>new</B>. Затем текущий путь выполнения 
  (который вы не можете продолжать) останавливается, и ссылка на объект исключения 
  выталкивается из текущего контекста. В этот момент вступает механизм обработки 
  исключений и начинает искать подходящее место для продолжения выполнения программы. 
  Это подходящее место - <i>обработчик исключения</i>, чья работа - извлечь проблему, 
  чтобы программа могла попробовать другой способ, либо просто продолжиться.</FONT></P>
<P><FONT FACE="Georgia">Простым примером выбрасывания исключения является рассмотрение 
  ссылки на объект, называемой <B>t</B>. Возможно, что вы можете передать ссылку, 
  которая не была инициализирована, так что вы можете пожелать проверить ее перед 
  вызовом метода, использующего эту ссылку на объект. Вы можете послать информацию 
  об ошибке в больший контекст с помощью создания объекта, представляющего вашу 
  информацию и &#8220;выбросить&#8221; его из вашего контекста. Это называется 
  <i>выбрасыванием исключения</i>. Это выглядит так:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>if</font>(t == <font color=#0000ff>null</font>)
  <font color=#0000ff>throw</font> <font color=#0000ff>new</font> NullPointerException();</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Здесь выбрасывается исключение, которое позволяет вам 
  &#8212; в текущем контексте &#8212; отказаться от ответственности, думая о будущем 
  решении. Оно магически обработается где-то в другом месте. <i>Где</i> именно 
  будет скоро показано.</FONT><A NAME="_Toc481064715"></A></P>
<A NAME="Heading333"></A><FONT FACE = "Verdana"> 
<H3 ALIGN="LEFT"> Аргументы исключения<A NAME="Index1054"></A><A NAME="Index1055"></A></H3>
</FONT> 
<p><FONT FACE="Georgia">Как и многие объекты в Java, вы всегда создаете исключения 
  в куче, используя <B>new</B>, который резервирует хранилище и вызывает конструктор. 
  Есть два конструктора для всех стандартных исключений: первый - конструктор 
  по умолчанию, и второй принимает строковый аргумент, так что вы можете поместить 
  подходящую информацию в исключение:</FONT></p>
<DIV ALIGN="LEFT"></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>if</font>(t == <font color=#0000ff>null</font>)
  <font color=#0000ff>throw</font> <font color=#0000ff>new</font> NullPointerException(<font color=#004488>"t = null"</font>);</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Эта строка позже может быть разложена при использовании 
  различных методов, как скоро будет показано.</FONT></P>
<P><FONT FACE="Georgia"> <A NAME="Index1056"></A>Ключевое слово <B>throw</B> является 
  причиной несколько относительно магических вещей. Обычно, вы сначала используете 
  <B>new</B> для создания объекта, который соответствует ошибочному состоянию. 
  Вы передаете результирующую ссылку в <B>throw</B>. Объект, в результате, &#8220;возвращается&#8221; 
  из метода, даже если метод обычно не возвращает этот тип объекта. Простой способ 
  представлять себе обработку исключений, как альтернативный механизм возврата, 
  хотя вы будете иметь трудности, если будете использовать эту аналогию и далее. 
  Вы можете также выйти из обычного блока, выбросив исключение. Но значение будет 
  возвращено, и произойдет выход из метода или блока.</FONT></P>
<P><FONT FACE="Georgia">Любое подобие обычному возврату из метода здесь заканчивается, 
  потому что <i>куда</i> вы возвращаетесь, полностью отличается от того места, 
  куда вы вернетесь при нормальном вызове метода. (Вы закончите в соответствующем 
  обработчике исключения, который может быть очень далеко &#8212; на много уровней 
  ниже по стеку вызова &#8212; от того места, где выброшено исключение.)</FONT></P>
<P><FONT FACE="Georgia">В дополнение, вы можете выбросить любой тип <B>Выбрасываемого(Throwable)</B>объекта, 
  который вы хотите. Обычно вы будете выбрасывать различные классы исключений 
  для каждого различного типа ошибок. Информация об ошибке представлена и внутри 
  объекта исключения, и выбранным типом исключения, так что кто-то в большем контексте 
  может определить, что делать с вашим исключением. (Часто используется только 
  информация о типе объекта исключения и ничего значащего не хранится в объекте 
  исключения.)</FONT><A NAME="_Toc305593298"></A><A NAME="_Toc305628770"></A><A NAME="_Toc312374113"></A><A NAME="_Toc375545364"></A><A NAME="_Toc481064716"></A></P>
<A NAME="Heading334"></A><FONT FACE = "Verdana"> 
<H2 ALIGN="LEFT"> Ловля исключения<A NAME="Index1057"></A><A NAME="Index1058"></A></H2>
</FONT> 
<p><FONT FACE="Georgia">Если метод выбросил исключение, он должен предполагать, 
  что исключение будет &#8220;поймано&#8221; и устранено. Один из преимуществ 
  обработки исключений Java в том, что это позволяет вам концентрироваться на 
  проблеме, которую вы пробуете решить в одном месте, а затем принимать меры по 
  ошибкам из этого кода в другом месте.</FONT></p>
<DIV ALIGN="LEFT"></DIV>
<P><FONT FACE="Georgia">Чтобы увидеть, как ловятся исключения, вы должны сначала 
  понять концепцию <A NAME="Index1060"></A><I>критического блока</I>. Он является 
  секцией кода, которая может произвести исключение и за которым следует код, 
  обрабатывающий это исключение.</FONT><A NAME="_Toc312374114"></A><A NAME="_Toc375545365"></A><A NAME="_Toc481064717"></A></P>
<A NAME="Heading335"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Блок try</H3>
</FONT> 
<P><FONT FACE="Georgia">Если вы находитесь внутри метода, и вы выбросили исключение 
  (или другой метод, вызванный вами внутри этого метода, выбросил исключение), 
  такой метод перейдет в процесс бросания. Если вы не хотите быть <B>выброшенными</B> 
  из метода, вы можете установить специальный блок внутри такого метода для поимки 
  исключения. Он называется <i>блок проверки</i>,<A NAME="Index1062"></A> потому 
  что вы &#8220;проверяете&#8221; ваши различные методы, вызываемые здесь. Блок 
  проверки - это обычный блок, которому предшествует ключевое слово <B>try</B>:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#0000ff>try</font> {
  <font color=#009900>// Код, который может сгенерировать исключение</font>
}</PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Если вы внимательно проверяли ошибки в языке программирования, 
  который не поддерживает исключений, вы окружали каждый вызов метода кодом установки 
  и проверки ошибки, даже если вы вызывали один и тот же метод несколько раз. 
  С обработкой исключений вы помещаете все в блок проверки и ловите все исключения 
  в одном месте. Это означает, что ваш код становится намного легче для написания 
  и легче для чтения, поскольку цель кода - не смешиваться с проверкой ошибок.</FONT><A NAME="_Toc312374115"></A><A NAME="_Toc375545366"></A><A NAME="_Toc481064718"></A></P>
<A NAME="Heading336"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Обработчики исключений</H3>
</FONT>
<P><FONT FACE="Georgia">Конечно, выбрасывание исключения должно где-то заканчиваться. 
  Это &#8220;место&#8221; - <i>обработчик исключения</i><A NAME="Index1063"></A><A NAME="Index1064"></A>, 
  и есть один обработчик для каждого типа исключения, которые вы хотите поймать. 
  Обработчики исключений следуют сразу за блоком проверки и объявляются ключевым 
  словом <B>catch<A NAME="Index1065"></A></B>:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"> 
  <PRE><font color=#0000ff>try</font> {
  <font color=#009900>// </font><font color=#009900>Код, который может сгенерировать исключение</font>
} <font color=#0000ff>catch</font>(Type1 id1) {
  <font color=#009900>// Обработка исключения Type1</font>
} <font color=#0000ff>catch</font>(Type2 id2) {
  <font color=#009900>// </font><font color=#009900>Обработка исключения</font><font color=#009900> Type2</font>
} <font color=#0000ff>catch</font>(Type3 id3) {
  <font color=#009900>// </font><font color=#009900>Обработка исключения</font><font color=#009900> Type3</font>
}

<font color=#009900>// и так далее...</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Каждое catch предложение (обработчик исключения) как меленький 
  метод, который принимает один и только один аргумент определенного типа. Идентификаторы 
  (<B>id1</B>, <B>id2</B> и так далее) могут быть использованы внутри обработчика, 
  как аргумент метода. Иногда вы нигде не используете идентификатор, потому что 
  тип исключения дает вам достаточно информации, чтобы разобраться с исключением, 
  но идентификатор все равно должен быть.</FONT></P>
<P><FONT FACE="Georgia">Обработчики должны располагаться прямо после блока проверки. 
  Если выброшено исключение, механизм обработки исключений идет охотится за первым 
  обработчиком с таким аргументом, тип которого совпадает с типом исключения. 
  Затем происходит вход в предложение catch, и рассматривается обработка исключения. 
  Поиск обработчика, после остановки на предложении catch, заканчивается. Выполняется 
  только совпавшее предложение catch; это не как инструкция <B>switch</B>, в которой 
  вам необходим <B>break</B> после каждого <B>case</B>, чтобы предотвратить выполнение 
  оставшейся части.</FONT></P>
<P><FONT FACE="Georgia">Обратите внимание, что внутри блока проверки несколько 
  вызовов различных методов может генерировать одно и тоже исключение, но вам 
  необходим только один обработчик.</FONT></P>
<A NAME="Heading337"></A><FONT FACE = "Verdana"> 
<H4 ALIGN="LEFT"> Прерывание против возобновления<A NAME="Index1066"></A><A NAME="Index1067"></A><A NAME="Index1068"></A></H4>
</FONT> 
<p><FONT FACE="Georgia">Есть две основные модели в теории обработки исключений. 
  При <I>прерывании </I>(которое поддерживает Java и C++), вы предполагаете, что 
  ошибка критична и нет способа вернуться туда, где возникло исключение. Кто бы 
  ни выбросил исключение, он решил, что нет способа спасти ситуацию, и он <i>не 
  хочет</i> возвращаться обратно.</FONT></p>
<DIV ALIGN="LEFT"></DIV>
<P><FONT FACE="Georgia">Альтернатива называется <I>возобновлением</I> - это означает, 
  что обработчик исключения может что-то сделать для исправления ситуации, а затем 
  повторно вызовет придирчивый метод, предполагая, что вторая попытка будет удачной. 
  Если вы хотите возобновления, это означает, что вы все еще надеетесь продолжить 
  выполнение после обработки исключения. В этом случае ваше исключение больше 
  похоже на вызов метода, в котором вы должны произвести настройку ситуации в 
  Java, после чего возможно возобновление. (То есть, не выбрасывать исключение; 
  вызвать метод, который исправит проблему.) Альтернатива - поместить ваш блок 
  <B>try</B> внутри цикла <B>while</B>, который производит повторный вход в блок 
  <B>try</B>, пока не будет получен удовлетворительный результат.</FONT></P>
<P><FONT FACE="Georgia">Исторически программисты используют операционные системы, 
  которые поддерживают обработку ошибок с возобновлением, в конечном счете, заканчивающуюся 
  использованием прерывающего кода и пропуском возобновления. Так что, хотя возобновление 
  на первый взгляд кажется привлекательнее, оно не так полезно на практике. Вероятно, 
  главная причина - это <i>с</i><a name="Index1069"></a><i>оединение</i> таких 
  результатов: ваш обработчик часто должен знать, где брошено исключение и содержать 
  не характерный специфический код для места выброса. Это делает код трудным для 
  написания и ухода, особенно для больших систем, где исключения могут быть сгенерированы 
  во многих местах.</FONT><A NAME="_Toc375545373"></A><A NAME="_Toc481064719"></A></P>
<A NAME="Heading338"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Создание ваших собственных исключений</H2>
</FONT>
<P><FONT FACE="Georgia">Вы не ограничены в использовании существующих Java <A NAME="Index1070"></A>исключений. 
  Это очень важно, потому что часто вам будет нужно создавать свои собственные 
  исключения, чтобы объявить специальную ошибку, которую способна создавать ваша 
  библиотека, но это не могли предвидеть, когда создавалась иерархия исключений 
  Java.</FONT></P>
<P><FONT FACE="Georgia">Для создания вашего собственного класса исключения вы 
  обязаны наследовать его от исключения существующего типа, предпочтительно от 
  того, которое наиболее близко подходит для вашего нового исключения (однако, 
  часто это невозможно). Наиболее простой способ создать новый тип исключения 
  - это просто создать конструктор по умолчанию для вас, так чтобы он совсем не 
  требовал кода:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c10:SimpleExceptionDemo.java</font>
<font color=#009900>// Наследование вашего собственного исключения.</font>
<font color=#0000ff>class</font> SimpleException <font color=#0000ff>extends</font> Exception {} 

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SimpleExceptionDemo {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> f() <font color=#0000ff>throws</font> SimpleException {
    System.out.println(
      <font color=#004488>"Throwing SimpleException from f()"</font>);
    <font color=#0000ff>throw</font> <font color=#0000ff>new</font> SimpleException ();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    SimpleExceptionDemo sed = 
      <font color=#0000ff>new</font> SimpleExceptionDemo();
    <font color=#0000ff>try</font> {
      sed.f();
    } <font color=#0000ff>catch</font>(SimpleException e) {
      System.err.println(<font color=#004488>"Caught it!"</font>);
    }
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Когда компилятор создает конструктор по умолчанию, он 
  автоматически (и невидимо) вызывает конструктор по умолчанию базового класса. 
  Конечно, в этом случае у вас нет конструктора <B>SimpleException(String)</B>, 
  но на практике он не используется часто. Как вы увидите, наиболее важная вещь 
  в использовании исключений - это имя класса, так что чаще всего подходят такие 
  исключения, как показаны выше.</FONT></P>
<P><FONT FACE="Georgia">Вот результат, который печатается на консоль <A NAME="Index1071"></A><I>стандартной 
  ошибки </I>- поток для записи в <A NAME="Index1072"></A><B>System.err</B>. Чаще 
  всего это лучшее место для направления информации об ошибках, чем <B>System.out</B>, 
  который может быть перенаправлен. Если вы посылаете вывод в <B>System.err</B>, 
  он не может быть перенаправлен, в отличие от <B>System.out</B>, так что пользователю 
  легче заметить его.</FONT></P>
<P><FONT FACE="Georgia">Создание класса исключения, который также имеет конструктор, 
  принимающий <B>String</B>, также достаточно просто:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c10:FullConstructors.java</font>
<font color=#009900>// </font><font color=#009900>Наследование вашего собственного исключения.</font>

<font color=#0000ff>class</font> MyException <font color=#0000ff>extends</font> Exception {
  <font color=#0000ff>public</font> MyException() {}
  <font color=#0000ff>public</font> MyException(String msg) {
    <font color=#0000ff>super</font>(msg);
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> FullConstructors {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> f() <font color=#0000ff>throws</font> MyException {
    System.out.println(
      <font color=#004488>"Throwing MyException from f()"</font>);
    <font color=#0000ff>throw</font> <font color=#0000ff>new</font> MyException();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> g() <font color=#0000ff>throws</font> MyException {
    System.out.println(
      <font color=#004488>"Throwing MyException from g()"</font>);
    <font color=#0000ff>throw</font> <font color=#0000ff>new</font> MyException(<font color=#004488>"Originated in g()"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      f();
    } <font color=#0000ff>catch</font>(MyException e) {
      e.printStackTrace(System.err);
    }
    <font color=#0000ff>try</font> {
      g();
    } <font color=#0000ff>catch</font>(MyException e) {
      e.printStackTrace(System.err);
    }
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Дополнительный код достаточно мал &#8212; добавлено два 
  конструктора, которые определяют способы создания <B>MyException</B>. Во втором 
  конструкторе явно вызывается конструктор базового класса с аргументом <B>String</B> 
  с помощью использования ключевого слова <B>super</B>.</FONT></P>
<P><FONT FACE="Georgia">Информация трассировки направляется в <B>System.err</B>, 
  так как это лучше, поскольку она будет выводиться, даже если <B>System.out</B> 
  будет перенаправлен.</FONT></P>
<P><FONT FACE="Georgia">Программа выводит следующее:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Throwing MyException from f()
MyException
        at FullConstructors.f(FullConstructors.java:16)
        at FullConstructors.main(FullConstructors.java:24)
Throwing MyException from g()
MyException: Originated in g()
        at FullConstructors.g(FullConstructors.java:20)
        at FullConstructors.main(FullConstructors.java:29)</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Вы можете увидеть недостаток деталей в этих сообщениях 
  <B>MyException</B>, выбрасываемых из <B>f(&#160;)</B>.</FONT></P>
<P><FONT FACE="Georgia">Процесс создания вашего собственного исключения может 
  быть развит больше. Вы можете добавить дополнительные конструкторы и члены:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c10:ExtraFeatures.java</font>
<font color=#009900>// Дальнейшее украшение класса исключения.</font>

<font color=#0000ff>class</font> MyException2 <font color=#0000ff>extends</font> Exception {
  <font color=#0000ff>public</font> MyException2() {}
  <font color=#0000ff>public</font> MyException2(String msg) {
    <font color=#0000ff>super</font>(msg);
  }
  <font color=#0000ff>public</font> MyException2(String msg, <font color=#0000ff>int</font> x) {
    <font color=#0000ff>super</font>(msg);
    i = x;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> val() { <font color=#0000ff>return</font> i; }
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> i;
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ExtraFeatures {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> f() <font color=#0000ff>throws</font> MyException2 {
    System.out.println(
      <font color=#004488>"Throwing MyException2 from f()"</font>);
    <font color=#0000ff>throw</font> <font color=#0000ff>new</font> MyException2();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> g() <font color=#0000ff>throws</font> MyException2 {
    System.out.println(
      <font color=#004488>"Throwing MyException2 from g()"</font>);
    <font color=#0000ff>throw</font> <font color=#0000ff>new</font> MyException2(<font color=#004488>"Originated in g()"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> h() <font color=#0000ff>throws</font> MyException2 {
    System.out.println(
      <font color=#004488>"Throwing MyException2 from h()"</font>);
    <font color=#0000ff>throw</font> <font color=#0000ff>new</font> MyException2(
      <font color=#004488>"Originated in h()"</font>, 47);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      f();
    } <font color=#0000ff>catch</font>(MyException2 e) {
      e.printStackTrace(System.err);
    }
    <font color=#0000ff>try</font> {
      g();
    } <font color=#0000ff>catch</font>(MyException2 e) {
      e.printStackTrace(System.err);
    }
    <font color=#0000ff>try</font> {
      h();
    } <font color=#0000ff>catch</font>(MyException2 e) {
      e.printStackTrace(System.err);
      System.err.println(<font color=#004488>"e.val() = "</font> + e.val());
    }
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Бал добавлен член - данные <B>i</B>, вместе с методами, 
  которые читают его значение и дополнительные конструкторы, которые устанавливают 
  его. Вод результат работы:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Throwing MyException2 from f()
MyException2
        at ExtraFeatures.f(ExtraFeatures.java:22)
        at ExtraFeatures.main(ExtraFeatures.java:34)
Throwing MyException2 from g()
MyException2: Originated in g()
        at ExtraFeatures.g(ExtraFeatures.java:26)
        at ExtraFeatures.main(ExtraFeatures.java:39)
Throwing MyException2 from h()
MyException2: Originated in h()
        at ExtraFeatures.h(ExtraFeatures.java:30)
        at ExtraFeatures.main(ExtraFeatures.java:44)
e.val() = 47</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Так как исключение является просто еще одним видом объекта, 
  вы можете продолжать этот процесс наращивания мощность ваших классов исключений. 
  Однако запомните, что все это украшение может быть потеряно для клиентского 
  программиста, использующего ваш пакет, так как он может просто взглянуть на 
  выбрасываемое исключение и ничего более. (Это способ чаще всего используется 
  в библиотеке исключений Java.)</FONT><A NAME="_Toc312374116"></A><A NAME="_Toc375545367"></A><A NAME="_Toc481064720"></A></P>
<A NAME="Heading339"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Спецификация исключения<A NAME="Index1073"></A><A NAME="Index1074"></A></H2>
</FONT>
<P><FONT FACE="Georgia">В Java, вам необходимо проинформировать клиентских программистов, 
  которые вызывают ваши методы, что метод может выбросить исключение. Это достаточно 
  цивилизованный метод, поскольку тот, кто производит вызов, может точно знать 
  какой код писать для поимки всех потенциальных исключений. Конечно, если доступен 
  исходный код, клиентский программист может открыть программу и посмотреть на 
  инструкцию <B>throw</B>, но часто библиотеки не поставляются с исходными текстами. 
  Для предотвращения возникновения этой проблемы Java обеспечивает синтаксис (и 
  <i>навязывает</i> вам этот синтаксис), позволяющий вам правильно сказать клиентскому 
  программисту, какое исключение выбрасывает этот метод, так что клиентский программист 
  может обработать его. Это <i>спецификация исключения</i> и это часть объявления 
  метода, добавляемая после списка аргументов.</FONT></P>
<P><FONT FACE="Georgia">Спецификация исключения использует дополнительное ключевое 
  слово <B>throws</B>, за которым следует за список потенциальных типов исключений. 
  Так что определение вашего метода может выглядеть так:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>void</font> f() <font color=#0000ff>throws</font> TooBig, TooSmall, DivZero { <font color=#009900>//... </font></PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Если вы скажете</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>void</font> f() { <font color=#009900>// ...</font></PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">это будет означать, что исключения не выбрасываются из 
  этого метода. (<i>Кроме</i> исключения, типа <B>RuntimeException</B>, которое 
  может быть выброшено в любом месте &#8212; это будет описано позже.)</FONT></P>
<P><FONT FACE="Georgia">Вы не можете обмануть спецификацию исключения &#8212; 
  если ваш метод является причиной исключения и не обрабатывает его, компилятор 
  обнаружит это и скажет вам что вы должны либо обработать исключение, либо указать 
  с помощью спецификации исключения, что оно может быть выброшено из вашего метода. 
  При введении ограничений на спецификацию исключений с верху вниз, Java гарантирует, 
  что исключение будет корректно обнаружено во <i>время компиляции</i><a href="#fn52">[52]</a>.</FONT> 
</P>
<P><FONT FACE="Georgia">Есть одно место, в котором вы можете обмануть: вы можете 
  заявить о выбрасывании исключения, которого на самом деле нет. Компилятор получит 
  ваши слова об этом и заставит пользователя вашего метода думать, что это исключение 
  на самом деле выбрасывается. Это имеет благотворный эффект на обработчика этого 
  исключения, так как вы на самом деле позже можете начать выбрасывать это исключение 
  и это не потребует изменения существующего кода. Также важно создание <B>абстрактного 
  </B> базового класса и <B>интерфейсов</B>, наследующих классам или реализующим 
  многие требования по выбрасыванию исключений.</FONT><A NAME="_Toc312374118"></A><A NAME="_Toc375545368"></A><A NAME="_Toc481064721"></A></P>
<A NAME="Heading340"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Перехват любого исключения<A NAME="Index1075"></A><A NAME="Index1076"></A></H3>
</FONT>
<P><FONT FACE="Georgia">Можно создать обработчик, ловящий любой тип исключения. 
  Вы сделаете это, перехватив исключение базового типа <B>Exception</B> (есть 
  другие типы базовых исключений, но <B>Exception</B> - это базовый тип, которому 
  принадлежит фактически вся программная активность):</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>catch</font>(Exception e) {
  System.err.println(<font color=#004488>"Caught an exception"</font>);
}</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Это поймает любое исключение, так что, если вы используете 
  его, вы будете помещать его в конце вашего списка обработчиков для предотвращения 
  перехвата любого обработчика исключения, который мог управлять течением.</FONT></P>
<DIV ALIGN="LEFT">
  <P><FONT FACE="Georgia">Так как класс <B>Exception</B> - это базовый класс для 
    всех исключений, которые важны для программиста, вы не получите достаточно 
    специфической информации об исключении, но вы можете вызвать метод, который 
    пришел из <i>его</i> базового типа<A NAME="Index1077"></A><A NAME="Index1078"></A><B> 
    Throwable</B>:</FONT></P>
</DIV>
<P><FONT FACE="Georgia"><B>String getMessage(&#160;)</B></FONT><BR>
  <FONT FACE="Georgia"><B>String </B><A HREF="C:#getLocalizedMessage()">getLocalizedMessage</A><B>(&#160;)</B></FONT><BR>
  <FONT FACE="Georgia">Получает подробное сообщение или сообщение, отрегулированное 
  по его месту действия.</FONT></P>
<P><FONT FACE="Georgia"><B>String toString(&#160;)</B></FONT><BR>
  <FONT FACE="Georgia">Возвращает короткое описание Throwable, включая подробности 
  сообщения, если они есть.</FONT></P>
<P><FONT FACE="Georgia"><B>void <A NAME="Index1079"></A>printStackTrace(&#160;) 
  </B></FONT><BR>
  <FONT FACE="Georgia"><B>void printStackTrace(PrintStream)</B></FONT><BR>
  <FONT FACE="Georgia"><B>void </B><A HREF="C:#printStackTrace(java.io.PrintWriter)">printStackTrace</A><B>(</B><A HREF="C:">PrintWriter</A><B>) 
  </B></FONT><BR>
  <FONT FACE="Georgia">Печатает Throwable и трассировку вызовов Throwable. Вызов 
  стека показывает последовательность вызовов методов, которые подвели вас к точке, 
  в которой было выброшено исключение. Первая версия печатает в поток стандартный 
  поток ошибки, второй и третий печатают в выбранный вами поток (в <a href="Chapter11.html">Главе 
  11</a>, вы поймете, почему есть два типа потоков).</FONT></P>
<P><FONT FACE="Georgia"><B>Throwable </B><A HREF="C:#fillInStackTrace()">fillInStackTrace</A><B>(&#160;)</B></FONT><BR>
  <FONT FACE="Georgia">Запись информации в этот <B>Throwable </B>объекте о текущем 
  состоянии кадра стека. Это полезно, когда приложение вновь выбрасывает ошибки 
  или исключение (дальше об этом будет подробнее).</FONT></P>
<P><FONT FACE="Georgia">Кроме этого вы имеете некоторые другие метода, наследуемые 
  от базового типа <B>Throwable</B> <B>Object</B> (базовый тип для всего). Один 
  из них, который может быть удобен для исключений, это <A NAME="Index1080"></A><A NAME="Index1081"></A><B>getClass(&#160;)</B>, 
  который возвращает объектное представление класса этого объекта. Вы можете опросить 
  у объекта этого <b>Класса</b> его имя с помощью <B>getName(&#160;)</B> или <B>toString(&#160;)</B>. 
  Вы также можете делать более изощренные вещи с объектом <b>Класса</b>, которые 
  не нужны в обработке ошибок. Объект <B>Class</B> будет изучен позже в этой книге.</FONT></P>
<DIV ALIGN="LEFT">
  <P><FONT FACE="Georgia">Вот пример, показывающий использование основных методов 
    <B>Exception</B>:</FONT></P>
</DIV>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c10:ExceptionMethods.java</font>
<font color=#009900>// Демонстрация методов Exception.</font>

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ExceptionMethods {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      <font color=#0000ff>throw</font> <font color=#0000ff>new</font> Exception(<font color=#004488>"Here's my Exception"</font>);
    } <font color=#0000ff>catch</font>(Exception e) {
      System.err.println(<font color=#004488>"Caught Exception"</font>);
      System.err.println(
        <font color=#004488>"e.getMessage(): "</font> + e.getMessage());
      System.err.println(
        <font color=#004488>"e.getLocalizedMessage(): "</font> +
         e.getLocalizedMessage());
      System.err.println(<font color=#004488>"e.toString(): "</font> + e);
      System.err.println(<font color=#004488>"e.printStackTrace():"</font>);
      e.printStackTrace(System.err);
    }
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Вывод этой программы:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Caught Exception
e.getMessage(): Here's my Exception
e.getLocalizedMessage(): Here's my Exception
e.toString(): java.lang.Exception: 
   Here's my Exception
e.printStackTrace():
java.lang.Exception: Here's my Exception
 at ExceptionMethods.main(ExceptionMethods.java:7)
java.lang.Exception: 
   Here's my Exception
 at ExceptionMethods.main(ExceptionMethods.java:7)</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Вы можете заметить, что методы обеспечивают больше информации 
  &#8212; каждый из них дополняет предыдущий.</FONT><A NAME="_Toc312374119"></A><A NAME="_Toc375545369"></A><A NAME="_Toc481064722"></A></P>
<A NAME="Heading341"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Повторное выбрасывание исключений<A NAME="Index1082"></A><A NAME="Index1083"></A></H3>
</FONT>
<P><FONT FACE="Georgia">Иногда вам будет нужно вновь выбросить исключение, которое 
  вы только что поймали, обычно это происходит, когда вы используете <B>Exception</B>, 
  чтобы поймать любое исключение. Так как вы уже имеете ссылку на текущее исключение, 
  вы можете просто вновь бросить эту ссылку:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>catch</font>(Exception e) {
  System.err.println(<font color=#004488>"An exception was thrown"</font>);
  <font color=#0000ff>throw</font> e;
}</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Повторное выбрасывание исключения является причиной того, 
  что исключение переходит в обработчик следующего, более старшего контекста. 
  Все остальные предложения <B>catch</B> для того же самого блока <B>try</B> игнорируются. 
  Кроме того, все, что касается объекта исключения, сохраняется, так что обработчик 
  старшего контекста, который поймает исключение этого специфического типа, может 
  получить всю информацию из этого объекта.</FONT></P>
<DIV ALIGN="LEFT">
  <P><FONT FACE="Georgia">Если вы просто заново выбросите текущее исключение, 
    то информация, которую вы печатаете об этом исключении, в <A NAME="Index1084"></A><A NAME="Index1085"></A><B>printStackTrace(&#160;) 
    </B>будет принадлежать источнику исключения, а не тому месту, откуда вы его 
    вновь выбросили. Если вы хотите установить новый стек информации трассировки, 
    вы можете сделать это, вызвав функцию <A NAME="Index1086"></A><A NAME="Index1087"></A><B>fillInStackTrace(&#160;)</B>, 
    которая возвращает объект исключения, для которого текущий стек наполняется 
    информацией для старого объекта исключения. Вот как это выглядит:</FONT></P>
</DIV>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c10:Rethrowing.java</font>
<font color=#009900>// Демонстрация fillInStackTrace()</font>

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Rethrowing {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> f() <font color=#0000ff>throws</font> Exception {
    System.out.println(
      <font color=#004488>"originating the exception in f()"</font>);
    <font color=#0000ff>throw</font> <font color=#0000ff>new</font> Exception(<font color=#004488>"thrown from f()"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> g() <font color=#0000ff>throws</font> Throwable {
    <font color=#0000ff>try</font> {
      f();
    } <font color=#0000ff>catch</font>(Exception e) {
      System.err.println(
        <font color=#004488>"Inside g(), e.printStackTrace()"</font>);
      e.printStackTrace(System.err);
      <font color=#0000ff>throw</font> e; <font color=#009900>// 17</font>
      <font color=#009900>// throw e.fillInStackTrace(); // 18</font>
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font>
  main(String[] args) <font color=#0000ff>throws</font> Throwable {
    <font color=#0000ff>try</font> {
      g();
    } <font color=#0000ff>catch</font>(Exception e) {
      System.err.println(
        <font color=#004488>"Caught in main, e.printStackTrace()"</font>);
      e.printStackTrace(System.err);
    }
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Важные строки помечены комментарием с числами. При раскомментированной 
  строке 17 (как показано), на выходе получаем:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>originating the exception in f()
Inside g(), e.printStackTrace()
java.lang.Exception: thrown from f()
        at Rethrowing.f(Rethrowing.java:8)
        at Rethrowing.g(Rethrowing.java:12)
        at Rethrowing.main(Rethrowing.java:24)
Caught in main, e.printStackTrace()
java.lang.Exception: thrown from f()
        at Rethrowing.f(Rethrowing.java:8)
        at Rethrowing.g(Rethrowing.java:12)
        at Rethrowing.main(Rethrowing.java:24)</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Так что стек трассировки исключения всегда помнит исходное 
  место, не имеет значения, сколько прошло времени перед повторным выбрасыванием.</FONT></P>
<DIV ALIGN="LEFT">
  <P><FONT FACE="Georgia">Если закомментировать строку 17, а строку 18 раскомментировать, 
    будет использоваться функция <B>fillInStackTrace(&#160;)</B>, и получим результат:</FONT></P>
</DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>originating the exception in f()
Inside g(), e.printStackTrace()
java.lang.Exception: thrown from f()
        at Rethrowing.f(Rethrowing.java:8)
        at Rethrowing.g(Rethrowing.java:12)
        at Rethrowing.main(Rethrowing.java:24)
Caught in main, e.printStackTrace()
java.lang.Exception: thrown from f()
        at Rethrowing.g(Rethrowing.java:18)
        at Rethrowing.main(Rethrowing.java:24)</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Поскольку <B>fillInStackTrace(&#160;)</B> в строке 18 
  становится новой <A NAME="Index1088"></A>исходной точкой исключения.</FONT></P>
<DIV ALIGN="LEFT">
  <P><FONT FACE="Georgia">Класс <B>Throwable</B> должен появиться в спецификации 
    исключения для <B>g(&#160;)</B> и <B>main(&#160;)</B>, потому что <B>fillInStackTrace(&#160;)</B> 
    производит ссылку на объект <B>Throwable</B>. Так как <A NAME="Index1089"></A><B>Throwable</B> 
    - это базовый класс для <B>Exception</B>, можно получить объект, который является 
    <B>Throwable</B>, но <i>не</i> <B>Exception</B>, так что обработчик для <B>Exception</B> 
    в <B>main(&#160;) </B>может промахнуться. Чтобы убедится, что все в порядке, 
    компилятор навязывает спецификацию исключения для <B>Throwable</B>. Например, 
    исключение в следующем примере <i>не</i> перехватывается в <B>main(&#160;)</B>:</FONT></P>
</DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c10:ThrowOut.java</font>
<font color=#0000ff>public</font> <font color=#0000ff>class</font> ThrowOut {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font>
  main(String[] args) <font color=#0000ff>throws</font> Throwable {
    <font color=#0000ff>try</font> {
      <font color=#0000ff>throw</font> <font color=#0000ff>new</font> Throwable(); 
    } <font color=#0000ff>catch</font>(Exception e) {
      System.err.println(<font color=#004488>"Caught in main()"</font>);
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Также возможно вновь выбросить исключение, отличающееся 
  от того, которое вы поймали. Если вы делаете это, вы получаете сходный эффект, 
  как если бы вы использовали <B>fillInStackTrace(&#160;)</B> &#8212; информация 
  об оригинальном состоянии исключения теряется, а то, с чем вы остаетесь - это 
  информация, относящаяся к новому <B>throw</B>:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c10:RethrowNew.java</font>
<font color=#009900>// Повторное выбрасывание объекта</font>,
<font color=#009900>// отличающегося от пойманного.</font>

<font color=#0000ff>class</font> OneException <font color=#0000ff>extends</font> Exception {
  <font color=#0000ff>public</font> OneException(String s) { <font color=#0000ff>super</font>(s); }
}

<font color=#0000ff>class</font> TwoException <font color=#0000ff>extends</font> Exception {
  <font color=#0000ff>public</font> TwoException(String s) { <font color=#0000ff>super</font>(s); }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> RethrowNew {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> f() <font color=#0000ff>throws</font> OneException {
    System.out.println(
      <font color=#004488>"originating the exception in f()"</font>);
    <font color=#0000ff>throw</font> <font color=#0000ff>new</font> OneException(<font color=#004488>"thrown from f()"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
  <font color=#0000ff>throws</font> TwoException {
    <font color=#0000ff>try</font> {
      f();
    } <font color=#0000ff>catch</font>(OneException e) {
      System.err.println(
        <font color=#004488>"Caught in main, e.printStackTrace()"</font>);
      e.printStackTrace(System.err);
      <font color=#0000ff>throw</font> <font color=#0000ff>new</font> TwoException(<font color=#004488>"from main()"</font>);
    }
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Вот что напечатается:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>originating the exception in f()
Caught in main, e.printStackTrace()
OneException: thrown from f()
        at RethrowNew.f(RethrowNew.java:17)
        at RethrowNew.main(RethrowNew.java:22)
Exception in thread <font color=#004488>"main"</font> TwoException: from main()
        at RethrowNew.main(RethrowNew.java:27)</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Конечное исключение знает только то, что оно произошло 
  в <B>main(&#160;)</B>, а не в <B>f(&#160;)</B>. </FONT> </P>
<P><FONT FACE="Georgia">Вам никогда не нужно заботится об очистке предыдущего 
  исключения или что другое исключение будет иметь значение. Они являются объектами, 
  базирующимися в куче и создающимися с помощью <B>new</B>, так что сборщик мусора 
  автоматически очистит их все.</FONT><A NAME="_Toc375545370"></A><A NAME="_Toc481064723"></A></P>
<A NAME="Heading342"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Стандартные исключения Java</H2>
</FONT>
<P><FONT FACE="Georgia">Класс Java <B>Throwable</B> описывает все, что может быть 
  выброшено как исключение. Есть два основных типа объектов <B>Throwable</B> (&#8220;тип&#8221; 
  = &#8220;наследуется от&#8221;). <A NAME="Index1090"></A><B>Error</B> представляет 
  ошибки времени компиляции и системные ошибки, о поимке которых вам не нужно 
  беспокоиться (за исключением особых случаев). <A NAME="Index1091"></A><B>Exception</B> 
  - основной тип, который может быть выброшен из любого стандартного метода библиотеки 
  классов Java и из вашего метода, что случается во время работы. Так что основной 
  тип, интересующий программистов Java - это <B>Exception</B>.</FONT></P>
<DIV ALIGN="LEFT">
  <P><FONT FACE="Georgia">Лучший способ получить обзор исключений - просмотреть 
    HTML документацию Java, которую можно загрузить с <I>java.sun.com.</I> Это 
    стоит сделать один раз, чтобы почувствовать разнообразие исключений, но вы 
    скоро увидите, что нет никакого специального отличия одного исключения от 
    другого кроме его имени. Кроме того, число исключений в Java увеличивается, 
    поэтому бессмысленно перечислять их в книге. Каждая новая библиотека, получаемая 
    от третьих производителей, вероятно, имеет свои собственные исключения. Важно 
    понимать концепцию и то, что вы должны делать с исключением.</FONT></P>
</DIV>
<DIV ALIGN="LEFT">
  <P><FONT FACE="Georgia">Основная идея в том, что имя исключения представляет 
    возникшую проблему, и имя исключения предназначено для самообъяснения. Не 
    все исключения определены в <B>java.lang</B>, некоторые создаются для поддержки 
    других библиотек, таких как <B>util</B>, <B>net</B> и <B>io</B>, как вы можете 
    видеть по полому имени класса или по их наследованию. Например, все исключения 
    I/O наследуются от <B>java.io.IOException</B>.</FONT><A NAME="_Toc375545372"></A><A NAME="_Toc481064724"></A></P>
</DIV>
<A NAME="Heading343"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Особый случай RuntimeException</H3>
</FONT>
<P><FONT FACE="Georgia">Первый пример в этой главе был:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>if</font>(t == <font color=#0000ff>null</font>)
  <font color=#0000ff>throw</font> <font color=#0000ff>new</font> NullPointerException();</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Это может быть немного пугающим: думать, что вы должны 
  проверять на <B>null</B> каждую ссылку, передаваемую в метод (так как вы не 
  можете знать, что при вызове была передана правильная ссылка). К счастью вам 
  не нужно это, поскольку Java выполняет стандартную проверку во время выполнения 
  за вас и, если вы вызываете метод для <B>null</B> ссылки, Java автоматически 
  выбросит <A NAME="Index1092"></A><A NAME="Index1093"></A><B>NullPointerException</B>. 
  Так что приведенную выше часть кода всегда излишняя.</FONT></P>
<P><FONT FACE="Georgia">Есть целая группа типов исключений, которые относятся 
  к такой категории. Они всегда выбрасываются Java автоматически и вам не нужно 
  включать их в вашу спецификацию исключений. Что достаточно удобно, что они все 
  сгруппированы вместе и относятся к одному базовому классу, называемому <B>RuntimeException</B>, 
  который является великолепным примером наследования: он основывает род типов, 
  которые имеют одинаковые характеристики и одинаковы в поведении. Также вам никогда 
  не нужно писать спецификацию исключения, объявляя, что метод может выбросить 
  <B>RuntimeException</B>, так как это просто предполагается. Так как они указывают 
  на ошибки, вы, фактически, никогда не выбрасываете <A NAME="Index1094"></A><A NAME="Index1095"></A><B>RuntimeException</B> 
  &#8212; это делается автоматически. Если вы заставляете ваш код выполнять проверку 
  на <B>RuntimeException</B>s, он может стать грязным. Хотя вы обычно не ловите 
  <B>RuntimeExceptions</B>,<B> </B>в ваших собственных пакетах вы можете по выбору 
  выбрасывать некоторые из <B>RuntimeException</B>.</FONT></P>
<P><FONT FACE="Georgia">Что случится, если вы не выбросите это исключение? Так 
  как компилятор не заставляет включать спецификацию исключений для этого случая, 
  достаточно правдоподобно, что <B>RuntimeException</B> могут принизывать насквозь 
  ваш метод <B>main(&#160;) </B> и не ловится. Чтобы увидеть, что случится в этом 
  случае, попробуйте следующий пример:</FONT><BR>
</P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c10:NeverCaught.java</font>
<font color=#009900>// Игнорирование RuntimeExceptions.</font>

<font color=#0000ff>public</font> <font color=#0000ff>class</font> NeverCaught {
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> f() {
    <font color=#0000ff>throw</font> <font color=#0000ff>new</font> RuntimeException(<font color=#004488>"From f()"</font>);
  }
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> g() {
    f();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    g();
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Вы уже видели, что <B>RuntimeException </B>(или любое, 
  унаследованное от него) - это особый случай, так как компилятор не требует спецификации 
  этих типов.</FONT></P>
<P><FONT FACE="Georgia">Вот что получится при выводе:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Exception in thread <font color=#004488>"main"</font>
java.lang.RuntimeException: From f()
        at NeverCaught.f(NeverCaught.java:9)
        at NeverCaught.g(NeverCaught.java:12)
        at NeverCaught.main(NeverCaught.java:15)</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Так что получим такой ответ: Если получаем <B>RuntimeException</B>, 
  все пути ведут к выходу из <B>main(&#160;)</B> без поимки, для такого исключения 
  вызывается <B>printStackTrace(&#160;)</B>, и происходит выход из программы.</FONT></P>
<P><FONT FACE="Georgia">Не упускайте из виду, что вы можете только игнорировать 
  <B>RuntimeException</B> в вашем коде, так как вся другая обработка внимательно 
  ограничивается компилятором. Причина в том, что <B>RuntimeException</B> представляют 
  ошибки программы:</FONT></P>
<OL>
  <LI>Ошибка, которую вы не можете поймать<FONT FACE="Verdana"> </FONT><FONT FACE="Georgia"> 
    (получение <B>null</B> ссылки, передаваемой в ваш метод клиентским программистом, 
    например).</FONT>
  <LI>Ошибки, которые вы, как программист, должны проверять в вашем коде <FONT FACE="Verdana"> 
    </FONT><FONT FACE="Georgia"> (такие как <B>ArrayIndexOutOfBoundsException</B>, 
    где вы должны обращать внимание на размер массива).</FONT>
</OL>
<P><FONT FACE="Georgia">Вы можете увидеть какая огромная выгода от этих исключений, 
  так как они помогают процессу отладки.</FONT></P>
<P><FONT FACE="Georgia">Интересно заметить, что вы не можете классифицировать 
  обработку исключений Java, как инструмент с одним предназначением. Да, он предназначен 
  для обработки этих надоедливых ошибок времени выполнения, которые будут случаться, 
  потому что ограничения накладываются вне кода управления, но он также важен 
  для определенных типов ошибок программирования, которые компилятор не может 
  отследить.</FONT><A NAME="_Toc481064725"></A><A NAME="Heading344"></A></P>
<FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Выполнение очистки с помощью finally</H2>
</FONT>
<P><FONT FACE="Georgia">Часто есть такие места кода, которые вы хотите выполнить 
  независимо от того, было ли выброшено исключение в блоке <B>try</B>, или нет. 
  Это обычно относится к некоторым операциям, отличным от утилизации памяти (так 
  как об этом заботится сборщик мусора). Для достижения этого эффекта вы используете 
  предложение <A NAME="Index1096"></A><A NAME="Index1097"></A><B>finally</B></FONT> 
  <a href="#fn53">[53]</a><FONT FACE="Georgia"> в конце списка всех обработчиков 
  исключений. Полная картина секции обработки исключений выглядит так:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"> 
  <PRE><font color=#0000ff>try</font> {
  <font color=#009900>// Критическая область: Опасная активность,</font>
  <font color=#009900>// при которой могут быть выброшены A, B или C </font>
} <font color=#0000ff>catch</font>(A a1) {
  <font color=#009900>// Обработчик ситуации A</font>
} <font color=#0000ff>catch</font>(B b1) {
  <font color=#009900>// </font><font color=#009900>Обработчик ситуации</font><font color=#009900> B</font>
} <font color=#0000ff>catch</font>(C c1) {
  <font color=#009900>// </font><font color=#009900>Обработчик ситуации</font><font color=#009900> C</font>
} <font color=#0000ff>finally</font> {
  <font color=#009900>// Действия, совершаемые всякий раз</font>
}</PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Для демонстрации, что предложение <B>finally</B> всегда 
  отрабатывает, попробуйте эту программу:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"> 
  <PRE><font color=#009900>//: c10:FinallyWorks.java</font>
<font color=#009900>// Предложение finally выполняется всегда.</font>

<font color=#0000ff>class</font> ThreeException <font color=#0000ff>extends</font> Exception {}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> FinallyWorks {
  <font color=#0000ff>static</font> <font color=#0000ff>int</font> count = 0;
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>while</font>(<font color=#0000ff>true</font>) {
      <font color=#0000ff>try</font> {
        <font color=#009900>// Пост-инкремент, вначале </font><font color=#009900>равен </font><font color=#009900>нулю:</font>
        <font color=#0000ff>if</font>(count++ == 0)
          <font color=#0000ff>throw</font> <font color=#0000ff>new</font> ThreeException();
        System.out.println(<font color=#004488>"No exception"</font>);
      } <font color=#0000ff>catch</font>(ThreeException e) {
        System.err.println(<font color=#004488>"ThreeException"</font>);
      } <font color=#0000ff>finally</font> {
        System.err.println(<font color=#004488>"In finally clause"</font>);
        <font color=#0000ff>if</font>(count == 2) <font color=#0000ff>break</font>; <font color=#009900>// выйти из "while"</font>
      }
    }
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Эта программа также дает подсказку, как вы можете поступить 
  с фактом, что исключения в Java (как и исключения в C++) не позволяют вам возвратится 
  обратно в то место, откуда оно выброшено, как обсуждалось ранее. Если вы поместите 
  ваш блок <B>try</B> в цикл, вы сможете создать состояние, которое должно будет 
  встретиться, прежде чем вы продолжите программу. Вы также можете добавить <B>статический 
  </B> счетчик или какое-то другое устройство, позволяющее циклу опробовать различные 
  подходы, прежде чем сдаться. Этим способом вы можете построить лучший уровень 
  живучести вашей программы.</FONT></P>
<P><FONT FACE="Georgia">Вот что получается на выводе:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>ThreeException
In <font color=#0000ff>finally</font> clause
No exception
In <font color=#0000ff>finally</font> clause</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Независимо от того, было выброшено исключение или не, 
  предложение <B>finally</B> выполняется всегда.</FONT><A NAME="_Toc375545375"></A><A NAME="_Toc481064726"></A><A NAME="Heading345"></A><FONT FACE = "Verdana"></FONT></P>
<FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Для чего нужно finally?</H3>
</FONT> 
<P><FONT FACE="Georgia">В языках без сборщика мусора <i>и</i> без автоматического 
  <A NAME="Index1098"></A>вызова деструктора </FONT><a href="#fn54">[54]</a><FONT FACE="Georgia">, 
  <B>finally</B> очень важно, потому что оно позволяет программисту гарантировать 
  освобождение памяти независимо от того, что случилось в блоке <A NAME="Index1099"></A><A NAME="Index1100"></A><B>try</B>. 
  Но Java имеет сборщик мусора, так что освобождение памяти, фактически, не является 
  проблемой. Также, язык не имеет деструкторов для вызова. Так что, когда вам 
  нужно использовать <A NAME="Index1101"></A><B>finally</B> в Java?</FONT></P>
<DIV ALIGN="LEFT">
  <P><FONT FACE="Georgia"><B>finally</B> необходимо, когда вам нужно что-то установить, 
    <i>отличное</i> от блока памяти, в его оригинальное состояние. Это очистка 
    определенного вида, такое как открытие файла или сетевого соединения, рисование 
    на экране или даже переключение во внешний мир, как смоделировано в следующем 
    примере:</FONT></P>
</DIV>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c10:OnOffSwitch.java </font>
<font color=#009900>// Почему используется finally?</font>

<font color=#0000ff>class</font> Switch {
  <font color=#0000ff>boolean</font> state = <font color=#0000ff>false</font>;
  <font color=#0000ff>boolean</font> read() { <font color=#0000ff>return</font> state; }
  <font color=#0000ff>void</font> on() { state = <font color=#0000ff>true</font>; }
  <font color=#0000ff>void</font> off() { state = <font color=#0000ff>false</font>; }
} 
<font color=#0000ff>class</font> OnOffException1 <font color=#0000ff>extends</font> Exception {}
<font color=#0000ff>class</font> OnOffException2 <font color=#0000ff>extends</font> Exception {}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> OnOffSwitch {
  <font color=#0000ff>static</font> Switch sw = <font color=#0000ff>new</font> Switch();
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> f() <font color=#0000ff>throws</font> 
    OnOffException1, OnOffException2 {}
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      sw.on();
      <font color=#009900>// Код, который может выбросить исключение...</font>
      f();
      sw.off();
    } <font color=#0000ff>catch</font>(OnOffException1 e) {
      System.err.println(<font color=#004488>"OnOffException1"</font>);
      sw.off();
    } <font color=#0000ff>catch</font>(OnOffException2 e) {
      System.err.println(<font color=#004488>"OnOffException2"</font>);
      sw.off();
    }
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Цель этого примера - убедится, что переключатель выключен, 
  когда <B>main(&#160;)</B> будет завершена, так что <B>sw.off(&#160;)</B> помешена 
  в конце блока проверки и в каждом обработчике исключения. Но возможно, что будет 
  выброшено исключение, которое не будет поймано здесь, так что <B>sw.off(&#160;) 
  будет пропущено. </B> Однако с помощью <B>finally</B> вы можете поместить очищающий 
  код для блока проверки только в одном месте:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"> 
  <PRE><font color=#009900>//: c10:WithFinally.java</font>
<font color=#009900>// Finally гарантирует очистку.</font>

<font color=#0000ff>public</font> <font color=#0000ff>class</font> WithFinally {
  <font color=#0000ff>static</font> Switch sw = <font color=#0000ff>new</font> Switch();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      sw.on();
      <font color=#009900>// </font><font color=#009900>Код, который может выбросить исключение...</font>
      OnOffSwitch.f();
    } <font color=#0000ff>catch</font>(OnOffException1 e) {
      System.err.println(<font color=#004488>"OnOffException1"</font>);
    } <font color=#0000ff>catch</font>(OnOffException2 e) {
      System.err.println(<font color=#004488>"OnOffException2"</font>);
    } <font color=#0000ff>finally</font> {
      sw.off();
    }
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Здесь <B>sw.off(&#160;)</B> была перемещена только в одно 
  место, где она гарантировано отработает не зависимо от того, что случится.</FONT></P>
<P><FONT FACE="Georgia">Даже в случае исключения, не пойманного в этом случае 
  набором предложений <B>catch</B>, <B>finally</B> будет выполнено прежде, чем 
  механизм обработки исключений продолжит поиск обработчика на более высоком уровне:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c10:AlwaysFinally.java</font>
<font color=#009900>// Finally выполняется всегда.</font>

<font color=#0000ff>class</font> FourException <font color=#0000ff>extends</font> Exception {}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> AlwaysFinally {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    System.out.println(
      <font color=#004488>"Entering first try block"</font>);
    <font color=#0000ff>try</font> {
      System.out.println(
        <font color=#004488>"Entering second try block"</font>);
      <font color=#0000ff>try</font> {
        <font color=#0000ff>throw</font> <font color=#0000ff>new</font> FourException();
      } <font color=#0000ff>finally</font> {
        System.out.println(
          <font color=#004488>"finally in 2nd try block"</font>);
      }
    } <font color=#0000ff>catch</font>(FourException e) {
      System.err.println(
        <font color=#004488>"Caught FourException in 1st try block"</font>);
    } <font color=#0000ff>finally</font> {
      System.err.println(
        <font color=#004488>"finally in 1st try block"</font>);
    }
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Вывод этой программы показывает что происходит:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Entering first <font color=#0000ff>try</font> block
Entering second <font color=#0000ff>try</font> block
<font color=#0000ff>finally</font> in 2nd <font color=#0000ff>try</font> block
Caught FourException in 1st <font color=#0000ff>try</font> block
<font color=#0000ff>finally</font> in 1st <font color=#0000ff>try</font> block</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Инструкция <B>finally</B> также будет исполнена в ситуации, 
  когда используются инструкции <B>break</B> и <B>continue</B>. Обратите внимание, 
  что наряду с помеченным <B>break</B> и помеченным <B>continue</B>, <B>finally</B> 
  подавляет необходимость в использовании инструкции <B>goto </B>в Java.</FONT><A NAME="_Toc481064727"></A></P>
<A NAME="Heading346"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Ловушка: потерянное исключение</H3>
</FONT> 
<P><FONT FACE="Georgia">Вообще, реализация исключений Java достаточно выдающееся, 
  но, к сожалению, есть недостаток. Хотя исключения являются индикаторами кризиса 
  в вашей программе и не должны игнорироваться, возможна ситуация, при которой 
  исключение просто <a name="Index1102"></a>потеряется. Это случается при определенной 
  конфигурации использования предложения <A NAME="Index1103"></A><B>finally</B>:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c10:LostMessage.java</font>
<font color=#009900>// Как может быть потеряно исключение.</font>

<font color=#0000ff>class</font> VeryImportantException <font color=#0000ff>extends</font> Exception {
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> <font color=#004488>"A very important exception!"</font>;
  }
}

<font color=#0000ff>class</font> HoHumException <font color=#0000ff>extends</font> Exception {
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> <font color=#004488>"A trivial exception"</font>;
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> LostMessage {
  <font color=#0000ff>void</font> f() <font color=#0000ff>throws</font> VeryImportantException {
    <font color=#0000ff>throw</font> <font color=#0000ff>new</font> VeryImportantException();
  }
  <font color=#0000ff>void</font> dispose() <font color=#0000ff>throws</font> HoHumException {
    <font color=#0000ff>throw</font> <font color=#0000ff>new</font> HoHumException();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
      <font color=#0000ff>throws</font> Exception {
    LostMessage lm = <font color=#0000ff>new</font> LostMessage();
    <font color=#0000ff>try</font> {
      lm.f();
    } <font color=#0000ff>finally</font> {
      lm.dispose();
    }
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Вот что получаем на выходе:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Exception in thread <font color=#004488>"main"</font> A trivial exception
    at LostMessage.dispose(LostMessage.java:21)
    at LostMessage.main(LostMessage.java:29)</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Вы можете видеть, что нет свидетельств о <B>VeryImportantException</B>, 
  которое просто заменилось <B>HoHumException</B> в предложении <B>finally</B>. 
  Это достаточно серьезная ловушка, так как это означает, что исключения могут 
  быть просто потеряны и далее в более узких и трудно определимых ситуациях, чем 
  показано выше. В отличие от Java, C++ трактует ситуации, в которых второе исключение 
  выбрасывается раньше, чем обработано первое, как ошибку программирования. Надеюсь, 
  что будущие версии Java решат эту проблему (с другой стороны, вы всегда окружаете 
  метод, который выбрасывает исключение, такой как <B>dispose(&#160;)</B>, предложением 
  <B>try-catch</B>).</FONT><A NAME="_Toc375545374"></A><A NAME="_Toc481064728"></A></P>
<A NAME="Heading347"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Ограничения исключений<A NAME="Index1104"></A><A NAME="Index1105"></A></H2>
</FONT>
<P><FONT FACE="Georgia">Когда вы перегружаете метод, вы можете выбросить только 
  те исключения, которые указаны в версии базового класса этого метода. Это полезное 
  ограничение, так как это означает, что код, работающий с базовым классом, будет 
  автоматически работать с любым другим объектом, наследованным от базового класса 
  (конечно, это фундаментальная концепция ООП), включая исключения.</FONT></P>
<P><FONT FACE="Georgia">Этот пример демонстрирует виды налагаемых ограничений 
  (времени компиляции) на исключения:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c10:StormyInning.java</font>
<font color=#009900>// Перегруженные методы могут выбрасывать только те</font>
<font color=#009900>// исключения, которые указаны в версии</font>
<font color=#009900>// базового класса, или унаследованное от</font>
<font color=#009900>// исключения базового класса.</font>

<font color=#0000ff>class</font> BaseballException <font color=#0000ff>extends</font> Exception {}
<font color=#0000ff>class</font> Foul <font color=#0000ff>extends</font> BaseballException {}
<font color=#0000ff>class</font> Strike <font color=#0000ff>extends</font> BaseballException {}

<font color=#0000ff>abstract</font> <font color=#0000ff>class</font> Inning {
  Inning() <font color=#0000ff>throws</font> BaseballException {}
  <font color=#0000ff>void</font> event () <font color=#0000ff>throws</font> BaseballException {
   <font color=#009900>// На самом деле ничего не выбрасывает</font>
  }
  <font color=#0000ff>abstract</font> <font color=#0000ff>void</font> atBat() <font color=#0000ff>throws</font> Strike, Foul;
  <font color=#0000ff>void</font> walk() {} <font color=#009900>// Ничего не выбрасывает</font>
}

<font color=#0000ff>class</font> StormException <font color=#0000ff>extends</font> Exception {}
<font color=#0000ff>class</font> RainedOut <font color=#0000ff>extends</font> StormException {}
<font color=#0000ff>class</font> PopFoul <font color=#0000ff>extends</font> Foul {}

<font color=#0000ff>interface</font> Storm {
  <font color=#0000ff>void</font> event() <font color=#0000ff>throws</font> RainedOut;
  <font color=#0000ff>void</font> rainHard() <font color=#0000ff>throws</font> RainedOut;
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> StormyInning <font color=#0000ff>extends</font> Inning 
    <font color=#0000ff>implements</font> Storm {
  <font color=#009900>// можно добавить новое исключение для</font>
  <font color=#009900>// конструкторов, но вы должны работать</font>
  <font color=#009900>// с базовым исключеним конструктора:</font>
  StormyInning() <font color=#0000ff>throws</font> RainedOut, 
    BaseballException {}
  StormyInning(String s) <font color=#0000ff>throws</font> Foul, 
    BaseballException {}
  <font color=#009900>// Обычный метод должен соответствовать базовому классу:</font>
<font color=#009900>//! void walk() throws PopFoul {} //Ошибка компиляции</font>
  <font color=#009900>// Интерфейс НЕ МОДЕТ добавлять исключения к существующим</font>
  <font color=#009900>// методам базового класса:</font>
<font color=#009900>//! public void event() throws RainedOut {}</font>
  <font color=#009900>// Если метод еще не существует в базовом классе</font>
  <font color=#009900>// исключение допустимо:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> rainHard() <font color=#0000ff>throws</font> RainedOut {}
  <font color=#009900>// Вы можете решить не выбрасывать исключений вообще,</font>
  <font color=#009900>// даже если версия базового класса делает это:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> event() {}
  <font color=#009900>// Перегруженные методы могут выбрасывать</font>
  <font color=#009900>// унаследованные исключения:</font>
  <font color=#0000ff>void</font> atBat() <font color=#0000ff>throws</font> PopFoul {}
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      StormyInning si = <font color=#0000ff>new</font> StormyInning();
      si.atBat();
    } <font color=#0000ff>catch</font>(PopFoul e) {
      System.err.println(<font color=#004488>"Pop foul"</font>);
    } <font color=#0000ff>catch</font>(RainedOut e) {
      System.err.println(<font color=#004488>"Rained out"</font>);
    } <font color=#0000ff>catch</font>(BaseballException e) {
      System.err.println(<font color=#004488>"Generic error"</font>);
    }
    <font color=#009900>// Strike не выбрасывается в унаследованной версии.</font>
    <font color=#0000ff>try</font> {
      <font color=#009900>// Что случится при обратном приведении?</font>
      Inning i = <font color=#0000ff>new</font> StormyInning();
      i.atBat();
      <font color=#009900>// Вы должны ловить исключения от метода</font>
      <font color=#009900>// версии базового класса:</font>
    } <font color=#0000ff>catch</font>(Strike e) {
      System.err.println(<font color=#004488>"Strike"</font>);
    } <font color=#0000ff>catch</font>(Foul e) {
      System.err.println(<font color=#004488>"Foul"</font>);
    } <font color=#0000ff>catch</font>(RainedOut e) {
      System.err.println(<font color=#004488>"Rained out"</font>);
    } <font color=#0000ff>catch</font>(BaseballException e) {
      System.err.println(
        <font color=#004488>"Generic baseball exception"</font>);
    }
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">В <B>Inning</B> вы можете увидеть, что и конструктор, 
  и метод <B>event(&#160;)</B> говорят о том, что они будут выбрасывать исключение, 
  но они не делают этого. Это допустимо, потому что это позволяет вам заставить 
  пользователя ловить любое исключение, которое может быть добавлено и перегруженной 
  версии метода <B>event(&#160;)</B>. Эта же идея применена к <B>абстрактным</B> 
  методам, как видно в <B>atBat(&#160;)</B>.</FONT></P>
<P><FONT FACE="Georgia">Интересен <B>interface Storm</B>, потому что он содержит 
  один метод (<B>event(&#160;)</B>), который определен в <B>Inning</B>, и один 
  метод, которого там нет. Оба метода выбрасывают новый тип исключения: <B>RainedOut</B>. 
  Когда <B>StormyInning</B> <B>расширяет Inning</B> и <B>реализует Storm</B>, 
  вы увидите, что метод <B>event(&#160;)</B> в <B>Storm</B> <i>не может</i> изменить 
  исключение интерфейса <B>event(&#160;)</B> в <B>Inning</B>. Кроме того, в этом 
  есть здравый смысл, потому что, в противном случае, вы никогда не узнаете, что 
  поймали правильную вещь, работая с базовым классом. Конечно, если метод, описанный 
  как <b>интерфейс</b>, не существует в базовом классе, такой как <B>rainHard(&#160;)</B>,<B> 
  </B>то нет проблем, если он выбросит исключения.</FONT></P>
<P><FONT FACE="Georgia">Ограничения для исключений не распространяются на <A NAME="Index1106"></A><A NAME="Index1107"></A>конструкторы. 
  Вы можете видеть в <B>StormyInning</B>, что конструктор может выбросить все, 
  что хочет, не зависимо от того, что выбрасывает конструктор базового класса. 
  Но, так как конструктор базового класса всегда, так или иначе, должен вызываться 
  (здесь автоматически вызывается конструктор по умолчанию), конструктор наследованного 
  класса должен объявить все исключения конструктора базового класса в своей спецификации 
  исключений. Заметьте, что конструктор наследованного класса не может ловить 
  исключения, выброшенные конструктором базового класса.</FONT></P>
<P><FONT FACE="Georgia">Причина того, что <B>StormyInning.walk(&#160;)</B> не 
  будет компилироваться в том, что она выбрасывает исключение, которое <B>Inning.walk(&#160;)</B> 
  не выбрасывает. Если бы это допускалось, то вы могли написать код, вызывающий 
  <B>Inning.walk(&#160;)</B>, и не иметь обработчика для любого исключения, а 
  затем, когда вы заменили объектом класса, унаследованного от <B>Inning</B>, 
  могло начать выбрасываться исключение и ваш код сломался бы. При ограничивании 
  методов наследуемого класса в соответствии со спецификацией исключений методов 
  базового класса замена объектов допустима.</FONT></P>
<P><FONT FACE="Georgia">Перегрузка метода <B>event(&#160;)</B> показывает, что 
  версия метода наследованного класса может не выбрасывать исключение, даже если 
  версия базового класса делает это. Опять таки это хорошо, так как это не нарушит 
  ни какой код, который написан с учетом версии базового класса с выбрасыванием 
  исключения. Сходная логика применима и к <B>atBat(&#160;)</B>, которая выбрасывает 
  <B>PopFoul</B> - исключение, унаследованное от <B>Foul</B>, выбрасываемое версией 
  базового класса в методе <B>atBat(&#160;)</B>. Таким образом, если кто-то напишет 
  код, который работает с классом <B>Inning</B> и вызывает <B>atBat(&#160;)</B>, 
  он должен ловить исключение <B>Foul</B>. Так как <B>PopFoul</B> наследуется 
  от <B>Foul</B>, обработчик исключения также поймает <B>PopFoul</B>.</FONT></P>
<P><FONT FACE="Georgia">Последнее, что нас интересует - это <B>main(&#160;)</B>. 
  Здесь вы можете видеть, что если вы имеете дело с объектом <B>StormyInning</B>, 
  компилятор заставит вас ловить только те исключения, которые объявлены для этого 
  класса, но если вы выполните приведение к базовому типу, то компилятор (что 
  совершенно верно) заставит вас ловить исключения базового типа. Все эти ограничения 
  производят более устойчивый код обработки исключений </FONT><a href="#fn55">[55]</a><FONT FACE="Georgia">.</FONT></P>
<P><FONT FACE="Georgia">Полезно понимать, что хотя спецификация исключений навязываются 
  компилятором во время наследования, спецификация исключений не является частью 
  метода типа, который включает только имя метода и типы аргументов. Поэтому вы 
  не можете перегрузить метод, основываясь на спецификации исключений. Кроме того, 
  только потому, что спецификация исключений существует в версии метода базового 
  класса, это не означает, что она должна существовать в версии метода наследованного 
  класса. Это немного отличается от правил наследования, по которым метод базового 
  класса должен также существовать в наследуемом классе. Есть другая возможность: 
  &#8220;спецификации исключения интерфейса&#8221; для определенного метода может 
  сузиться во время наследования и перегрузки, но он не может расшириться &#8212; 
  это точно противоречит правилам для интерфейса класса при наследовании.</FONT><A NAME="_Toc305628772"></A><A NAME="_Toc312374122"></A><A NAME="_Toc375545376"></A><A NAME="_Toc481064729"></A></P>
<A NAME="Heading348"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Конструкторы<A NAME="Index1108"></A><A NAME="Index1109"></A></H2>
</FONT>
<P><FONT FACE="Georgia">Когда пишете код с исключениями, обычно важно, чтобы вы 
  всегда спрашивали: &#8220;Если случится исключение, будет ли оно правильно очищено?&#8221; 
  Большую часть времени вы этим сохраните, но в конструкторе есть проблемы. Конструктор 
  переводит объект в безопасное начальное состояние, но он может выполнить некоторые 
  операции &#8212; такие как открытие файла &#8212; которые не будут очищены, 
  пока пользователь не закончит работать с объектом и не вызовет специальный очищающий 
  метод. Если вы выбросили исключение из конструктора, это очищающее поведение 
  может не сработать правильно. Это означает, что вы должны быть особенно осторожными 
  при написании конструктора.</FONT></P>
<P><FONT FACE="Georgia">Так как вы только изучили о <A NAME="Index1110"></A><A NAME="Index1111"></A><B>finally</B>, 
  вы можете подумать, что это корректное решение. Но это не так просто, потому 
  что <B>finally </B>выполняет очищающий код <i>каждый раз</i>, даже в ситуации, 
  в которой вы не хотите, чтобы выполнялся очищающий код до тех пор, пока не будет 
  вызван очищающий метод. Таким образом, если вы выполняете очистку в <B>finally</B>, 
  вы должны установить некоторый флаг, когда конструктор завершается нормально, 
  так что вам не нужно ничего делать в блоке <B>finally</B>, если флаг установлен. 
  Потому что это обычно не элегантное решение (вы соединяете ваш код в одном месте 
  с кодом в другом месте), так что лучше попробовать предотвратить выполнение 
  такого рода очистки в <B>finally</B>, если вы не вынуждены это делать.</FONT></P>
<DIV ALIGN="LEFT">
  <P><FONT FACE="Georgia">В приведенном ниже примере класс, называемый <B>InputFile</B>, 
    при создании открывает файл и позволяет вам читать его по одной строке (конвертируя 
    в <B>String</B>). Он использует классы <A NAME="Index1112"></A><A NAME="Index1113"></A><B>FileReader</B> 
    и <A NAME="Index1114"></A><A NAME="Index1115"></A><B>BufferedReader</B> из 
    стандартной библиотеки Java I/O, которая будет обсуждаться в <a href="Chapter11.html">Главе 
    11</a>, но которая достаточно проста, что вы, вероятно, не будете иметь трудностей 
    в понимании основ ее использования:</FONT></P>
</DIV>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c10:Cleanup.java</font>
<font color=#009900>// Уделение внимание на исключение</font>
<font color=#009900>// в конструкторе.</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>class</font> InputFile {
  <font color=#0000ff>private</font> BufferedReader in;
  InputFile(String fname) <font color=#0000ff>throws</font> Exception {
    <font color=#0000ff>try</font> {
      in = 
        <font color=#0000ff>new</font> BufferedReader(
          <font color=#0000ff>new</font> FileReader(fname));
      <font color=#009900>// Другой код, который может выбросить исключение</font>
    } <font color=#0000ff>catch</font>(FileNotFoundException e) {
      System.err.println(
        <font color=#004488>"Could not open "</font> + fname);
      <font color=#009900>// Что не открыто, то не закроется</font>
      <font color=#0000ff>throw</font> e;
    } <font color=#0000ff>catch</font>(Exception e) {
      <font color=#009900>// Все другие исключения должны быть перекрыты</font>
      <font color=#0000ff>try</font> {
        in.close();
      } <font color=#0000ff>catch</font>(IOException e2) {
        System.err.println(
          <font color=#004488>"in.close() unsuccessful"</font>);
      }
      <font color=#0000ff>throw</font> e; <font color=#009900>// Повторное выбрасывание</font>
    } <font color=#0000ff>finally</font> {
      <font color=#009900>// Не закрывайте их здесь!!!</font>
    }
  }
  String getLine() {
    String s;
    <font color=#0000ff>try</font> {
      s = in.readLine();
    } <font color=#0000ff>catch</font>(IOException e) {
      System.err.println(
        <font color=#004488>"readLine() unsuccessful"</font>);
      s = <font color=#004488>"failed"</font>;
    }
    <font color=#0000ff>return</font> s;
  }
  <font color=#0000ff>void</font> cleanup() {
    <font color=#0000ff>try</font> {
      in.close();
    } <font color=#0000ff>catch</font>(IOException e2) {
      System.err.println(
        <font color=#004488>"in.close() unsuccessful"</font>);
    }
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Cleanup {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      InputFile in = 
        <font color=#0000ff>new</font> InputFile(<font color=#004488>"Cleanup.java"</font>);
      String s;
      <font color=#0000ff>int</font> i = 1;
      <font color=#0000ff>while</font>((s = in.getLine()) != <font color=#0000ff>null</font>)
        System.out.println(<font color=#004488>""</font>+ i++ + <font color=#004488>": "</font> + s);
      in.cleanup();
    } <font color=#0000ff>catch</font>(Exception e) {
      System.err.println(
        <font color=#004488>"Caught in main, e.printStackTrace()"</font>);
      e.printStackTrace(System.err);
    }
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Конструктор для <B>InputFile</B> получает аргумент <B>String</B>, 
  который является именем файла, который вы открываете. Внутри блока <B>try</B> 
  создается <B>FileReader</B> с использование имени файла. <B>FileReader</B> не 
  очень полезен до тех пор, пока вы не используете его для создания <B>BufferedReader</B>, 
  с которым вы фактически можете общаться &#8212; обратите внимание, что в этом 
  одна из выгод <B>InputFile</B>, который комбинирует эти два действия.</FONT></P>
<P><FONT FACE="Georgia">Если конструктор <B>FileReader</B> завершится неудачно, 
  он выбросит <A NAME="Index1116"></A><A NAME="Index1117"></A><B>FileNotFoundException</B>, 
  которое должно быть поймано отдельно, потому что это тот случай, когда вам не 
  надо закрывать файл, так как его открытие закончилось неудачно. Любое <i>другое</i> 
  предложение catch должно закрыть файл, потому что он <i>был</i> открыт до того, 
  как произошел вход в предложение catch. (Конечно это ненадежно, если более одного 
  метода могут выбросить <B>FileNotFoundException</B>. В этом случае вы можете 
  захотеть разбить это на несколько блоков <B>try</B>.) Метод <B>close(&#160;)</B> 
  может выбросить исключение, так что он проверяется и ловится, хотя он в блоке 
  другого предложения <B>catch</B> &#8212; это просто другая пара фигурных скобок 
  для компилятора Java. После выполнения локальных операций исключение выбрасывается 
  дальше, потому что конструктор завершился неудачей, и вы не захотите объявить, 
  что объект правильно создан и имеет силу.</FONT></P>
<P><FONT FACE="Georgia">В этом примере, который не использует вышеупомянутую технику 
  флагов, предложение <B>finally</B> определенно это не то место для закрытия 
  файла, так как он будет закрываться всякий раз по завершению конструктора. Так 
  как вы хотим, чтобы файл был открыт для использования все время жизни объекта 
  <B>InputFile</B>, этот метод не подходит.</FONT></P>
<P><FONT FACE="Georgia">Метод <B>getLine(&#160;)</B> возвращает <B>String</B>, 
  содержащую следующую строку файла. Он вызывает <A NAME="Index1118"></A><A NAME="Index1119"></A><B>readLine(&#160;)</B>, 
  который может выбросить исключение, но это исключение ловится, так что <B>getLine(&#160;)</B> 
  не выбрасывает никаких исключений. Одна из проблем разработки <a name="Index1120"></a>исключений 
  заключается в том, обрабатывать ли исключение полностью на этом уровне, обрабатывать 
  ли его частично и передавать то же исключение (или какое-то другое) или просто 
  передавать его дальше. Дальнейшая передача его, в подходящих случаях, может 
  сильно упростить код. Метод <B>getLine(&#160;)</B> превратится в:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>String getLine() <font color=#0000ff>throws</font> IOException {
  <font color=#0000ff>return</font> in.readLine();
}</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Но, конечно, теперь вызывающий код несет ответственность 
  за обработку любого исключения <B>IOException</B>, которое может возникнуть</FONT>.</P>
<P><FONT FACE="Georgia">Метод <B>cleanup(&#160;)</B> должен быть вызван пользователем, 
  когда закончится использование объекта <B>InputFile</B>. Это освободит ресурсы 
  системы (такие как указатель файла), которые используются объектами <B>BufferedReader</B> 
  и/или <B>FileReader</B> </FONT><a href="#fn56">[56]</a><FONT FACE="Georgia">. 
  Вам не нужно делать этого до тех пор, пока вы не закончите работать с объектом 
  <B>InputFile</B>. Вы можете подумать о перенесении такой функциональности в 
  метод <A NAME="Index1121"></A><B>finalize(&#160;)</B>, но как показано в <a href="Chapter04.html">Главе 
  4</a>, вы не можете всегда быть уверены, что будет вызвана <B>finalize(&#160;)</B> 
  (даже если вы <i>можете</i> быть уверены, что она будет вызвана, вы не будете 
  знать <i>когда</i>). Это обратная сторона Java: вся очистка &#8212; отличающаяся 
  от очистки памяти &#8212; не происходит автоматически, так что вы должны информировать 
  клиентского программиста, что он отвечает за это и, возможно, гарантировать 
  возникновение такой очистки с помощью <B>finalize(&#160;)</B>.</FONT></P>
<P><FONT FACE="Georgia">В <B>Cleanup.java</B> <B>InputFile</B> создается для открытия 
  того же исходного файла, который создает программа, файл читается по строкам, 
  а строки нумеруются. Все исключения ловятся в основном в <B>main(&#160;)</B>, 
  хотя вы можете выбрать лучшее решение.</FONT></P>
<P><FONT FACE="Georgia">Польза от этого примера в том, что он показывает вам, 
  почему исключения введены именно в этом месте книги &#8212; вы не можете работать 
  с основами ввода/вывода, не используя исключения. Исключения настолько интегрированы 
  в программирование на Java, особенно потому, что компилятор навязывает их, что 
  вы можете выполнить ровно столько, не зная их, сколько может сделать, работая 
  с ними.</FONT><A NAME="_Toc305593301"></A><A NAME="_Toc305628773"></A><A NAME="_Toc312374124"></A><A NAME="_Toc375545377"></A><A NAME="_Toc481064730"></A></P>
<A NAME="Heading349"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Совпадение исключений<A NAME="Index1122"></A><A NAME="Index1123"></A></H2>
</FONT> 
<P><FONT FACE="Georgia">Когда выброшено исключение, система обработки исключений 
  просматривает &#8220;ближайшие&#8221; обработчики в порядке их записи. Когда 
  он находит совпадение, исключение считается обработанным и дальнейшего поиска 
  не производится.</FONT></P>
<P><FONT FACE="Georgia">Для совпадения исключения не требуется точного соответствия 
  между исключением и его обработчиком. Объект наследованного класса будет совпадать 
  обработчику базового класса, как показано в <A NAME="Index1124"></A><A NAME="Index1125"></A>этом 
  примере:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c10:Human.java</font>
<font color=#009900>// Ловля иерархических исключений.</font>

<font color=#0000ff>class</font> Annoyance <font color=#0000ff>extends</font> Exception {}
<font color=#0000ff>class</font> Sneeze <font color=#0000ff>extends</font> Annoyance {}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Human {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      <font color=#0000ff>throw</font> <font color=#0000ff>new</font> Sneeze();
    } <font color=#0000ff>catch</font>(Sneeze s) {
      System.err.println(<font color=#004488>"Caught Sneeze"</font>);
    } <font color=#0000ff>catch</font>(Annoyance a) {
      System.err.println(<font color=#004488>"Caught Annoyance"</font>);
    }
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Исключение <B>Sneeze</B> будет поймано первым предложением 
  <B>catch</B>, с которым оно совпадает &#8212; конечно, это первое предложение. 
  Конечно, если вы удалите первое предложение catch, оставив только:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>    <font color=#0000ff>try</font> {
      <font color=#0000ff>throw</font> <font color=#0000ff>new</font> Sneeze();
    } <font color=#0000ff>catch</font>(Annoyance a) {
      System.err.println(<font color=#004488>"Caught Annoyance"</font>);
    }</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Код все равно будет работать, потому что он ловит базовый 
  класс <B>Sneeze</B>. Другими словами, <B>catch(Annoyance e)</B> будет ловить 
  <B>Annoyance</B> <I> или любой другой класс, наследованный от него. </I>Это 
  полезно, потому что, если вы решите добавить еще унаследованных исключений в 
  метод, то код клиентского программиста не будет требовать изменений до тех пор, 
  пока клиент ловит исключения базового класса.</FONT></P>
<P><FONT FACE="Georgia">Если вы пробуете &#8220;маскировать&#8221; исключения 
  наследованного класса, помещая первым предложение catch для базового класса, 
  как здесь:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>    <font color=#0000ff>try</font> {
      <font color=#0000ff>throw</font> <font color=#0000ff>new</font> Sneeze();
    } <font color=#0000ff>catch</font>(Annoyance a) {
      System.err.println(<font color=#004488>"Caught Annoyance"</font>);
    } <font color=#0000ff>catch</font>(Sneeze s) {
      System.err.println(<font color=#004488>"Caught Sneeze"</font>);
    }</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">компилятор выдаст вам сообщение об ошибке, так как catch-предложение 
  <B>Sneeze</B> никогда не будет достигнуто.</FONT><A NAME="_Toc312374128"></A><A NAME="_Toc375545378"></A><A NAME="_Toc481064731"></A></P>
<A NAME="Heading350"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Руководство по исключениям<BR>
  <A NAME="Index1126"></A></H3></FONT>
<DIV ALIGN="LEFT">
  <P><FONT FACE="Georgia">Используйте исключения для:</FONT><BR>
  </P></DIV>
<OL>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Исправления проблем и 
    нового вызова метода, который явился причиной исключения.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Исправления вещей и продолжения 
    без повторной попытки метода.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Подсчета какого-то альтернативного 
    результата вместо того, который должен был вычислить метод.</FONT>
  <LI><FONT FACE="Georgia">Выполнения того, что вы можете в текущем контексте 
    и повторного выброса <i>того же</i> исключения в более старший контекст.</FONT>
  <LI><FONT FACE="Georgia">Выполнения того, что вы можете в текущем контексте 
    и повторного выброса <i>другого</i> исключения в более старший контекст.</FONT>
  <LI>Прекращения программы<FONT FACE="Georgia">.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Упрощения. (Если ваша 
    схема исключений делает вещи более сложными, то это приводит к тягостному 
    и мучительному использованию.)</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Создать более безопасные 
    библиотеки и программы. (Для краткосрочной инвестиции - для отладки - и для 
    долгосрочной инвестиции (Для устойчивости приложения).)</FONT><A NAME="_Toc375545379"></A><A NAME="_Toc481064732"></A>
</OL>
<A NAME="Heading351"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Резюме</H2>
</FONT>
<P><FONT FACE="Georgia">Улучшение перекрытия ошибок<A NAME="Index1127"></A> является 
  мощнейшим способом, который увеличивает устойчивость вашего кода. Перекрытие 
  ошибок является фундаментальной концепцией для каждой написанной вами программы, 
  но это особенно важно в Java, где одна из главнейших целей - это создание компонент 
  программ для других. <i>Для создание помехоустойчивой системы каждый компонент 
  должен быть помехоустойчивым</i>.</FONT></P>
<P><FONT FACE="Georgia">Цель обработки исключений в Java состоит в упрощении создания 
  больших, надежных программ при использовании меньшего кода, насколько это возможно, 
  и с большей уверенностью, что ваше приложение не имеет не отлавливаемых ошибок.</FONT></P>
<p>Исключения не ужасно сложны для изучения и это одна из тех особенностей, которая 
  обеспечивает немедленную и значительную выгоду для вашего проекта. К счастью, 
  Java ограничивает все аспекты исключений, так что это гарантирует, что они будут 
  использоваться совместно и разработчиком библиотеки, и клиентским программистом.<A NAME=_Toc375545380></A><a name="_Toc481064733"></a><A NAME="Heading352"></A></p>
<FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Упражнения</H2>
</FONT><DIV ALIGN="LEFT">
  <P><font face="Georgia" size=2>Решения для выбранных упражнений могут быть найдены 
    в электронной документации <i>The Thinking in Java Annotated Solution Guide</i>, 
    доступной за малую плату на <i>www.BruceEckel.com</i>.</font></P>
</DIV>
<OL>
  <LI><FONT FACE="Georgia">Создайте класс с <B>main(&#160;)</B>, который выбрасывает 
    объект, класса <B>Exception</B> внутри блока <B>try</B>. Передайте конструктору 
    <B>Exception</B> аргумент <B>String</B>. Поймайте исключение внутри предложение 
    <B>catch</B> и напечатайте аргумент <B>String</B>. Добавьте предложение <B>finally</B> 
    и напечатайте сообщение, чтобы убедится, что вы были там.</FONT> 
  <LI><FONT FACE="Georgia">Создайте ваш собственный класс исключений, используя 
    ключевое слово <B>extends</B>. Напишите конструктор для этого класса, который 
    принимает аргумент <B>String</B>, и хранит его внутри объекта в ссылке <B>String</B>. 
    Напишите метод, который печатает хранящийся <B>String</B>. Создайте предложение 
    <B>try-catch</B> для наблюдения своего собственного исключения.</FONT> 
  <LI><FONT FACE="Georgia">Напишите класс с методом, который выбрасывает исключение 
    типа, созданного в Упражнении 2. Попробуйте откомпилировать его без спецификации 
    исключения, чтобы посмотреть, что скажет компилятор. Добавьте соответствующую 
    спецификацию исключения. Испытайте ваш класс и его исключение в блоке try-catch.</FONT> 
  <LI>Определите ссылку на объект и инициализируйте ее значением <FONT FACE="Georgia"> 
    <B>null</B>. Попробуйте вызвать метод по этой ссылке. Не окружайте код блоком 
    <B>try-catch</B>, чтобы поймать исключение.</FONT>
  <LI><FONT FACE="Georgia">Создайте класс с двумя методами <B>f(&#160;)</B> и 
    <B>g(&#160;)</B>. В<B> g(&#160;)</B> выбросите исключение нового типа, который 
    вы определили. В <B>f(&#160;)</B> вызовите <B>g(&#160;)</B>, поймайте его 
    исключение и, в предложении <B>catch</B>, выбросите другое исключение (второго 
    определенного вами типа). Проверьте ваш код в <B>main(&#160;)</B>.</FONT> 
  <LI><FONT FACE="Georgia">Создайте три новых типа исключений. Напишите класс 
    с методом, который выбрасывает все три исключения. В <B>main(&#160;)</B> вызовите 
    метод, но используйте только единственное предложение <B>catch</B>, которое 
    будет ловить все три вида исключений.</FONT>
  <LI>
  <FONT FACE="Georgia">Напишите код для генерации и поимки <B>ArrayIndexOutOfBoundsException</B>. 
  <LI>Создайте свое собственное поведение по типу возобновления, используя цикл 
    <B>while</B>, который будет повторяться, пока исключение больше не будет выбрасываться. 
  </FONT>
  <LI><FONT FACE="Georgia">Создайте трехуровневую иерархию исключений. Теперь 
    создайте базовый класс <B>A</B>, с методом, который выбрасывает исключение 
    базового класса вашей иерархии. Наследуйте <B>B</B> от <B>A</B> и перегрузите 
    метод так, чтобы он выбрасывал исключение второго уровня в вашей иерархии. 
    Повторите то же самое, унаследовав класс <B>C</B> от <B>B</B>. В <B>main(&#160;)</B> 
    создайте <B>C</B> и приведите его к <B>A</B>, затем вызовите метод.</FONT>
  <LI>Покажите, что конструктор наследуемого класса не может ловить исключения, 
    брошенные конструктором базового класса<FONT FACE="Georgia">.</FONT>
  <LI><FONT FACE="Georgia">Покажите, что <B>OnOffSwitch.java</B> может завершиться 
    неудачей при выбрасывании <B>RuntimeException</B> внутри блока <B>try</B>.</FONT>
  <LI><FONT FACE="Georgia">Покажите, что <B>WithFinally.java</B> не завершится 
    неудачей при выбрасывании <B>RuntimeException</B> в блоке <B>try</B>.</FONT>
  <LI>Измените Упражнение 6, добавив предложение <FONT FACE="Georgia"> <B>finally</B>. 
    Проверьте, что предложение <B>finally</B> выполняется даже, если выбрасывается 
    <B>NullPointerException</B>.</FONT>
  <LI><FONT FACE="Georgia">Создайте пример, в котором вы используете флаг для 
    управления вызовом кода очистки, как описано во втором параграфе под заголовком 
    &#8220;Конструкторы&#8221;.</FONT>
  <LI><FONT FACE="Georgia">Измените <B>StormyInning.java</B>, добавив тип исключения 
    <B>UmpireArgument</B> и метод, который его выбрасывает. Проверьте измененную 
    иерархию.</FONT>
  <LI><FONT FACE="Georgia">Удалите первый catch в <B>Human.java</B> и проверьте, 
    что код все равно компилируется и правильно работает.</FONT>
  <LI>Добавьте второй уровень потерь исключения <FONT FACE="Georgia">в <B>LostMessage.java</B>, 
    так чтобы <B>HoHumException</B> заменялось третьим исключением.</FONT>
  <LI><FONT FACE="Georgia">В <a href="Chapter05.html">Главе 5</a> найдите две 
    программы, называемые <B>Assert.java</B> и измените их, чтобы они выбрасывали 
    свои собственные исключения вместо печать в <B>System.err</B>. Это исключение 
    должно быть внутренним классом, расширяющим <B>RuntimeException</B>.</FONT>
  <LI><FONT FACE="Georgia">Добавьте подходящий набор исключений в <B>c08:GreenhouseControls.java</B>.</FONT>
</OL>
<HR>
<P><A NAME="fn51">[51]</A><FONT FACE="Georgia" SIZE=2> C программист может посмотреть 
  на возвращаемое значение <B>printf(&#160;)</B>, как пример этого.</FONT></P>
<P><A NAME="fn52">[52]</A><FONT FACE="Georgia" SIZE=2> Это значительное улучшение, 
  по сравнению с обработкой исключений в C++, которая не ловит нарушения спецификации 
  исключений до времени выполнения, хотя это не очень полезно.</FONT></P>
<P><A NAME="fn53">[53]</A><FONT FACE="Georgia" SIZE=2> Обработка исключений в 
  C++ не имеет предложения <B>finally</B>, поэтому в C++ освобождение происходит 
  в деструкторах, чтобы завершить такой род очистки.</FONT></P>
<P><A NAME="fn54">[54]</A><FONT FACE="Georgia" SIZE=2> Деструктор - это функция, 
  которая всегда вызывается, когда объект более не используется. Вы всегда знаете 
  точно, где совершен вызов деструктора. C++ имеет автоматический вызов деструктора, 
  но Object Pascal из Delphi версии 1 и 2 не делает этого (что изменяет значение 
  и использование концепции деструкторов в этом языке).</FONT></P>
<P><A NAME="fn55">[55]</A><FONT FACE="Georgia" SIZE=2> ISO C++ добавил сходное 
  ограничение, которое требует, чтобы исключение наследуемого метода были теми 
  же или наследовались от тех же, что и выбрасываемые методом базового класса. 
  Это первый случай, в котором C++ реально способен проверить спецификацию исключений 
  во время компиляции.</FONT></P>
<P><A NAME="fn56">[56]</A><FONT FACE="Georgia" SIZE=2> В C++ <i>деструктор</i> 
  должен это обрабатывать за вас.</FONT></P>
<DIV ALIGN="CENTER">
    <FONT FACE="Verdana" size = "-1">
     </FONT>
  <p><font face="Verdana" size = "-1">[ <a href="Chapter09.html">Предыдущая глава 
    </a> ] [ <a href="SimpleContents.html">Оглавление</a> ] [ <a href="Contents.html">Содержание</a> 
    ] [ <a href="DocIndex.html">Индекс</a> ] [ <a href="Chapter11.html">Следующая 
    глава </a> ]</font></p>
</DIV>

</BODY>

</HTML>
