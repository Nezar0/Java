<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<!--
This document was converted from RTF source: 
By rtftohtml 4.19
See http://www.sunpack.com/RTF
Filename:TIJ2.rtf
Application Directory:c:\TOOLS\RTF2HTML\
Subject:
Author:Bruce Eckel
Operator:Bruce Eckel
Document Comments:
Version Comments:
Comments:
Keywords:
Translation Date:04/24/2000
Translation Time:06:36:24
Translation Platform:Win32
Number of Output files:23
This File:Chapter11.html
SplitDepth=1
SkipNavPanel=1
SkipLeadingToc=1
SkipTrailingToc=1
GenContents=1
GenFrames=1
GenIndex=1
-->
<HEAD lang="en"><META http-equiv="Content-Type" content="text/html; charset=windows-1251">
<TITLE>11: Система ввода/вывода в Java</TITLE>
</HEAD>

<BODY  BGCOLOR="#FFFFFF">
<a href="http://www.MindView.net"> </a><FONT FACE="Verdana" size = "-1"> </FONT> 
<CENTER>
  <H2><FONT FACE="Verdana"> Thinking in Java, 2nd edition, Revision 11</FONT></H2>
  <H3><FONT FACE="Verdana">&copy;2000 by Bruce Eckel</FONT></H3>
  <FONT FACE="Verdana" size = "-1"> </FONT>
  <p><font face="Verdana" size = "-1">[ <a href="Chapter10.html">Предыдущая глава 
    </a> ] [ <a href="SimpleContents.html">Оглавление</a> ] [ <a href="Contents.html">Содержание</a> 
    ] [ <a href="DocIndex.html">Индекс</a> ] [ <a href="Chapter12.html">Следующая 
    глава </a> ]</font></p>
</CENTER>
<p></P>
<A NAME="Chapter_10"></A><A NAME="_Toc375545381"></A><A NAME="_Toc477690731"></A><A NAME="_Toc481064734"></A><A NAME="Heading353"></A><FONT FACE = "Verdana">
<H1 ALIGN="LEFT"> 11: Система ввода/вывода в Java</H1>
</FONT>
<P><FONT FACE="Georgia" SIZE=4>Создание хорошей системы ввода/вывода (I/O) является 
  одной из наиболее сложных задач для разработчиков языка.</FONT></P>
<P><FONT FACE="Georgia">Доказательством этому служит наличие множества различных 
  подходов. Сложность задачи видится в охвате всех возможностей. Не только различный 
  исходный код и виды ввода/вывода, с которыми вы можете общаться (файлы, консоль, 
  сетевые соединения), но так же вам необходимо общаться с ними большим числом 
  способов (последовательный, в случайном порядке, буферный, бинарный, посимвольный, 
  построчный, пословный и т.п.).</FONT></P>
<P><FONT FACE="Georgia">Разработчики библиотеки Java атаковали эту проблему путем 
  создания множества классов. Фактически, существует так много классов для системы 
  ввода/вывода в Java, что это может сначала испугать (по иронии, дизайн ввода/вывода 
  Java I/O на самом деле предотвращает взрыв классов). Также произошли значительные 
  изменения в <a name="Index1128"></a>библиотеке ввода/вывода после версии Java 
  1.0, когда изначально <B>byte</B>-ориентированная библиотека была пополнена 
  <B>char</B>-ориентированными, основанными на Unicode I/O классами. Как результат, 
  есть некоторое количество классов, которые необходимо изучить прежде, чем вы 
  поймете достаточно хорошо картину ввода/вывода Java и ее правильно использовать. 
  Кроме того, достаточно важно понимать историю эволюции библиотеки ввода/вывода, 
  даже если вашей первой реакцией было: &#8220;не надоедайте мне историей, просто 
  покажите мне, как использовать это!&#8221; Проблема в том, что без исторической 
  перспективы вы постоянно будете смущаться некоторыми классами, определяя, когда 
  вы должны, а когда не должны использовать их.</FONT></P>
<P><FONT FACE="Georgia">Эта глава даст вам введение в различные классы ввод/вывода 
  стандартной библиотеки Java и расскажет о том, как их использовать.</FONT><A NAME="_Toc375545382"></A><A NAME="_Toc375545390"></A><A NAME="_Toc481064735"></A></P>
<A NAME="Heading354"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Класс File<A NAME="Index1129"></A><A NAME="Index1130"></A><A NAME="Index1131"></A><A NAME="Index1132"></A><A NAME="Index1133"></A><A NAME="Index1134"></A></H2>
</FONT>
<P><FONT FACE="Georgia">Прежде чем перейти к классам, которые действительно читают 
  и записывают данные в поток, мы посмотрим на утилиты, обеспечивающиеся библиотекой 
  в помощь вам в обработке директории файлов.</FONT></P>
<P><FONT FACE="Georgia">Класс <B>File </B>имеет обманчивое имя &#8212; вы можете 
  подумать, что он ссылается на файл, но это не так. Он может представлять либо 
  <i>имя</i> определенного файла, либо <i>имя</i> набора файлов в директории. 
  Если это набор файлов, вы можете опросить набор с помощью метода <B>list(&#160;)</B>, 
  который вернет массив <B>String</B>. Есть смысл возвращать массив, а не гибкий 
  класс контейнера, потому что число элементов фиксировано, и если вам нужен список 
  другого директория, вы просто создаете другой объект <B>File</B>. Фактически, 
  &#8220;FilePath&#8221; был бы лучшим именем для класса. Этот раздел покажет 
  пример использования этого класса, включая ассоциированный <B>FilenameFilter</B> 
  <B>interface</B>.</FONT><A NAME="_Toc375545391"></A><A NAME="_Toc481064736"></A></P>
<A NAME="Heading355"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Список директории<A NAME="Index1135"></A><A NAME="Index1136"></A></H3>
</FONT>
<P><FONT FACE="Georgia">Предположим, вы хотите получить список директории. Объект 
  <B>File</B> может выдать его двумя способами. Если вы вызовите <B>list(&#160;)</B> 
  без аргументов, вы получите полный список, содержащийся в объекте <B>File</B>. 
  Однако если вы хотите ограничить список, например, если вы хотите получить все 
  файлы с расширением <B>.java</B>, то вам нужно использовать &#8220;фильтр директории&#8221;, 
  который является классом, который определяет, как использовать объект <B>File</B> 
  для отображения.</FONT></P>
<P><FONT FACE="Georgia">Здесь приведен код примера. Обратите внимание, что результат 
  без труда будет храниться (в алфавитном порядке) при использовании метода <B>java.utils.Array.sort(&#160;)</B> 
  и <B>AlphabeticComparator</B>, определенного в <a href="Chapter09.html">Главе 
  9</a>:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c11:DirList.java</font>
<font color=#009900>// Отображение списка директории.</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> DirList {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    File path = <font color=#0000ff>new</font> File(<font color=#004488>"."</font>);
    String[] list;
    <font color=#0000ff>if</font>(args.length == 0)
      list = path.list();
    <font color=#0000ff>else</font> 
      list = path.list(<font color=#0000ff>new</font> DirFilter(args[0]));
    Arrays.sort(list,
      <font color=#0000ff>new</font> AlphabeticComparator());
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; list.length; i++)
      System.out.println(list[i]);
  }
}

<font color=#0000ff>class</font> DirFilter <font color=#0000ff>implements</font> FilenameFilter {
  String afn;
  DirFilter(String afn) { <font color=#0000ff>this</font>.afn = afn; }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> accept(File dir, String name) {
    <font color=#009900>// Получение информации о пути:</font>
    String f = <font color=#0000ff>new</font> File(name).getName();
    <font color=#0000ff>return</font> f.indexOf(afn) != -1;
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Класс <B>DirFilter</B> &#8220;реализует&#8221; <B>interface</B> 
  <B>FilenameFilter</B>. Полезно посмотреть, насколько прост <B>FilenameFilter</B> 
  <B>interface</B>:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>public</font> <font color=#0000ff>interface</font> FilenameFilter {
  <font color=#0000ff>boolean</font> accept(File dir, String name);
}</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Это говорит о том, что этот тип объекта должен обеспечивать 
  метод, называемый <B>accept(&#160;)</B>. Главная цель создания этого класса 
  заключается в обеспечении метода <B>accept(&#160;)</B> для метода <B>list(&#160;)</B>, 
  так как <B>list(&#160;)</B> может выполнять &#8220;обратный вызов&#8221; <B>accept(&#160;)</B> 
  для определения, какое имя файла должно включаться в список. Эта техника часто 
  называется <a name="Index1137"></a><i>обратным вызовом</i> или иногда <a name="Index1138"></a><i>функтором</i> 
  (то есть, <b>DirFilter</b> - это функтор, потому что он выполняет работу по 
  поддержанию метода) или <a name="Index1139"></a><a name="Index1140"></a><i>Командой 
  Заполнения</i>. Потому что <B>list(&#160;)</B> принимает объект <B>FilenameFilter</B> 
  в качестве аргумента, это означает, что вы можете передать объект любого класса, 
  который реализует <B>FilenameFilter</B> для выбора (даже во время выполнения) 
  поведения метода <B>list(&#160;)</B>. Назначение обратного вызова заключается 
  в обеспечении гибкого поведения кода.</FONT></P>
<P><FONT FACE="Georgia"><B>DirFilter</B> показывает, что из-за того, что <b>interface</b> 
  содержит только набор методов, вы не ограничены в написании только этих методов. 
  (Однако вы должны как минимум обеспечить определение для всех методов интерфейса.) 
  В этом случае также создается конструктор <b>DirFilter</b>.</FONT></P>
<P><FONT FACE="Georgia">Метод <B>accept(&#160;)</B> должен принимать объект <b>File</b>, 
  представляющий директорий, в котором находится определенный файл, а <b>String</b> 
  содержит имя этого файла. Вы можете выбрать использовать или игнорировать любой 
  из этих аргументов, но вы, вероятно, как минимум, должны использовать имя файла. 
  Помните, что метод <b>list(&#160;)</b> вызывает метод <b>accept(&#160;)</b> 
  для каждого имени файла в директории, чтобы проверить, какой из них должен быть 
  включен &#8212; на это указывает тип <b>boolean</b> результата, возвращаемого 
  <b>accept(&#160;)</b>.</FONT></P>
<P><FONT FACE="Georgia">Чтобы убедится, что элемент, с которым вы работаете, является 
  всего лишь именем файла и не содержит информации о пути, все, что вам нужно 
  сделать, это получить объект <b>String</b> и создать из него объект <b>File</b>, 
  затем вызвать <b>getName(&#160;)</b>, который отсекает всю информацию о пути 
  (платформонезависимым способом). Затем <b>accept(&#160;)</b> использует метод 
  <a name="Index1141"></a><a name="Index1142"></a><b>indexOf(&#160;)</b> класса 
  <b>String</b>, чтобы убедится, что искомая строка <b>afn</b> присутствует в 
  любом месте имени файла. Если <b>afn</b> найдено в строке, возвращаемым значением 
  является начальный индекс <b>afn</b>, а если не найдено, возвращаемым значением 
  является -1. Имейте в виду, что это простой поиск строк и не имеет &#8220;глобальных&#8221; 
  выражений подстановочных символов, таких как fo?.b?r*&#8221;, которые являются 
  более сложными в реализации.</FONT></P>
<P><FONT FACE="Georgia">Метод <B>list(&#160;)</B> возвращает массив. Вы можете 
  опросить этот массив о его длине, а затем пройтись по нему, выбирая элементы 
  массива. Эта способность легкого прохода по массиву вне методов и в методах 
  является значительным улучшением по сравнению с поведением </FONT><FONT FACE="Georgia"> 
  C и C++.</FONT></P>
<DIV ALIGN="LEFT"></DIV>
<A NAME="Heading356"></A><FONT FACE = "Verdana">
<H4 ALIGN="LEFT"> Анонимные внутренние классы</H4>
</FONT> 
<P><FONT FACE="Georgia">Это пример идеален для того, чтобы быть переписанным с 
  использованием <A NAME="Index1143"></A><A NAME="Index1144"></A><A NAME="Index1145"></A>анонимных 
  внутренних классов (описанных в <a href="Chapter08.html">Главе 8</a>). В качестве 
  первой пробы, создадим метод <B>filter(&#160;)</B>, который возвращает ссылку 
  на <B>FilenameFilter</B>:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c11:DirList2.java</font>
<font color=#009900>// Использование анонимных внутренних классов.</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> DirList2 {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> FilenameFilter 
  filter(<font color=#0000ff>final</font> String afn) {
    <font color=#009900>// Создание анонимного внутреннего класса:</font>
    <font color=#0000ff>return</font> <font color=#0000ff>new</font> FilenameFilter() {
      String fn = afn;
      <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> accept(File dir, String n) {
        <font color=#009900>// Получаем информацию о пути:</font>
        String f = <font color=#0000ff>new</font> File(n).getName();
        <font color=#0000ff>return</font> f.indexOf(fn) != -1;
      }
    }; <font color=#009900>// Конец анонимного внутреннего класса</font>
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    File path = <font color=#0000ff>new</font> File(<font color=#004488>"."</font>);
    String[] list;
    <font color=#0000ff>if</font>(args.length == 0)
      list = path.list();
    <font color=#0000ff>else</font> 
      list = path.list(filter(args[0]));
    Arrays.sort(list,
      <font color=#0000ff>new</font> AlphabeticComparator());
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; list.length; i++)
      System.out.println(list[i]);
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Обратите внимание, что аргумент для <B>filter(&#160;)</B> 
  должен быть <A NAME="Index1146"></A><A NAME="Index1147"></A><B>final</B>. Это 
  требуется анонимному внутреннему классу, так как он использует объект внешней 
  части кода, по отношению к нему.</FONT></P>
<P><FONT FACE="Georgia">Это лучший дизайн, потому что класс <B>FilenameFilter</B> 
  теперь тесно связан с <B>DirList2</B>. Однако вы можете выбрать этот подход 
  на один шаг раньше, и определить анонимный внутренний класс как аргумент <B>list(&#160;)</B>, 
  в этом случае программа будет даже меньше:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c11:DirList3.java</font>
<font color=#009900>// Построение анонимного внутреннего класса "на месте".</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> DirList3 {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(<font color=#0000ff>final</font> String[] args) {
    File path = <font color=#0000ff>new</font> File(<font color=#004488>"."</font>);
    String[] list;
    <font color=#0000ff>if</font>(args.length == 0)
      list = path.list();
    <font color=#0000ff>else</font> 
      list = path.list(<font color=#0000ff>new</font> FilenameFilter() {
        <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> 
        accept(File dir, String n) {
          String f = <font color=#0000ff>new</font> File(n).getName();
          <font color=#0000ff>return</font> f.indexOf(args[0]) != -1;
        }
      });
    Arrays.sort(list,
      <font color=#0000ff>new</font> AlphabeticComparator());
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; list.length; i++)
      System.out.println(list[i]);
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Теперь аргумент у <B>main(&#160;)</B> является <B>final</B>, 
  так как анонимный внутренний класс напрямую использует <B> args[0]</B>.</FONT></P>
<P><FONT FACE="Georgia">Здесь показано как анонимный внутренний класс позволяет 
  создать быстрые и грязные классы для решения проблемы. Так как все в Java вертится 
  вокруг классов, это может быть полезной техникой написания программ. Одна из 
  выгод в том, что программа содержит код, который решает определенную проблему, 
  изолированную в одном месте. С другой стороны, это не всегда легче для чтения, 
  так что вы должны использовать это с умом.</FONT><A NAME="_Toc375545392"></A><A NAME="_Toc481064737"></A></P>
<A NAME="Heading357"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Поиск и создание директориев</H3>
</FONT> 
<P><FONT FACE="Georgia">Класс <B>File</B> - это больше, чем просто представление 
  существующего файла или директория. Вы также можете использовать объект <B>File</B> 
  для создания новой <A NAME="Index1148"></A><A NAME="Index1149"></A>директории 
  или целого пути директорий, если этот путь не существует. Вы можете также взглянуть 
  на <A NAME="Index1150"></A><A NAME="Index1151"></A>характеристики файлов (размер, 
  дату последней модификации, доступ на чтение/запись), посмотреть, представляет 
  ли объект <B>File</B> файл или директорий, и удалить файл. Эта программа показывает 
  некоторые методы, поддерживаемые классом <B>File</B> (смотрите HTML документацию 
  на <I>java.sun.com </I> чтобы увидеть полный набор):</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c11:MakeDirectories.java</font>
<font color=#009900>// Демонстрация использования класса File</font>
<font color=#009900>// для создания и манипулирования файлами.</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> MakeDirectories {
  <font color=#0000ff>private</font> <font color=#0000ff>final</font> <font color=#0000ff>static</font> String usage =
    <font color=#004488>"Usage:MakeDirectories path1 ...\n"</font> +
    <font color=#004488>"Creates each path\n"</font> +
    <font color=#004488>"Usage:MakeDirectories -d path1 ...\n"</font> +
    <font color=#004488>"Deletes each path\n"</font> +
    <font color=#004488>"Usage:MakeDirectories -r path1 path2\n"</font> +
    <font color=#004488>"Renames from path1 to path2\n"</font>;
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> usage() {
    System.err.println(usage);
    System.exit(1);
  }
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> fileData(File f) {
    System.out.println(
      <font color=#004488>"Absolute path: "</font> + f.getAbsolutePath() +
      <font color=#004488>"\n Can read: "</font> + f.canRead() +
      <font color=#004488>"\n Can write: "</font> + f.canWrite() +
      <font color=#004488>"\n getName: "</font> + f.getName() +
      <font color=#004488>"\n getParent: "</font> + f.getParent() +
      <font color=#004488>"\n getPath: "</font> + f.getPath() +
      <font color=#004488>"\n length: "</font> + f.length() +
      <font color=#004488>"\n lastModified: "</font> + f.lastModified());
    <font color=#0000ff>if</font>(f.isFile())
      System.out.println(<font color=#004488>"it's a file"</font>);
    <font color=#0000ff>else</font> <font color=#0000ff>if</font>(f.isDirectory())
      System.out.println(<font color=#004488>"it's a directory"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>if</font>(args.length &lt; 1) usage();
    <font color=#0000ff>if</font>(args[0].equals(<font color=#004488>"-r"</font>)) {
      <font color=#0000ff>if</font>(args.length != 3) usage();
      File 
        old = <font color=#0000ff>new</font> File(args[1]),
        rname = <font color=#0000ff>new</font> File(args[2]);
      old.renameTo(rname);
      fileData(old);
      fileData(rname);
      <font color=#0000ff>return</font>; <font color=#009900>// Выход из main</font>
    }
    <font color=#0000ff>int</font> count = 0;
    <font color=#0000ff>boolean</font> del = <font color=#0000ff>false</font>;
    <font color=#0000ff>if</font>(args[0].equals(<font color=#004488>"-d"</font>)) {
      count++;
      del = <font color=#0000ff>true</font>;
    }
    <font color=#0000ff>for</font>( ; count &lt; args.length; count++) {
      File f = <font color=#0000ff>new</font> File(args[count]);
      <font color=#0000ff>if</font>(f.exists()) {
        System.out.println(f + <font color=#004488>" exists"</font>);
        <font color=#0000ff>if</font>(del) {
          System.out.println(<font color=#004488>"deleting..."</font> + f);
          f.delete();
        }
      } 
      <font color=#0000ff>else</font> { <font color=#009900>// Не существует</font>
        <font color=#0000ff>if</font>(!del) {
          f.mkdirs();
          System.out.println(<font color=#004488>"created "</font> + f);
        }
      }
      fileData(f);
    }  
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">В <B>fileData(&#160;)</B> вы можете видеть различные способы 
  исследования файла для отображения информации о файле или о пути директории.</FONT></P>
<P><FONT FACE="Georgia">Первый метод, который вызывается <b>main(&#160;)</b> - 
  это <a name="Index1152"></a><a name="Index1153"></a><b>renameTo(&#160;)</b>, 
  который позволяет вам переименовать (или переместить) файл по введенному новому 
  путь, представленному аргументом, который является другим объектом типа <b>File</b>. 
  Это так же работает с директориями любой длины.</FONT></P>
<P><FONT FACE="Georgia">Если вы поэкспериментируете с приведенной выше программой, 
  вы обнаружите, что вы можете создать путь директорий любой сложности, потому 
  что <A NAME="Index1154"></A><A NAME="Index1155"></A><B>mkdirs(&#160;)</B> будет 
  делать всю работу за вас.</FONT><A NAME="_Toc481064738"></A></P>
<DIV ALIGN="LEFT"></DIV>
<A NAME="Heading358"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Ввод и вывод<A NAME="Index1156"></A><A NAME="Index1157"></A><A NAME="Index1158"></A><A NAME="Index1159"></A><A NAME="Index1160"></A><A NAME="Index1161"></A><A NAME="Index1162"></A><A NAME="Index1163"></A><A NAME="Index1164"></A><A NAME="Index1165"></A><A NAME="Index1166"></A><A NAME="Index1167"></A><A NAME="Index1168"></A><A NAME="Index1169"></A><A NAME="Index1170"></A></H2>
</FONT>
<P><FONT FACE="Georgia">Библиотеки ввода/вывода часто используют абстракцию потока, 
  который представляется любым источником данных или представляется как объект, 
  способный производить или принимать кусочки данных. Поток прячет детали того, 
  что случается с данными внутри реального устройства ввода/вывода.</FONT></P>
<P><FONT FACE="Georgia">Библиотечные классы Java для ввода/вывода делятся на классы 
  ввода и вывода, как вы можете увидеть, взглянув на иерархию Java классов в онлайн 
  документации с помощью вашего Web броузера. При наследовании, все, что наследуется 
  от классов <b>InputStream</b> или <b>Reader</b>, имеет основной метод, называемый 
  <b>read(&#160;) </b>для чтения единичного байта или массива байт. Точно так 
  же, все, что наследуется от классов <b>OutputStream </b>или <b>Writer</b>, имеет 
  основной метод, называемый <b>write(&#160;) </b>для записи единичного байта 
  или массива байт. Однако чаще всего вы не можете использовать эти методы; они 
  существуют для того, чтобы другие классы могли использовать их &#8212; эти другие 
  классы обеспечивают более полезные интерфейсы. Таким образом, вы редко будете 
  создавать ваш объект потока, используя единственный класс, вместо этого вы будите 
  располагать множеством объектом для обеспечения желаемой функциональности. Факт 
  в том что вы создаете более, чем один объект для создания единственного результирующего 
  потока, это главная причина, по которой потоки Java являются запутанными.</FONT></P>
<P>Полезно распределить классы по категориям, исходя из их функциональности. <FONT FACE="Georgia"> 
  В Java 1.0 разработчики библиотеки начали с решения, что все классы, которые 
  могут что-то делать с вводом, должны наследоваться от <B>InputStream</B>, а 
  все классы, которые ассоциируются с выводом, должны наследоваться от <B>OutputStream</B>.</FONT><A NAME="_Toc375545383"></A><A NAME="_Toc481064739"></A></P>
<A NAME="Heading359"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Типы InputStream</H3>
</FONT>
<P><FONT FACE="Georgia">Работа <B>InputStream</B> состоит в представлении классов, 
  которые производят ввод от различных источников. Источниками могут быть:</FONT></P>
<OL>
  <LI><FONT FACE="Georgia">Массив байт.</FONT> 
  <LI><FONT FACE="Georgia">Объект <B>String</B>.</FONT> 
  <LI><FONT FACE="Georgia">Файл.</FONT> 
  <LI><FONT FACE="Georgia">&#8220;Труба&#8221;, которая работает так же, как и 
    физическая <a name="Index1171"></a><a name="Index1172"></a>труба: вы помещаете 
    вещи в один конец, а они выходят из другого.</FONT> 
  <LI><FONT FACE="Georgia">Последовательность других потоков, так что вы можете 
    собрать их вместе в единый поток<font face="Georgia"></font>.</FONT>
  <LI><FONT FACE="Georgia">Другие источники, такие как Internet соединение. (Это 
    будет обсуждено в одной из следующих глав.)</FONT>
</OL>
<P><FONT FACE="Georgia">Каждый из них имеет ассоциированный подкласс <B>InputStream</B>. 
  Кроме того, <B>FilterInputStream</B> также имеет тип <B>InputStream</B>, для 
  обеспечения базового класса для "декоративных" классов, которые присоединяют 
  атрибуты или полезные интерфейсы для входного потока. Это будет обсуждаться 
  дальше.</FONT></P>
<P><FONT FACE="Georgia"><B>Таблица 11-1. Типы InputStream<A NAME="Index1173"></A><A NAME="Index1174"></A><A NAME="Index1175"></A><A NAME="Index1176"></A><A NAME="Index1177"></A><A NAME="Index1178"></A><A NAME="Index1179"></A><A NAME="Index1180"></A><A NAME="Index1181"></A><A NAME="Index1182"></A><A NAME="Index1183"></A><A NAME="Index1184"></A><A NAME="Index1185"></A><A NAME="Index1186"></A><A NAME="Index1187"></A><A NAME="Index1188"></A><A NAME="Index1189"></A><A NAME="Index1190"></A><A NAME="Index1191"></A><A NAME="Index1192"></A></B></FONT></P>
<TABLE BORDER width="100%">
  <TR VALIGN="TOP"> 
    <TH WIDTH=99 COLSPAN=1 ROWSPAN=1 VALIGN="TOP"> <FONT FACE="Georgia"><B>Класс</B></FONT></TH>
    <TH WIDTH=108 COLSPAN=1 ROWSPAN=1 VALIGN="TOP"> <FONT FACE="Georgia"><B>Функция</B></FONT></TH>
    <TH WIDTH=153 COLSPAN=1 ROWSPAN=1 VALIGN="TOP"> <FONT FACE="Georgia"><B>Аргументы 
      конструктора </B></FONT></TH>
  </TR>
  <TR VALIGN="TOP"> 
    <TH WIDTH=153 COLSPAN=1 ROWSPAN=1 VALIGN="TOP"> <FONT FACE="Georgia"><B>Как 
      его использовать</B></FONT></TH>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>ByteArray-InputStream</B></FONT><BR>
    </TD>
    <TD> <FONT FACE="Georgia">Позволяет использовать буфер в памяти в качестве 
      <B>InputStream</B></FONT></TD>
    <TD> <FONT FACE="Georgia">Буфер, их которого извлекаются байты.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia">Как источник данных. Соединить его с объектом <B>FilterInputStream</B> 
      для обеспечения полезного интерфейса.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>StringBuffer-InputStream</B></FONT></TD>
    <TD> <FONT FACE="Georgia">Конвертирует <B>String</B> в <B>InputStream</B></FONT></TD>
    <TD> <FONT FACE="Georgia"> <B>String</B>. Лежащая в основе реализация на самом 
      деле использует <B>StringBuffer</B>.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia">Как источник данных. Соединить его с объектом <b>FilterInputStream</b> 
      для обеспечения полезного интерфейса.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>File-InputStream</B></FONT></TD>
    <TD> <FONT FACE="Georgia">Для чтения информации из файла.</FONT></TD>
    <TD> <FONT FACE="Georgia"> <B>String</B>, представляющий имя файла, или объекты 
      <B>File</B> или <B>FileDescriptor</B>.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <font face="Georgia">Как источник данных. Соединить его с объектом <b>FilterInputStream</b> 
      для обеспечения полезного интерфейса.</font></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>Piped-InputStream</B></FONT><BR>
    </TD>
    <TD> <FONT FACE="Georgia">Производит данные, которые были записаны в ассоциированный 
      <B>PipedOutput</B>-<B>Stream</B>. Реализует концепцию &#8220;трубопровода&#8221;.</FONT></TD>
    <TD> <FONT FACE="Georgia"><B>PipedOutputStream</B></FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> Как источник данных при нескольких нитях процессов. <font face="Georgia">Соединить 
      его с объектом <b>FilterInputStream</b> для обеспечения полезного интерфейса.</font></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>Sequence-InputStream</B></FONT></TD>
    <TD> <FONT FACE="Georgia">Преобразует два или более объектов <B>InputStream</B> 
      в единый <B>InputStream</B>.</FONT></TD>
    <TD> <FONT FACE="Georgia">Два объекта <B>InputStream</B> или <B>Enumeration</B> 
      для контейнера из <B>InputStream</B>.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD><font face="Georgia">Как источник данных. Соединить его с объектом <b>FilterInputStream</b> 
      для обеспечения полезного интерфейса.</font> </TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>Filter-InputStream</B></FONT><BR>
    </TD>
    <TD> <FONT FACE="Georgia">Абстрактный класс, который является интерфейсом 
      для декоратора, который обеспечивает полезную функциональность для других 
      классов <B>InputStream</B>. Смотрите таблицу11-3.</FONT></TD>
    <TD> <FONT FACE="Georgia">Смотрите таблицу 11-3.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia">Смотрите таблицу 11-3.</FONT></TD>
  </TR>
  <A NAME="_Toc375545385"></A><A NAME="_Toc481064740"></A>
</TABLE>
<p></P>
<A NAME="Heading360"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Типы OutputStream<A NAME="Index1193"></A><A NAME="Index1194"></A></H3>
</FONT>
<P><FONT FACE="Georgia">Эта категория включает классы, которые решают, куда будет 
  производиться вывод: в массив байт (но не <B>String</B>; возможно, вы можете 
  создать его, используя массив байт), в файл, или в &#8220;трубу&#8221;.</FONT> 
</P>
<P><FONT FACE="Georgia">Кроме того, <B>FilterOutputStream</B> обеспечивает базовый 
  класс для "декорирования" классов, которые присоединяют атрибуты или полезные 
  интерфейсы для выходного потока. Это будет обсуждаться позже.</FONT></P>
<P><FONT FACE="Georgia"><B>Таблица 11-2. Типы OutputStream<A NAME="Index1195"></A><A NAME="Index1196"></A><A NAME="Index1197"></A><A NAME="Index1198"></A><A NAME="Index1199"></A><A NAME="Index1200"></A><A NAME="Index1201"></A><A NAME="Index1202"></A></B></FONT></P>
<TABLE BORDER width="100%">
  <TR VALIGN="TOP"> 
    <TH WIDTH=407 COLSPAN=1 ROWSPAN=1 VALIGN="TOP"> <FONT FACE="Georgia"><B>Класс</B></FONT></TH>
    <TH WIDTH=187 COLSPAN=1 ROWSPAN=1 VALIGN="TOP"> <FONT FACE="Georgia"><B>Функция</B></FONT></TH>
    <TH WIDTH=147 COLSPAN=1 ROWSPAN=1 VALIGN="TOP"> <FONT FACE="Georgia"><B>Аргументы 
      конструктора</B></FONT></TH>
  </TR>
  <TR VALIGN="TOP"> 
    <TH WIDTH=407 COLSPAN=1 ROWSPAN=1 VALIGN="TOP"> <FONT FACE="Georgia"><B>Как 
      его использовать</B></FONT></TH>
  </TR>
  <TR VALIGN="TOP"> 
    <TD width="407"> <FONT FACE="Georgia"><B>ByteArray-OutputStream</B></FONT></TD>
    <TD width="187"> <FONT FACE="Georgia">Создает буфер в памяти. Все данные, 
      которые вы будете посылать в поток, помещаются в этот буфер.</FONT></TD>
    <TD width="147"> <FONT FACE="Georgia">необязательный начальный размер буфера.</FONT><BR>
    </TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD width="407"> <FONT FACE="Georgia">Для определения места назначения ваших 
      данных. Соедините его с объектом <B>FilterOutputStream</B> для обеспечения 
      полезного интерфейса.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD width="407"> <FONT FACE="Georgia"><B>File-OutputStream</B></FONT></TD>
    <TD width="187"> <FONT FACE="Georgia">Для отсылки информации в файл.</FONT></TD>
    <TD width="147"> <FONT FACE="Georgia">Строка, представляющая имя файла, или 
      объекты <B>File</B> или <B>FileDescriptor</B>.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD width="407"><font face="Georgia">Для определения места назначения ваших 
      данных. Соедините его с объектом <b>FilterOutputStream</b> для обеспечения 
      полезного интерфейса.</font></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD width="407"> 
      <DIV ALIGN="LEFT">
        <P><FONT FACE="Georgia"><B>Piped-OutputStream</B></FONT><BR>
        </P>
      </DIV>
    </TD>
    <TD width="187"> <FONT FACE="Georgia">Любая информация, записанная сюда, автоматически 
      становится вводом ассоциированного <B>PipedInput-Stream</B>. Реализует концепцию 
      &#8220;трубопровода&#8221;.</FONT></TD>
    <TD width="147"> <FONT FACE="Georgia"><B>PipedInputStream</B></FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD width="407"> <FONT FACE="Georgia">Для определения назначения ваших данных 
      со многими нитями процессов. Соедините его с объектом <b>FilterOutputStream</b> 
      для обеспечения полезного интерфейса.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD width="407"> <FONT FACE="Georgia"><B>Filter-OutputStream</B></FONT></TD>
    <TD width="187"> <FONT FACE="Georgia">Абстрактный класс, который является 
      интерфейсом для декоратора, который обеспечивает полезную функциональность 
      другим классам <B>OutputStream</B>. Смотрите Таблицу 11-4.</FONT></TD>
    <TD width="147"> <FONT FACE="Georgia">Смотрите Таблицу 11-4.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD width="407"> <FONT FACE="Georgia">Смотрите Таблицу 11-4.</FONT></TD>
  </TR>
  <A NAME="_Toc375545386"></A><A NAME="_Toc481064741"></A>
</TABLE>
<p></P>
<A NAME="Heading361"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Добавление атрибутов и полезных интерфейсов</H2>
</FONT> 
<P><FONT FACE="Georgia">Использование многослойных объектов для динамического 
  и прозрачного добавления ответственности индивидуальным объектам, называется 
  <a name="Index1203"></a><a name="Index1204"></a>шаблоном декорации. (Шаблоны 
  <a href="#fn57">[57]</a> являются предметом обсуждения <i>Thinking in Patterns 
  with Java</i>, доступной на <i>www.BruceEckel.com</i>.) Шаблон декорации определяет, 
  что все объекты, которые крутятся вокруг вашего начального объекта, имеют один 
  и тот же интерфейс. Это делает основное использование декораторов прозрачным 
  &#8212; вы посылаете объекту одни и те же с сообщения не зависимо от того, был 
  он декорирован или нет. Это причина существования &#8220;фильтрующих&#8221; 
  классов в библиотеке ввода/вывода в Java: абстрактный &#8220;фильтрующий&#8221; 
  класс - это базовый класс для всех декораторов. (Декоратор должен иметь такой 
  же интерфейс, что и объект, который он декорирует, но декоратор так же может 
  расширить интерфейс, что случается в некоторых &#8220;фильтрующих&#8221; классах.</FONT></P>
<P><FONT FACE="Georgia">Декорирование часто используется, когда простое использование 
  подклассов в результате приводит к большому числу подклассов, способных удовлетворить 
  каждую возможную необходимую комбинацию, что становится непрактично. Библиотека 
  ввода/вывода Java требует много различных комбинаций особенностей, которые являются 
  причиной использования шаблона декоратора. Однако для шаблона декоратора есть 
  препятствие. Декораторы дают вам много больше гибкости, когда вы пишите программу 
  (так как вы можете легко смешивать и сравнивать атрибуты), но они привносят 
  сложность в ваш код. Причина того, что библиотека Java неудобна в использовании, 
  состоит в том, что вы должны создавать много классов &#8212; &#8220;центральные&#8221; 
  типы ввода/вывода, плюс все декораторы &#8212; для того, чтобы создать единственный 
  объект ввода/вывода, который вам нужен.</FONT></P>
<P><FONT FACE="Georgia">К классам, обеспечивающим интерфейс декоратора для управления 
  определенным <b>InputStream</b> или <b>OutputStream</b>, относятся <b>FilterInputStream</b> 
  и <b>FilterOutputStream</b> &#8212; которые не имеют интуитивно понятных имен. 
  <b>FilterInputStream</b> и <b>FilterOutputStream</b> являются абстрактными классами, 
  наследованными от базовых классов библиотеки ввода/вывода <b>InputStream</b> 
  и <b>OutputStream</b>, которые являются ключевым требованием декоратора (так 
  как он обеспечивает общий интерфейс для всех объектов, которые будут декорироваться)</FONT><FONT FACE="Georgia">.</FONT><A NAME="_Toc375545387"></A><A NAME="_Toc481064742"></A></P>
<A NAME="Heading362"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Чтение из InputStream с помощью FilterInputStream</H3>
</FONT> 
<P><FONT FACE="Georgia">Классы <B>FilterInputStream</B> совершают две значительные 
  вещи. <b>DataInputStream</b> позволяет вам читать различные типы примитивных 
  данных, наряду с объектами типа <b>String</b>. (Все методы начинаются со слова 
  &#8220;read&#8221;, например: <b>readByte(&#160;)</b>, <b>readFloat(&#160;)</b>, 
  и т.п.) Таким образом, наряду со своим компаньоном <b>DataOutputStream</b>, 
  это позволяет вам перемещать примитивные данные из одного места в другое через 
  поток. Эти &#8220;места&#8221; определяются классами в таблице 11-1.</FONT></P>
<P><FONT FACE="Georgia">Оставшиеся классы изменяют способ внутреннего поведения 
  <b>InputStream</b>: будет ли он буферизированный или нет, будет ли он хранить 
  историю прочитанных строк (позволяя вам спрашивать номер строки или множества 
  номеров строк), и сможете ли вы поместить назад единичный символ. Последние 
  два класса выглядят так, как будто они предназначены для поддержки работы компилятора 
  (то есть, они были добавлены для поддержки конструкций Java компилятора), так 
  что вы, вероятно, не захотите использовать их в обычном программировании.</FONT></P>
<P><FONT FACE="Georgia">Вероятно, вам необходимо будет буферизировать ваш ввод 
  почти каждый раз, в зависимости от устройства ввода/вывода, к которому вы подсоединяетесь, 
  так что имеет больше смысла для библиотеки ввода/вывода сделать особый случай 
  (или простой вызов метода) для не буферизированного ввода, в отличие от буферизированного 
  ввода.</FONT></P>
<P><FONT FACE="Georgia"><B>Таблица 11-3. Типы FilterInputStream<A NAME="Index1205"></A><A NAME="Index1206"></A><A NAME="Index1207"></A><A NAME="Index1208"></A><A NAME="Index1209"></A><A NAME="Index1210"></A><A NAME="Index1211"></A><A NAME="Index1212"></A></B></FONT></P>
<TABLE BORDER width="100%">
  <TR VALIGN="TOP"> 
    <th> <FONT FACE="Georgia"><B>Класс</B></FONT></th>
    <th> <FONT FACE="Georgia"><B>Функция</B></FONT></th>
    <th> <FONT FACE="Georgia"><B>Аргументы конструктора</B></FONT></th>
  </TR>
  <TR VALIGN="TOP"> 
    <th> <FONT FACE="Georgia"><B>Как его использовать</B></FONT></th>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>Data-InputStream</B></FONT></TD>
    <TD> <FONT FACE="Georgia">Используется в согласии с <B>DataOutputStream</B>, 
      так что вы можете читать примитивные типы (<B>int</B>, <B>char</B>, <B>long</B>, 
      и т.п.) из потока портативным способом.</FONT></TD>
    <TD> <FONT FACE="Georgia"><B>InputStream</B></FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia">Содержит полный интерфейс, чтобы позволить вам читать 
      примитивные типы.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>Buffered-InputStream</B></FONT></TD>
    <TD> <FONT FACE="Georgia">Используйте это для предотвращения физического чтения 
      каждый раз, когда вам необходимы дополнительные данные. Вы говорить &#8220;Использовать 
      буфер&#8221;.</FONT></TD>
    <TD> <FONT FACE="Georgia"><B>InputStream</B> с необязательным размером буфера.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><i>Сам по себе</i> не обеспечивает интерфейс, просто 
      требует, чтобы использовался буфер. Присоединяет объект интерфейса.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>LineNumber-InputStream</B></FONT></TD>
    <TD> <FONT FACE="Georgia">Сохраняет историю номеров строк входного потока; 
      вы можете вызвать <B>getLineNumber(&#160;)</B> и <B>setLineNumber(</B></FONT><BR>
      <FONT FACE="Georgia"><B>int)</B>.</FONT></TD>
    <TD> <FONT FACE="Georgia"><B>InputStream</B></FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia">Это просто добавляет нумерацию строк, так что вы, 
      вероятно, присоедините объект интерфейса.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>Pushback-InputStream</B></FONT></TD>
    <TD> <FONT FACE="Georgia">Имеет буфер для возврата одного символа, так что 
      вы можете поместить обратно один прочитанный символ.</FONT></TD>
    <TD> <FONT FACE="Georgia"><B>InputStream</B></FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia">Обычно используется в сканерах для компилятора и, 
      вероятно, включено потому, что Java компилятор нуждается в нем. Вы, вероятно, 
      не захотите использовать его.</FONT></TD>
  </TR>
  <A NAME="_Toc375545388"></A><A NAME="_Toc481064743"></A>
</TABLE>
<p></P>
<A NAME="Heading363"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Запись в OutputStream с помощью FilterOutputStream</H3>
</FONT> 
<P><FONT FACE="Georgia">Дополнением к <B>DataInputStream</B> является <B>DataOutputStream</B>, 
  который форматирует каждый из примитивных типов и объекты <b>String</b> в поток, 
  таким образом, которым любой <b>DataInputStream</b> на любой машине смог бы 
  прочесть его. Все методы начинаются со слова &#8220;write&#8221;, например <b>writeByte(&#160;)</b>, 
  <b>writeFloat(&#160;)</b> и т.п.</FONT></P>
<P><FONT FACE="Georgia">Изначальное предназначение <b>PrintStream</b> было в печати 
  всех примитивных типов данных и объектов <b>String</b> в удобочитаемом формате. 
  Он отличается от <b>DataOutputStream</b>, чья цель состоит в помещении элементов 
  данных в поток таким способом, чтобы <b>DataInputStream</b> мог без труда реконструировать 
  их.</FONT></P>
<P><FONT FACE="Georgia">Двумя важнейшими методами <b>PrintStream</b> являются 
  <b>print(&#160;)</b> и <b>println(&#160;)</b>, которые перегружены для печати 
  всех различных типов. Различия между <b>print(&#160;)</b> и <b>println(&#160;)</b> 
  в том, что последний метод добавляет символ новой строки, когда завершен вывод.</FONT></P>
<P><FONT FACE="Georgia"><B>PrintStream</B> может быть проблематичным, поскольку 
  он ловит все <b>IOException</b> (вы должны явно проверять статус ошибки с помощью 
  <b>checkError(&#160;)</b>, который возвращает <b>true</b>, если возникла ошибка). 
  Так же <b>PrintStream</b> не интернацианализован полностью и не обрабатывает 
  переводы строки платформонезависимым способом (эти проблемы решаются с помощью 
  <b>PrintWriter</b>).</FONT></P>
<P><FONT FACE="Georgia"><B>BufferedOutputStream</B> является модификатором и говорит 
  потоку, что нужно использовать буферизацию, так что вы не получите физической 
  записи при каждой записи в поток. Вы, вероятно, всегда захотите использовать 
  это с файлами, и, возможно, при консольном вводе/выводе.</FONT></P>
<P><FONT FACE="Georgia"><B>Таблица 11-4. Типы FilterOutputStream<A NAME="Index1213"></A><A NAME="Index1214"></A><A NAME="Index1215"></A><A NAME="Index1216"></A><A NAME="Index1217"></A><A NAME="Index1218"></A></B></FONT></P>
<TABLE BORDER width="100%">
  <TR VALIGN="TOP"> 
    <TH WIDTH=402 COLSPAN=1 ROWSPAN=1 VALIGN="TOP"> <FONT FACE="Georgia"><B>Класс</B></FONT></TH>
    <TH WIDTH=219 COLSPAN=1 ROWSPAN=1 VALIGN="TOP"> <FONT FACE="Georgia"><B>Функции</B></FONT></TH>
    <TH WIDTH=120 COLSPAN=1 ROWSPAN=1 VALIGN="TOP"> <FONT FACE="Georgia"><B>Аргументы 
      конструктора</B></FONT></TH>
  </TR>
  <TR VALIGN="TOP"> 
    <TH WIDTH=402 COLSPAN=1 ROWSPAN=1 VALIGN="TOP"> <FONT FACE="Georgia"><B>Как 
      это использовать</B></FONT></TH>
  </TR>
  <TR VALIGN="TOP"> 
    <TD width="402"> <FONT FACE="Georgia"><B>Data-OutputStream</B></FONT></TD>
    <TD width="219"> <FONT FACE="Georgia">Используется совместно с <B>DataInputStream</B>, 
      так что вы можете писать примитивные типы (int, char, long и т.п.) в поток 
      портативным образом.</FONT><BR>
    </TD>
    <TD width="120"> <FONT FACE="Georgia"><B>OutputStream</B></FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD width="402"> <FONT FACE="Georgia">Содержит полный интерфейс, чтобы позволить 
      вам записывать примитивные типы.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD width="402"> <FONT FACE="Georgia"><B>PrintStream</B></FONT></TD>
    <TD width="219"> <FONT FACE="Georgia">Для произведения форматированного вывода. 
      В то время как <B>DataOutputStream</B> обрабатывает <i>хранилище</i> данных, 
      <B>PrintStream</B> обрабатывает <i>отображение</i>.</FONT></TD>
    <TD width="120"> <FONT FACE="Georgia"><B>OutputStream</B>, с необязательным 
      <B>boolean</B>, указывающим, что буфер будет принудительно освобождаться 
      с каждой новой строкой.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD width="402"> <FONT FACE="Georgia">Должен быть в финале оборачивать ваш 
      объект <B>OutputStream</B>. Вы, вероятно, часто будете использовать его.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD width="402"> <FONT FACE="Georgia"><B>Buffered-OutputStream</B></FONT></TD>
    <TD width="219"> Используйте это для <FONT FACE="Georgia">предотвращения физической 
      записи при каждой посылке данных. Вы говорите &#8220;Используй буфер&#8221;. 
      Вы вызываете <B>flush(&#160;)</B> для очистки буфера.</FONT></TD>
    <TD width="120"> <FONT FACE="Georgia"><B>OutputStream</B>, с необязательным 
      размером буфера.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD width="402"> <FONT FACE="Georgia">Это не обеспечивает сам по себе интерфейс, 
      просто является требованием использования буфера. Присоединяется к объекту 
      интерфейса.</FONT></TD>
  </TR>
  <A NAME="_Toc375545389"></A><A NAME="_Toc481064744"></A>
</TABLE>
<p></P>
<A NAME="Heading364"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Читающие и пишущие<A NAME="Index1219"></A></H2>
</FONT> 
<P><FONT FACE="Georgia">В Java 1.1 сделаны некоторые значительные модификации 
  в фундаментальной библиотеке потоков ввода/вывода (однако Java 2 не внесла фундаментальных 
  модификаций). Когда вы видите классы <a name="Index1220"></a><a name="Index1221"></a><b>Reader</b> 
  и <a name="Index1222"></a><a name="Index1223"></a><b>Writer</b>, вы сначала 
  можете подумать (как и я), что они предназначены для замены классов <b>InputStream</b> 
  и <b>OutputStream</b>. Но не в этом случае. Хотя некоторые аспекты начальной 
  библиотеки потоков устарели и были заменены (если вы используете их, вы должны 
  получать предупреждение компилятора), классы <b>InputStream</b> и <b>OutputStream</b> 
  все еще обеспечивают ценную функциональность в форме байт-ориентированных систем 
  ввода/вывода, в то время как классы <b>Reader </b>и <b>Writer</b> обеспечивают 
  Unicode-совместимый, символьно ориентированный ввод/вывод. Кроме того:</FONT><FONT FACE="Georgia"><A NAME="Index1224"></A><A NAME="Index1225"></A><A NAME="Index1226"></A><A NAME="Index1227"></A></FONT></P>
<OL>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Java 1.1 добавил новые 
    классы в иерархию <B>InputStream </B>и <B>OutputStream</B>, так что, очевидно, 
    что эти классы не заменены.</FONT> 
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Иногда возникают ситуации, 
    когда вы должны использовать классы из &#8220;byte&#8221; иерархии в комбинации 
    с классами в &#8220;символьной&#8221; иерархии. Чтобы выполнить это, существуют 
    классы - &#8220;мосты&#8221;: <B>InputStreamReader</B> преобразует <B>InputStream 
    </B>к <B>Reader</B>,<B> </B>и <B>OutputStreamWriter</B> преобразует <B>OutputStream</B> 
    к <B>Writer</B>.</FONT>
</OL>
<P><FONT FACE="Georgia">Наиболее важная причина во введении иерархии <b>Reader</b> 
  и <b>Writer</b> состоит в <a name="Index1228"></a><a name="Index1229"></a>интернационализации. 
  Старая иерархия потоков ввода/вывода поддерживает только 8-битные байтовые потоки 
  и не обрабатывает 16 битные Unicode символы. Так как Unicode используется для 
  интернационализации (и родной тип <b>char</b> в Java - это 16-bit <a name="Index1230"></a><a name="Index1231"></a>Unicode), 
  иерархия <b>Reader</b> и <b>Writer</b> были добавлены для поддержки Unicode 
  и всех операций ввода/вывода. Кроме того, новые библиотеки были разработаны 
  для ускорения операций по сравнению со старыми.</FONT></P>
<P><FONT FACE="Georgia">Как практикуется в этой книге, я попробую выполнить обзор 
  классов, но вы должны принять во внимание, что вы будете использовать онлайн 
  документацию для определения всех деталей, таких как исчерпывающий список методов.</FONT><A NAME="_Toc481064745"></A></P>
<DIV ALIGN="LEFT"></DIV>
<A NAME="Heading365"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Источники и приемники данных</H3>
</FONT> 
<P><FONT FACE="Georgia">Почти все оригинальные классы потоков ввода/вывода имеют 
  соответствующие классы <b>Reader</b> и <b>Writer</b> для обеспечения родных 
  манипуляций в Unicode. Однако есть некоторые места, где байт-ориентированные 
  <b>InputStream</b> и <b>OutputStream</b> являются корректным решением; на практике 
  библиотеки из <b>java.util.zip</b> скорее байт-ориентированные, чем символьно-ориентированные. 
  Так что наиболее разумным подходом будет <i>попытка</i> использования классов 
  <b>Reader</b> и <b>Writer</b> там, где э</FONT><font face="Georgia">то возможно, 
  и вы обнаружите ситуации, когда будете вынуждены использовать байт-ориентированные 
  библиотеки, потому что ваш код не будет компилироваться.</font></P>
<P><FONT FACE="Georgia">Здесь приведена таблица, которая показывает соответствие 
  между источниками и приемниками информации (то есть, куда данные приходят на 
  физическом уровне или куда они уходят) в двух иерархиях.<A NAME="Index1232"></A><A NAME="Index1233"></A><A NAME="Index1234"></A><A NAME="Index1235"></A><A NAME="Index1236"></A><A NAME="Index1237"></A><A NAME="Index1238"></A><A NAME="Index1239"></A><A NAME="Index1240"></A><A NAME="Index1241"></A><A NAME="Index1242"></A><A NAME="Index1243"></A><A NAME="Index1244"></A><A NAME="Index1245"></A><A NAME="Index1246"></A><A NAME="Index1247"></A><A NAME="Index1248"></A><A NAME="Index1249"></A><A NAME="Index1250"></A><A NAME="Index1251"></A><A NAME="Index1252"></A><A NAME="Index1253"></A><A NAME="Index1254"></A><A NAME="Index1255"></A></FONT></P>
<DIV ALIGN="CENTER"><TABLE BORDER>
<TR VALIGN="TOP">
      <th> <FONT FACE="Georgia"><B>Источники и приемники: класс </B></FONT><FONT FACE="Georgia"><B>Java 
        1.0</B></FONT></th>      
      <th> <FONT FACE="Georgia"><B>Соответствующий класс Java 1.1</B></FONT> </th>
</TR>
<TR VALIGN="TOP">
      <TD> <FONT FACE="Georgia"><B>InputStream</B></FONT></TD>
      <TD> <FONT FACE="Georgia"><B>Reader </B></FONT><BR>
        <FONT FACE="Georgia">конвертер:<B> InputStreamReader</B></FONT></TD>
</TR>
<TR VALIGN="TOP">
      <TD> <FONT FACE="Georgia"><B>OutputStream</B></FONT></TD>
      <TD> <FONT FACE="Georgia"><B>Writer </B></FONT><BR>
        <FONT FACE="Georgia">конвертер:<B> OutputStreamWriter</B></FONT></TD>
</TR>
<TR VALIGN="TOP">
      <TD> <FONT FACE="Georgia"><B>FileInputStream</B></FONT></TD>
      <TD> <FONT FACE="Georgia"><B>FileReader</B></FONT></TD>
</TR>
<TR VALIGN="TOP">
      <TD> <FONT FACE="Georgia"><B>FileOutputStream</B></FONT></TD>
      <TD> <FONT FACE="Georgia"><B>FileWriter</B></FONT></TD>
</TR>
<TR VALIGN="TOP">
      <TD> <FONT FACE="Georgia"><B>StringBufferInputStream</B></FONT></TD>
      <TD> <FONT FACE="Georgia"><B>StringReader</B></FONT></TD>
</TR>
<TR VALIGN="TOP">
      <TD> <FONT FACE="Georgia">(соответствующего класса нет)</FONT></TD>
      <TD> <FONT FACE="Georgia"><B>StringWriter</B></FONT></TD>
</TR>
<TR VALIGN="TOP">
      <TD> <FONT FACE="Georgia"><B>ByteArrayInputStream</B></FONT></TD>
      <TD> <FONT FACE="Georgia"><B>CharArrayReader</B></FONT></TD>
</TR>
<TR VALIGN="TOP">
      <TD> <FONT FACE="Georgia"><B>ByteArrayOutputStream</B></FONT></TD>
      <TD> <FONT FACE="Georgia"><B>CharArrayWriter</B></FONT></TD>
</TR>
<TR VALIGN="TOP">
      <TD> <FONT FACE="Georgia"><B>PipedInputStream</B></FONT></TD>
      <TD> <FONT FACE="Georgia"><B>PipedReader</B></FONT></TD>
</TR>
<TR VALIGN="TOP">
      <TD> <FONT FACE="Georgia"><B>PipedOutputStream</B></FONT></TD>
      <TD> <FONT FACE="Georgia"><B>PipedWriter</B></FONT></TD>
</TR>
</TABLE><p></P></DIV>
<P><FONT FACE="Georgia">В общем случае вы обнаружите, что интерфейсы для этих 
  двух различных иерархий сходны, если не идентичны.</FONT><A NAME="_Toc481064746"></A></P>
<A NAME="Heading366"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Модификация поведения потока</H3>
</FONT> 
<P><FONT FACE="Georgia">Потоки <B>InputStream</B> и <B>OutputStream</B> адаптируются 
  под определенные требования с использованием &#8220;декорирующих&#8221; подклассов 
  <b>FilterInputStream</b> и <b>FilterOutputStream.</b> Классы иерархии <b>Reader</b> 
  и <b>Writer</b> продолжают использовать эту идею &#8212; но не точно.</FONT></P>
<P><FONT FACE="Georgia">В приведенной таблице соответствие произведено с еще большим 
  приближением, чем в предыдущей таблице. Различия происходят из-за организации 
  классов: в то время как <b>BufferedOutputStream</b> является подклассом <b>FilterOutputStream</b>, 
  <b>BufferedWriter</b> <i>не</i> является подклассом <b>FilterWriter</b> (который, 
  не смотря на то, что он является абстрактным, не имеет подклассов и, таким образом, 
  появляется помещенным в любой объект, а здесь упомянуть просто для того, чтобы 
  вы не удивились, увидев его). Однако интерфейсы классов достаточно близки при 
  сравнении.<a name="Index1256"></a><a name="Index1257"></a><a name="Index1258"></a><a name="Index1259"></a><a name="Index1260"></a><a name="Index1261"></a><a name="Index1262"></a><a name="Index1263"></a><a name="Index1264"></a><a name="Index1265"></a><a name="Index1266"></a><a name="Index1267"></a><a name="Index1268"></a><a name="Index1269"></a><a name="Index1270"></a><a name="Index1271"></a><a name="Index1272"></a><a name="Index1273"></a><a name="Index1274"></a><a name="Index1275"></a></FONT></P>
<TABLE BORDER>
  <TR VALIGN="TOP"> 
    <TH WIDTH=162 COLSPAN=1 ROWSPAN=1 VALIGN="TOP"> <FONT FACE="Georgia"><B>Фильтры:</B></FONT><BR>
      <FONT FACE="Georgia"><B>классы Java 1.0</B></FONT></TH>
    <TH WIDTH=189 COLSPAN=1 ROWSPAN=1 VALIGN="TOP"> <FONT FACE="Georgia"><B>Соответствующий 
      класс Java 1.1</B></FONT></TH>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>FilterInputStream</B></FONT></TD>
    <TD> <FONT FACE="Georgia"><B>FilterReader</B></FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>FilterOutputStream</B></FONT></TD>
    <TD> <FONT FACE="Georgia"><B>FilterWriter </B>(абстрактный класс без подклассов)</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>BufferedInputStream</B></FONT></TD>
    <TD> <FONT FACE="Georgia"><B>BufferedReader</B></FONT><BR>
      <FONT FACE="Georgia">(так же имеет <B> readLine(&#160;)</B>)</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>BufferedOutputStream</B></FONT></TD>
    <TD> <FONT FACE="Georgia"><B>BufferedWriter</B></FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>DataInputStream</B></FONT></TD>
    <TD> <FONT FACE="Georgia">Используйте<B> DataInputStream</B></FONT><BR>
      <FONT FACE="Georgia">(За исключением случаев, когда вам нужно использовать 
      <B> readLine(&#160;)</B>, в этом случае вы должны использовать<B> BufferedReader</B>)</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>PrintStream</B></FONT></TD>
    <TD> <FONT FACE="Georgia"><B>PrintWriter</B></FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>LineNumberInputStream</B></FONT></TD>
    <TD> <FONT FACE="Georgia"><B>LineNumberReader</B></FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>StreamTokenizer</B></FONT></TD>
    <TD> <FONT FACE="Georgia"><B>StreamTokenizer</B></FONT><BR>
      <FONT FACE="Georgia">(Используйте конструктор, принимающий <B>Reader</B>)</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>PushBackInputStream</B></FONT></TD>
    <TD> <FONT FACE="Georgia"><B>PushBackReader</B></FONT></TD>
  </TR>
</TABLE>
<p></P>
<P><FONT FACE="Georgia">Есть одно направление, которое достаточно понятно: Когда 
  вы хотите использовать <b>readLine(&#160;)</b>, вы не должны более использовать 
  <b>DataInputStream</b> (при этом вы встретитесь с сообщении об использовании 
  устаревших методов во время компиляции), а вместо этого использовать <b>BufferedReader</b>. 
  Тем не менее, <b>DataInputStream</b> все еще остается &#8220;привилегированным&#8221; 
  членом библиотеки ввода/вывода.</FONT></P>
<P><FONT FACE="Georgia">Чтобы сделать переход к использованию <b>PrintWriter</b> 
  более легким, он имеет конструктор, который принимает любой объект типа <b>OutputStream</b>, 
  наряду с объектами <b>Writer</b>. Однако <b>PrintWriter</b> более не поддерживает 
  форматирование, которое поддерживал <b>PrintStream</b>; интерфейс, фактически, 
  остался тем же.</FONT></P>
<P><FONT FACE="Georgia">Конструктор <B>PrintWriter</B> также имеет необязательную 
  опцию для выполнения автоматической выгрузки буферов, которая случается после 
  каждого вызова <b>println(&#160;)</b>, если установлен флаг в конструкторе.</FONT><A NAME="_Toc481064747"></A></P>
<DIV ALIGN="LEFT"></DIV>
<A NAME="Heading367"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Неизмененные классы</H3>
</FONT>
<P><FONT FACE="Georgia">Некоторые классы остались неизменными при переходе от 
  Java 1.0 к Java 1.1:<A NAME="Index1276"></A><A NAME="Index1277"></A><A NAME="Index1278"></A><A NAME="Index1279"></A><A NAME="Index1280"></A><A NAME="Index1281"></A><A NAME="Index1282"></A><A NAME="Index1283"></A></FONT></P>
<P ALIGN="CENTER"> 
  <TABLE BORDER>
    <TR VALIGN="TOP"> 
      <TH WIDTH=166 COLSPAN=1 ROWSPAN=1 VALIGN="TOP"> Классы <FONT FACE="Georgia">Java 
        1.0 не имеющие соответствующих классов в Java 1.1 </FONT> </TH>
    </TR>
    <TR VALIGN="TOP"> 
      <TD> <FONT FACE="Georgia"><B>DataOutputStream</B></FONT></TD>
    </TR>
    <TR VALIGN="TOP"> 
      <TD> <FONT FACE="Georgia"><B>File</B></FONT></TD>
    </TR>
    <TR VALIGN="TOP"> 
      <TD> <FONT FACE="Georgia"><B>RandomAccessFile</B></FONT></TD>
    </TR>
    <TR VALIGN="TOP"> 
      <TD> <FONT FACE="Georgia"><B>SequenceInputStream</B></FONT></TD>
    </TR>
  </TABLE>
  <p></P>
<p></p>
<P><FONT FACE="Georgia"><B>DataOutputStream</B>, в основном, используется без 
  изменений, так что для хранения и получения данных в транспортабельном формате, 
  используй те иерархии <B>InputStream</B> и <B>OutputStream</B>.</FONT><A NAME="_Toc481064748"></A></P>
<A NAME="Heading368"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Сам по себе: RandomAccessFile<A NAME="Index1284"></A><A NAME="Index1285"></A></H2>
</FONT> 
<P><FONT FACE="Georgia"><B>RandomAccessFile</B> используется для файлов, содержащих 
  записи известного размера, так что вы можете переместиться от одной записи к 
  другой, используя <a name="Index1286"></a><a name="Index1287"></a><b>seek(&#160;)</b>, 
  затем прочесть или изменить запись. Записи могут и не быть одинакового размера; 
  вы просто способны определить их размер и их положение в файле.</FONT></P>
<P><FONT FACE="Georgia">Сначала немного трудно поверить, что <b>RandomAccessFile</b> 
  не является частью иерархии <b>InputStream</b> или <b>OutputStream</b>. Однако 
  он не имеет ассоциаций с этими иерархиями, за исключением того, что он реализует 
  интерфейсы <a name="Index1288"></a><a name="Index1289"></a><b>DataInput</b> 
  и <a name="Index1290"></a><a name="Index1291"></a><b>DataOutput</b> (которые 
  так же реализуются <b>DataInputStream</b> и <b>DataOutputStream</b>). Он даже 
  не использует любую функциональность существующих классов <b>InputStream</b> 
  или <b>OutputStream</b> &#8212; это полностью отдельный класс, написанный для 
  поиска, имеющий все свои собственные (в большинстве своем родные) методы. Объяснением 
  этого может быть то, что <b>RandomAccessFile</b> имеет во многом отличающееся 
  поведение по сравнению с остальными типами ввода/вывода, так как вы можете перемещаться 
  вперед и назад в пределах файла. В любом случае, он стоит отдельно, как прямой 
  потомок от <b>Object</b>.</FONT></P>
<P><FONT FACE="Georgia">По существу, <B>RandomAccessFile</B> работает как <B>DataInputStream</B> 
  совмещенный с <b>DataOutputStream</b>, благодаря использованию методов <b>getFilePointer(&#160;)</b> 
  для нахождения местоположения в файле, <b>seek(&#160;)</b> для перемещения в 
  новую точку в файле и <b>length(&#160;)</b> для определения максимального размера 
  файла. Кроме того, конструктор требует второй аргумент (что идентично <b>fopen(&#160;) 
  </b>в C), указывающий будите ли вы производить только чтение в произвольном 
  порядке (<b>&#8220;r&#8221;</b>) или чтение и запись (<b>&#8220;rw&#8221;</b>). 
  Нет поддержки для файлов только для чтения, что может сказать о том, что <b>RandomAccessFile</b> 
  мог бы хорошо работать, если он наследовался бы от <b>DataInputStream</b>.</FONT></P>
<P><FONT FACE="Georgia">Метод поиска есть только у <B>RandomAccessFile</B>, который 
  работает только с файлами. <B>BufferedInputStream</B> позволяет вам выполнять 
  маркировку позиции с помощью метода <A NAME="Index1292"></A><A NAME="Index1293"></A><B>mark(&#160;)</B> 
  (чье значение содержится в единственной внутренней переменной) и сброс этой 
  позиции методом <A NAME="Index1294"></A><A NAME="Index1295"></A><B>reset(&#160;)</B>, 
  но это ограничено и не очень полезно.</FONT><A NAME="_Toc375545393"></A><A NAME="_Toc481064749"></A></P>
<DIV ALIGN="LEFT"></DIV>
<A NAME="Heading369"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Типичное использование потоков ввода/вывода</H2>
</FONT>
<P><FONT FACE="Georgia">Хотя вы можете комбинировать классы потоков ввода/вывода 
  многими различными способами, вы, вероятно, будете использовать несколько комбинаций. 
  Следующий пример может быть использован как отправная точка; он показывает создание 
  и использование </FONT> <FONT FACE="Georgia"> <A NAME="Index1296"></A>типичной 
  конфигурации ввода/вывода. Обратите внимание, что каждая конфигурация начинается 
  с порядкового номера и заголовка, который оглавляет соответствующее объяснение 
  в следующем за ним тексте.</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c11:IOStreamDemo.java</font>
<font color=#009900>// Типичные конфигурации потоков ввода/вывода.</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> IOStreamDemo {
  <font color=#009900>// Выбрасывание исключения на консоль:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
  <font color=#0000ff>throws</font> IOException {
    <font color=#009900>// 1. Чтение ввода по строкам:</font>
    BufferedReader in =
      <font color=#0000ff>new</font> BufferedReader(
        <font color=#0000ff>new</font> FileReader(<font color=#004488>"IOStreamDemo.java"</font>));
    String s, s2 = <font color=#0000ff>new</font> String();
    <font color=#0000ff>while</font>((s = in.readLine())!= <font color=#0000ff>null</font>)
      s2 += s + <font color=#004488>"\n"</font>;
    in.close();

    <font color=#009900>// 1b. Чтение стандартного ввода:</font>
    BufferedReader stdin =
      <font color=#0000ff>new</font> BufferedReader(
        <font color=#0000ff>new</font> InputStreamReader(System.in));      
    System.out.print(<font color=#004488>"Enter a line:"</font>);
    System.out.println(stdin.readLine());

    <font color=#009900>// 2. Ввод из памяти</font>
    StringReader in2 = <font color=#0000ff>new</font> StringReader(s2);
    <font color=#0000ff>int</font> c;
    <font color=#0000ff>while</font>((c = in2.read()) != -1)
      System.out.print((<font color=#0000ff>char</font>)c);

    <font color=#009900>// 3. Форматированный ввод из памяти</font>
    <font color=#0000ff>try</font> {
      DataInputStream in3 =
        <font color=#0000ff>new</font> DataInputStream(
          <font color=#0000ff>new</font> ByteArrayInputStream(s2.getBytes()));
      <font color=#0000ff>while</font>(<font color=#0000ff>true</font>)
        System.out.print((<font color=#0000ff>char</font>)in3.readByte());
    } <font color=#0000ff>catch</font>(EOFException e) {
      System.err.println(<font color=#004488>"End of stream"</font>);
    }

    <font color=#009900>// 4. Вывод в файл</font>
    <font color=#0000ff>try</font> {
      BufferedReader in4 =
        <font color=#0000ff>new</font> BufferedReader(
          <font color=#0000ff>new</font> StringReader(s2));
      PrintWriter out1 =
        <font color=#0000ff>new</font> PrintWriter(
          <font color=#0000ff>new</font> BufferedWriter(
            <font color=#0000ff>new</font> FileWriter(<font color=#004488>"IODemo.out"</font>)));
      <font color=#0000ff>int</font> lineCount = 1;
      <font color=#0000ff>while</font>((s = in4.readLine()) != <font color=#0000ff>null</font> )
        out1.println(lineCount++ + <font color=#004488>": "</font> + s);
      out1.close();
    } <font color=#0000ff>catch</font>(EOFException e) {
      System.err.println(<font color=#004488>"End of stream"</font>);
    }

    <font color=#009900>// 5. Хранение и перекрытие данных</font>
    <font color=#0000ff>try</font> {
      DataOutputStream out2 =
        <font color=#0000ff>new</font> DataOutputStream(
          <font color=#0000ff>new</font> BufferedOutputStream(
            <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"Data.txt"</font>)));
      out2.writeDouble(3.14159);
      out2.writeChars(<font color=#004488>"That was pi\n"</font>);
      out2.writeBytes(<font color=#004488>"That was pi\n"</font>);
      out2.close();
      DataInputStream in5 =
        <font color=#0000ff>new</font> DataInputStream(
          <font color=#0000ff>new</font> BufferedInputStream(
            <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"Data.txt"</font>)));
      BufferedReader in5br =
        <font color=#0000ff>new</font> BufferedReader(
          <font color=#0000ff>new</font> InputStreamReader(in5));
      <font color=#009900>// Необходимо использовать DataInputStream для данных:</font>
      System.out.println(in5.readDouble());
      <font color=#009900>// Теперь можно использовать "правильный" readLine():</font>
      System.out.println(in5br.readLine());
      <font color=#009900>// Но выводимая строка забавна.</font>
      <font color=#009900>// Строка, созданная с помощью writeBytes, в порядке:</font>
      System.out.println(in5br.readLine());
    } <font color=#0000ff>catch</font>(EOFException e) {
      System.err.println(<font color=#004488>"End of stream"</font>);
    }

    <font color=#009900>// 6. Чтение/запись файлов в произвольном порядке</font>
    RandomAccessFile rf =
      <font color=#0000ff>new</font> RandomAccessFile(<font color=#004488>"rtest.dat"</font>, <font color=#004488>"rw"</font>);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
      rf.writeDouble(i*1.414);
    rf.close();

    rf =
      <font color=#0000ff>new</font> RandomAccessFile(<font color=#004488>"rtest.dat"</font>, <font color=#004488>"rw"</font>);
    rf.seek(5*8);
    rf.writeDouble(47.0001);
    rf.close();

    rf =
      <font color=#0000ff>new</font> RandomAccessFile(<font color=#004488>"rtest.dat"</font>, <font color=#004488>"r"</font>);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
      System.out.println(
        <font color=#004488>"Value "</font> + i + <font color=#004488>": "</font> +
        rf.readDouble());
    rf.close();
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Здесь приведено описание для нумерованных разделов программы:</FONT><A NAME="_Toc375545394"></A><A NAME="_Toc481064750"></A></P>
<A NAME="Heading370"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Потоки ввода</H3>
</FONT>
<P><FONT FACE="Georgia">Части с 1 по 4 демонстрируют создание и использование 
  потоков ввода. Часть 4 также показывает простое использование потока вывода.</FONT></P>
<A NAME="Heading371"></A><FONT FACE = "Verdana">
<H4 ALIGN="LEFT"> 1. Буферизированный ввод из файла</H4>
</FONT> 
<P><FONT FACE="Georgia">Для открытия файла для ввода символов вы используете <a name="Index1297"></a><a name="Index1298"></a><b>FileInputReader</b> 
  с объектом <b>String</b> или <b>File</b> в качестве имени файла. Для быстрой 
  работы вы можете захотеть, чтобы файл был буферизированный, поэ</FONT><font face="Georgia">тому 
  вы передаете результирующую ссылку в конструктор <a name="Index1299"></a><a name="Index1300"></a><b>BufferedReader</b>. 
  <b>BufferedReader</b> также обеспечивает метод <b>readLine(&#160;)</b>, так 
  что это ваш конечный объект и интерфейс, из которого вы читаете. Когда вы достигаете 
  конца файла, <b>readLine(&#160;)</b> возвращает <b>null</b>, что используется 
  для окончания цикла <b>while</b>.</font></P>
<P><FONT FACE="Georgia"><B>String s2</B> использует для аккумулирования всего 
  содержимого файла (включая символы новой строки, которые должны добавляться, 
  поскольку <b>readLine(&#160;)</b> отбрасывает их). <b>s2 </b>далее используется 
  в следующих частях этой программы. В конце вызывается <b>close(&#160;)</b> для 
  закрытия файла. Технически, <b>close(&#160;)</b> будет вызвано при запуске <b>finalize(&#160;)</b>, 
  а это произойдет (не зависимо от того произойдет или нет сборка мусора) при 
  выходе из программы. Однако это было реализовано неустойчиво, поэтому безопасным 
  подходом является явный вызов <a name="Index1301"></a><a name="Index1302"></a><b>close(&#160;)</b> 
  для файлов.</FONT></P>
<P><FONT FACE="Georgia">Раздел 1b показывает, как вы можете использовать <A NAME="Index1303"></A><A NAME="Index1304"></A><B>System.in</B> 
  для чтения <A NAME="Index1305"></A><A NAME="Index1306"></A><A NAME="Index1307"></A>консольного 
  ввода. <B>System.in</B> является <B>DataInputStream</B> и для <B>BufferedReader</B> 
  необходим аргумент <B>Reader</B>, так что <B>InputStreamReader</B> вовлекается 
  для выполнения перевода.</FONT></P>
<DIV ALIGN="LEFT"></DIV>
<A NAME="Heading372"></A><FONT FACE = "Verdana">
<H4 ALIGN="LEFT"> 2. Ввод из памяти</H4>
</FONT>
<P><FONT FACE="Georgia">Эта секция берет <B>String s2</B>, которая теперь включает 
  все содержимое файла, и использует его для создания <A NAME="Index1308"></A><A NAME="Index1309"></A><B>StringReader</B>. 
  Затем используется <B>read(&#160;)</B> для чтения каждого символа, один символ 
  за обращение, который посылается на консоль. Обратите, что <B>read(&#160;)</B> 
  возвращает следующий байт как <B>int</B>, поэтому он должен быть приведен к 
  типу <B>char</B> для правильной печати.</FONT></P>
<A NAME="Heading373"></A><FONT FACE = "Verdana">
<H4 ALIGN="LEFT"> 3. Форматированный ввод из памяти</H4>
</FONT> 
<P><FONT FACE="Georgia">Для чтения &#8220;форматированных&#8221; данных вы используете 
  <a name="Index1310"></a><a name="Index1311"></a><b>DataInputStream</b>, который 
  является байт-ориентированным классом ввода/вывода (а не символьно-ориентированным). 
  Таким образом, вы должны использовать все классы <b>InputStream</b>, а не классы 
  <b>Reader</b>. Конечно, вы можете читать все, что угодно (также как и файл) 
  байтами, используя классы <b>InputStream</b>, но здесь используется <b>String</b>. 
  Для преобразования <b>String</b> в массив байт, который является подходящим 
  для <b>ByteArrayInputStream</b>, <b>String</b> имеет метод <a name="Index1312"></a><b>getBytes(&#160;)</b>, 
  чтобы сделать эту работу. В этой точке вы имеете соответствующий <b>InputStream</b> 
  для управления <b>DataInputStream</b>.</FONT></P>
<P><FONT FACE="Georgia">Если вы читаете символы из <B>DataInputStream </B>по одному 
  байту, используя <B>readByte(&#160;)</B>, любое байтовое значение является допустимым 
  результатом, так что возвращаемое значение не может использоваться для обнаружения 
  конца ввода. Вместо этого вы можете использовать метод <A NAME="Index1313"></A><A NAME="Index1314"></A><B>available(&#160;) 
  </B> для нахождения как много символов доступно. Вот пример, который показывает, 
  как читать файл по одному байту:</FONT><BR>
</P>
<DIV ALIGN="LEFT"></DIV>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c11:TestEOF.java</font>
<font color=#009900>// Проверка на конец файла</font>
<font color=#009900>// при чтении по одному байту.</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> TestEOF {
  <font color=#009900>// Выбрасывается исключение на консоль:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
  <font color=#0000ff>throws</font> IOException {
    DataInputStream in = 
      <font color=#0000ff>new</font> DataInputStream(
       <font color=#0000ff>new</font> BufferedInputStream(
        <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"TestEof.java"</font>)));
    <font color=#0000ff>while</font>(in.available() != 0)
      System.out.print((<font color=#0000ff>char</font>)in.readByte());
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Обратите внимание, что <b>available(&#160;)</b> работает 
  по разному в зависимости от сорта носителя, из которого вы читаете; буквально 
  - &#8220;это число байт, которые могут быть прочитаны <i>без блокировки</i>&#8221;.<a name="Index1315"></a><a name="Index1316"></a> 
  Для файлов это означает весь файл, но для другого вида потоков это может не 
  быть правдой, так что используйте его осторожно.</FONT></P>
<P><FONT FACE="Georgia">Вы также можете определить конец ввода в таком случае, 
  как здесь, при поимке исключения. Однако использование исключений для управления 
  выполнением программы, рассматривается как злоупотребление этой особенностью.</FONT></P>
<DIV ALIGN="LEFT"></DIV>
<A NAME="Heading374"></A><FONT FACE = "Verdana">
<H4 ALIGN="LEFT"> 4. Вывод в файл</H4>
</FONT> 
<P><FONT FACE="Georgia">Этот пример также показывает, как писать данные в файл. 
  Сначала создается <a name="Index1317"></a><a name="Index1318"></a><b>FileWriter</b> 
  для соединения с файлом. Фактически, вы всегда будете буферизировать вывод, 
  обернув его с помощью <a name="Index1319"></a><a name="Index1320"></a><b>BufferedWriter</b> 
  (попробуйте удалить эту обертку, чтобы посмотреть влияние на производительность 
  &#8212; буферизация позволяет значительно увеличить производительность операций 
  ввода/вывода). Затем, для форматирование объект включен в <a name="Index1321"></a><a name="Index1322"></a><b>PrintWriter</b>. 
  Файл данных, созданный этим способом, читаем, как обычный текстовый файл.</FONT></P>
<P><FONT FACE="Georgia">Когда строки записываются в файл, добавляются номера строк. 
  Обратите внимание, что <b>LineNumberInputStream</b> не используется, потому 
  что он слабый и вам не нужен. Как показано здесь, достаточно просто хранить 
  свою историю номеров строк.</FONT></P>
<P><A NAME="Index1323"></A><A NAME="Index1324"></A><FONT FACE="Georgia">Когда 
  входной поток исчерпан, <A NAME="Index1325"></A><A NAME="Index1326"></A><B>readLine(&#160;)</B> 
  возвращает <B>null</B>. Вы увидите явный вызов <B>close(&#160;)</B> для <B>out1</B>, 
  в противном случае, если вы не вызовите <B>close(&#160;)</B> для всех своих 
  выходных файлов, вы можете обнаружить, что данные из буферов не вытолкнуты, 
  поэтому файлы не завершенные.</FONT><A NAME="_Toc375545395"></A><A NAME="_Toc481064751"></A></P>
<DIV ALIGN="LEFT"></DIV>
<A NAME="Heading375"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Выходные потоки</H3>
</FONT>
<P><FONT FACE="Georgia">Два первичных вида потоков вывода делятся по способу записи 
  данных: одни пишут их для потребления людей, а другие пишут данные для повторного 
  использования с <A NAME="Index1327"></A><A NAME="Index1328"></A><B>DataInputStream</B>. 
  <A NAME="Index1329"></A><A NAME="Index1330"></A><B>RandomAccessFile</B> стоит 
  в стороне, хотя его формат данных совместим с <B>DataInputStream</B> и <A NAME="Index1331"></A><A NAME="Index1332"></A><B>DataOutputStream</B>.</FONT></P>
<A NAME="Heading376"></A><FONT FACE = "Verdana">
<H4 ALIGN="LEFT"> 5. Сохранение и возврат<A NAME="Index1333"></A><A NAME="Index1334"></A></H4>
</FONT> 
<P><FONT FACE="Georgia"> <B>PrintWriter</B> форматирует данные так, чтобы их читали 
  люди. Однако для вывода данных в виде, чтобы они могли быть возвращены в другой 
  поток, используйте <b>DataOutputStream</b> для записи данных, а <b>DataInputStream</b> 
  для обратного получения данных. Конечно, эти потоки могут быть всем, что угодно, 
  но здесь используется файл, буферизируемый и для чтения, и для записи. <b>DataOutputStream</b> 
  и <b>DataInputStream</b> являются байт-ориентированными и поэтому требуют потоков 
  <b>InputStream</b> и <b>OutputStream</b>.</FONT></P>
<P><FONT FACE="Georgia">Если вы используете <b>DataOutputStream</b> для записи 
  данных, то Java гарантирует, что вы можете безошибочно повторно задействовать 
  данные, используя <b>DataInputStream</b> &#8212; не зависимо от различий платформ 
  для записи и чтения данных. Это невероятно ценно, как могут подтвердить те, 
  кто потратил время, заботясь о платформозависимых путях движения данными. Эти 
  проблемы снимаются, если вы имеете Java на обеих платформах. <a href="#fn58">[58]</a></FONT></P>
<P><A NAME="Index1336"></A><A NAME="Index1337"></A><A NAME="Index1338"></A><FONT FACE="Georgia">Обратите 
  внимание, что строки символов записываются с использованием как <b>writeChars(&#160;)</b>, 
  так и <b>writeBytes(&#160;)</b>. Когда вы запустите программу, вы обнаружите, 
  что выводит 16-битные символы Unicode. Когда вы читаете строки, используя <b>readLine(&#160;)</b>, 
  вы увидите, что есть пространство между символами, потому что каждый дополнительный 
  байт вставляется из-за Unicode. Так как нет дополнительного метода &#8220;readChars&#8221; 
  для <b>DataInputStream</b>, вы вынуждены вытягивать символы по одному с помощью 
  <a name="Index1339"></a><a name="Index1340"></a><b>readChar(&#160;)</b>. Так 
  что для ASCII легче написать символы байтами, за которым следует новая строка, 
  а затем использовать <a name="Index1341"></a><a name="Index1342"></a><b>readLine(&#160;)</b> 
  для чтения байтов, как обычной ASCII cтроки.</FONT></P>
<P><FONT FACE="Georgia"><A NAME="Index1343"></A><A NAME="Index1344"></A><B>writeDouble(&#160;)</B> 
  сохраняет числа типа <b>double</b> в потоке, а дополнительный метод <a name="Index1345"></a><a name="Index1346"></a><b>readDouble(&#160;)</b> 
  получает их обратно (есть аналогичные методы для чтения и записи остальных типов). 
  Но для корректной работы с любым читающим методом вы должны знать точное положение 
  элемента данных в потоке, чтобы было одинаково возможно читать хранимое <b>double</b>, 
  как простую последовательность байт, или как <b>char</b>, и т.п. Таким образом, 
  вы должны либо иметь фиксированный формат для данных в файле, или в файле должна 
  хранится дополнительная информация, которую вы обработаете для определения местоположения 
  данных.</FONT></P>
<DIV ALIGN="LEFT"></DIV>
<A NAME="Heading377"></A><FONT FACE = "Verdana">
<H4 ALIGN="LEFT"> 6. Чтение и запись файлов произвольного доступа</H4>
</FONT> 
<P><FONT FACE="Georgia">Как было замечено ранее, <b>RandomAccessFile</b> почти 
  полностью изолирован от оставшейся иерархии ввода/вывода, и подтвержден тот 
  факт, что он реализует интерфейсы <b>DataInput</b> и <b>DataOutput</b>. Поэтому 
  вы не можете комбинировать его с любыми другими аспектами подклассов <b>InputStream</b> 
  и <b>OutputStream</b>. Даже при том, что имело бы смысл трактовать <b>ByteArrayInputStream</b>, 
  как элемент произвольного доступа, вы можете использовать <b>RandomAccessFile</b> 
  только для открытия файла. Вы должны иметь в виду, что <b>RandomAccessFile</b> 
  буферизирован должным образом, так что вам не нужно заботится об этом.</FONT></P>
<P><FONT FACE="Georgia">Одну из настроек вы имеете во втором конструкторе аргумента: 
  вы можете открыть <b>RandomAccessFile</b> для чтения (<b>&#8220;r&#8221;</b>) 
  или для чтения и записи (<b>&#8220;rw&#8221;</b>).</FONT></P>
<P><FONT FACE="Georgia">Использование <B>RandomAccessFile</B> аналогично использования 
  комбинации <B>DataInputStream</B> и <B>DataOutputStream</B> (потому что он реализует 
  эквивалентные интерфейсы). Кроме того, вы можете видеть, что <A NAME="Index1347"></A><A NAME="Index1348"></A><B>seek(&#160;)</B> 
  используется для перемещения в файле и изменения одного значения на другое.</FONT><A NAME="_Toc481064752"></A></P>
<DIV ALIGN="LEFT"></DIV>
<A NAME="Heading378"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Ошибка?</H3>
</FONT>
<P><FONT FACE="Georgia">Если вы взглянете на раздел 5, вы увидите, что данные 
  записываются <i>перед</i> текстом. Дело в том, что эта проблема была представлена 
  в Java 1.1 (и сохранилась в Java 2), я был уверен, что это ошибка. Когда я сообщил 
  об этом людям, занимающимся ошибками в JavaSoft, они сказали мне, что это, Проблема 
  показана в следующем коде:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c11:IOProblem.java</font>
<font color=#009900>// Java 1.1 и высшая проблема ввода/вывода.</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> IOProblem {
  <font color=#009900>// Исключение выбрасывается на консоль:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
  <font color=#0000ff>throws</font> IOException {
    DataOutputStream out =
      <font color=#0000ff>new</font> DataOutputStream(
        <font color=#0000ff>new</font> BufferedOutputStream(
          <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"Data.txt"</font>)));
    out.writeDouble(3.14159);
    out.writeBytes(<font color=#004488>"That was the value of pi\n"</font>);
    out.writeBytes(<font color=#004488>"This is pi</font><font color=#004488>/2:\n"</font>);
    out.writeDouble(3.14159/2);
    out.close();

    DataInputStream in =
      <font color=#0000ff>new</font> DataInputStream(
        <font color=#0000ff>new</font> BufferedInputStream(
          <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"Data.txt"</font>)));
    BufferedReader inbr =
      <font color=#0000ff>new</font> BufferedReader(
        <font color=#0000ff>new</font> InputStreamReader(in));
    <font color=#009900>// Double, записанное ПЕРЕД текстом</font>
    <font color=#009900>// считывается правильно:</font>
    System.out.println(in.readDouble());
    <font color=#009900>// Читаем строки текста:</font>
    System.out.println(inbr.readLine());
    System.out.println(inbr.readLine());
    <font color=#009900>// Попытка читать double после строки</font>
    <font color=#009900>// производит исключение конца файла:</font>
    System.out.println(in.readDouble());
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Кажется что все, что вы пишите после вызова <B>writeBytes(&#160;)</B> 
  не возвращаемо. Ответ, очевидно, тот же, что и в случае старой шутки водителя: 
  &#8220;Доктор, мне больно, когда я делаю это!&#8221; &#8220;Так не делайте этого!&#8221;</FONT><A NAME="_Toc481064753"></A></P>
<A NAME="Heading379"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Потоки в виде трубопровода<A NAME="Index1349"></A><A NAME="Index1350"></A></H3>
</FONT>
<P><FONT FACE="Georgia"><B>PipedInputStream</B>, <B>PipedOutputStream</B>, <B>PipedReader</B> 
  и <B>PipedWriter</B> будут упомянуты только вскользь в этой главе. Это не означает, 
  что они бесполезны, но их значение не будет очевидно, пока вы не поймете многонитевые 
  процессы, так как потоки в виде трубопровода используются для общения между 
  нитями. Это будет освещено в примере <a href="Chapter14.html">Главы 14</a>.</FONT><A NAME="_Toc481064754"></A></P>
<A NAME="Heading380"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Стандартный ввод/вывод<A NAME="Index1351"></A><A NAME="Index1352"></A><A NAME="Index1353"></A><A NAME="Index1354"></A><A NAME="Index1355"></A><A NAME="Index1356"></A><A NAME="Index1357"></A><A NAME="Index1358"></A><A NAME="Index1359"></A></H2>
</FONT>
<P><FONT FACE="Georgia">Термин <i>стандартный ввод/вывод</i> относится к концепции 
  Unix (которая в некоторой форме была воспроизведена в Windows и многих других 
  операционных системах) единого потока информации, который используется программой. 
  Весь ввод программы может вестись через <i>стандартный ввод</i>, весь вывод 
  может идти в <i>стандартный вывод</i>, а все сообщения об ошибках могут посылаться 
  в <i>стандартный </i>поток <i>ошибок. </i>Значение стандартного ввода/вывода 
  в том, что программы легко могут представлять цепочку вместе, и стандартный 
  вывод одной программы может стать стандартным вводом для другой. Это достаточно 
  мощный инструмент.</FONT><A NAME="_Toc375545397"></A><A NAME="_Toc481064755"></A></P>
<A NAME="Heading381"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Чтение из стандартного ввода</H3>
</FONT> 
<P><FONT FACE="Georgia">Стандартная модель ввода/вывода в Java имеет <B>System.in</B>, 
  <B>System.out</B> и <B>System.err</B>. На протяжении всей этой книге вы видели, 
  как писать в стандартный вывод, используя <B>System.out,</B> который представляет 
  собой объект <B>PrintStream</B>. <B>System.err</B> аналогичен <B>PrintStream</B>, 
  а <B>System.in</B> является производной <B>InputStream</B> без каких-либо включений. 
  Это означает, что в то время, когда вы можете использовать <B>System.out</B> 
  и <B>System.err</B> как они есть, <B>System.in</B> должен куда-то включаться 
  (быть обернут), прежде, чем вы сможете прочесть из него.</FONT></P>
<P><FONT FACE="Georgia">Обычно вы захотите читать ввод построчно, используя <B>readLine(&#160;)</B>, 
  так что вы захотите поместить <B>System.in</B> в <B>BufferedReader</B>. Чтобы 
  сделать это, вы можете конвертировать <B>System.in </B>в <B>Reader</B>, используя 
  <B>InputStreamReader</B>. Вот пример, который просто повторяет каждую строку, 
  которую вы печатаете:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c11:Echo.java</font>
<font color=#009900>// Как читать стандартный ввод.</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Echo {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args)
  <font color=#0000ff>throws</font> IOException {
    BufferedReader in =
        <font color=#0000ff>new</font> BufferedReader(
          <font color=#0000ff>new</font> InputStreamReader(System.in));
    String s;
    <font color=#0000ff>while</font>((s = in.readLine()).length() != 0)
      System.out.println(s);
    <font color=#009900>// Пустая строка прерывает выполнение программы</font>
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Причина указания исключения в том, что <A NAME="Index1360"></A><A NAME="Index1361"></A><B>readLine(&#160;)</B> 
  может выбросить <B>IOException</B>. Обратите внимание, что <B>System.in</B> 
  обычно должен быть буферизирован, как и большинство потоков.</FONT><A NAME="_Toc481064756"></A></P>
<A NAME="Heading382"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Замена System.out на PrintWriter</H3>
</FONT>
<P><FONT FACE="Georgia"><B>System.out</B> - это <B>PrintStream</B>, который является 
  <B>OutputStream</B>.<B> PrintWriter</B> имеет конструктор, который принимает 
  в качестве аргумента <B>OutputStream</B>. Таким образом, если вы хотите конвертировать 
  <B>System.out</B> в <B>PrintWriter</B>, используйте этот конструктор:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c11:ChangeSystemOut.java</font>
<font color=#009900>// Перевод System.out в PrintWriter.</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ChangeSystemOut {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    PrintWriter out = 
      <font color=#0000ff>new</font> PrintWriter(System.out, <font color=#0000ff>true</font>);
    out.println(<font color=#004488>"Hello, world"</font>);
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Важно использовать двухаргументную версию конструктора 
  <B>PrintWriter</B> и установить второй аргумент в <B>true</B>, чтобы позволить 
  автоматическое освобождение буфера, в противном случае вы можете не увидеть 
  вывода.</FONT><A NAME="_Toc481064757"></A></P>
<A NAME="Heading383"></A><FONT FACE = "Verdana"> 
<H3 ALIGN="LEFT"> Перенаправление стандартного ввода/вывода<A NAME="Index1362"></A><A NAME="Index1363"></A></H3>
</FONT> 
<p>Класс<FONT FACE="Georgia"> Java <B>System</B> позволяет вам перенаправлять 
  стандартный ввод, вывод и поток вывода ошибок, используя простой вызов статического 
  метода:</FONT></p>
<P><A NAME="Index1364"></A><A NAME="Index1365"></A><FONT FACE="Georgia"><B>setIn(InputStream) 
  </B></FONT><BR>
  <A NAME="Index1366"></A><A NAME="Index1367"></A><FONT FACE="Georgia"><B>setOut(PrintStream)</B></FONT><BR>
  <A NAME="Index1368"></A><A NAME="Index1369"></A><FONT FACE="Georgia"><B>setErr(PrintStream) 
  </B></FONT><BR>
</P>
<P><FONT FACE="Georgia">Перенаправление вывода особенно полезно, если вы неожиданно 
  начнете создание большого объема для вывода на экран, а он будет скроллироваться 
  гораздо быстрее, чем выбудете успевать читать.</FONT><A HREF="#fn59">[59]</a><FONT FACE="Georgia"> 
  Перенаправление ввода важно для программ командной строки, в которых вы захотите 
  протестировать определенные последовательности пользовательского ввода несколько 
  раз. Вот пример, показывающий использование этих методов:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c11:Redirecting.java</font>
<font color=#009900>// Демонстрация перенаправления стандартного ввода/вывода.</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>class</font> Redirecting {
  <font color=#009900>// Исключение выбрасывается на консоль:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
  <font color=#0000ff>throws</font> IOException {
    BufferedInputStream in = 
      <font color=#0000ff>new</font> BufferedInputStream(
        <font color=#0000ff>new</font> FileInputStream(
          <font color=#004488>"Redirecting.java"</font>));
    PrintStream out =
      <font color=#0000ff>new</font> PrintStream(
        <font color=#0000ff>new</font> BufferedOutputStream(
          <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"test.out"</font>)));
    System.setIn(in);
    System.setOut(out);
    System.setErr(out);

    BufferedReader br = 
      <font color=#0000ff>new</font> BufferedReader(
        <font color=#0000ff>new</font> InputStreamReader(System.in));
    String s;
    <font color=#0000ff>while</font>((s = br.readLine()) != <font color=#0000ff>null</font>)
      System.out.println(s);
    out.close(); <font color=#009900>// Помните об этом!</font>
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Эта программа соединяет стандартный ввод с файлом и перенаправляет 
  стандартный вывод и стандартные ошибки в другой файл.</FONT></P>
<P><FONT FACE="Georgia">Перенаправление ввода/вывода управляет потоками байт, 
  а не потоками символов, то есть, скорее, используются <B>InputStream</B> и <B>OutputStream</B>, 
  чем <B>Reader</B> и <B>Writer</B>.</FONT><A NAME="_Toc375545400"></A><A NAME="_Toc481064758"></A></P>
<A NAME="Heading384"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Компрессия<A NAME="Index1370"></A><A NAME="Index1371"></A></H2>
</FONT>
<P><FONT FACE="Georgia">Библиотека ввода/вывода Java содержит классы, поддерживающие 
  чтение и запись потоков в компрессированном формате. Они являются оберткой для 
  существующих классов ввода/вывода для обеспечения возможности компрессирования.</FONT></P>
<P><FONT FACE="Georgia">Эти классы не наследуются от классов <b>Reader</b> и <b>Writer</b>, 
  а вместо этого они являются частью иерархии <b>InputStream</b> и <b>OutputStream</b>. 
  Это происходит потому, что библиотека компрессии работает с байтами, а не с 
  символами. Однако вы можете иногда встретить необходимость смешивания двух типов 
  потоков. (Помните, что вы можете использовать <b>InputStreamReader</b> и <b>OutputStreamWriter</b> 
  для обеспечения простой конвертации одного типа в другой.</FONT><FONT FACE="Georgia">) 
  <A NAME="Index1372"></A><A NAME="Index1373"></A><A NAME="Index1374"></A><A NAME="Index1375"></A><A NAME="Index1376"></A><A NAME="Index1377"></A><A NAME="Index1378"></A><A NAME="Index1379"></A><A NAME="Index1380"></A><A NAME="Index1381"></A><A NAME="Index1382"></A><A NAME="Index1383"></A><A NAME="Index1384"></A><A NAME="Index1385"></A><A NAME="Index1386"></A><A NAME="Index1387"></A></FONT></P>
<TABLE BORDER width="100%">
  <TR VALIGN="TOP"> 
    <TH WIDTH=148 COLSPAN=1 ROWSPAN=1 VALIGN="TOP"> <FONT FACE="Georgia"><B>Классы 
      компрессии </B></FONT></TH>
    <TH WIDTH=211 COLSPAN=1 ROWSPAN=1 VALIGN="TOP"> <FONT FACE="Georgia"><B>Функция</B></FONT></TH>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>CheckedInputStream</B></FONT></TD>
    <TD> <FONT FACE="Georgia"><B>GetCheckSum(&#160;)</B> производит контрольную 
      сумму для любого <B>InputStream</B> (только не декомпрессию).</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>CheckedOutputStream</B></FONT></TD>
    <TD> <FONT FACE="Georgia"><B>GetCheckSum(&#160;)</B> производит контрольную 
      сумму для любого <B>OutputStream</B> (только не декомпрессию).</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>DeflaterOutputStream</B></FONT></TD>
    <TD> <FONT FACE="Georgia">Базовый класс для классов компрессии.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>ZipOutputStream</B></FONT></TD>
    <TD> <FONT FACE="Georgia"> <B>DeflaterOutputStream</B>, который компрессирует 
      данные в файл формата Zip.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>GZIPOutputStream</B></FONT></TD>
    <TD> <FONT FACE="Georgia"> <B>DeflaterOutputStream</B>, который компрессирует 
      данные в файл формата GZIP.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>InflaterInputStream</B></FONT></TD>
    <TD> <FONT FACE="Georgia">Базовый класс для классов декомпрессии.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>ZipInputStream</B></FONT></TD>
    <TD> <FONT FACE="Georgia"> <B>InflaterInputStream</B>, который декомпрессирует 
      данные, хранящиеся в файле формата Zip.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD> <FONT FACE="Georgia"><B>GZIPInputStream</B></FONT></TD>
    <TD> <FONT FACE="Georgia"> <B>InflaterInputStream</B>, который декомпрессирует 
      данные, хранящиеся в файле формата GZIP.</FONT></TD>
  </TR>
</TABLE>
<p></P>
<P><FONT FACE="Georgia">Хотя существует много алгоритмов компрессии, Zip и GZIP, 
  вероятно, наиболее часто используемые. Поэтому вы можете легко манипулировать 
  вашими компрессированными данными с помощью многих инструментов, существующих 
  для чтения и записи этих форматов.</FONT><A NAME="_Toc481064759"></A></P>
<A NAME="Heading385"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Простая компрессия с помощью GZIP</H3>
</FONT>
<P><FONT FACE="Georgia">Интерфейс GZIP прост, и поэтому он является более подходящим, 
  когда вы имеете единственный поток данных, которые хотите компрессировать (в 
  отличие от случая, когда вы имеете кусочки разнородных данных). Здесь приведен 
  пример компрессии единичного файла:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c11:GZIPcompress.java</font>
<font color=#009900>// Использование GZIP компрессии для компрессирования
// файла, имя которого получается из командной строки.</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.zip.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> GZIPcompress {
  <font color=#009900>// Исключение выбрасываются на консоль:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
  <font color=#0000ff>throws</font> IOException {
    BufferedReader in =
      <font color=#0000ff>new</font> BufferedReader(
        <font color=#0000ff>new</font> FileReader(args[0]));
    BufferedOutputStream out =
      <font color=#0000ff>new</font> BufferedOutputStream(
        <font color=#0000ff>new</font> GZIPOutputStream(
          <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"test.gz"</font>)));
    System.out.println(<font color=#004488>"Writing file"</font>);
    <font color=#0000ff>int</font> c;
    <font color=#0000ff>while</font>((c = in.read()) != -1)
      out.write(c);
    in.close();
    out.close();
    System.out.println(<font color=#004488>"Reading file"</font>);
    BufferedReader in2 =
      <font color=#0000ff>new</font> BufferedReader(
        <font color=#0000ff>new</font> InputStreamReader(
          <font color=#0000ff>new</font> GZIPInputStream(
            <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"test.gz"</font>))));
    String s;
    <font color=#0000ff>while</font>((s = in2.readLine()) != <font color=#0000ff>null</font>)
      System.out.println(s);
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Использование классов компрессии достаточно понятно &#8212; 
  вы просто оборачиваете ваш поток вывода в <B>GZIPOutputStream</B> или <B>ZipOutputStream</B>, 
  а ваш поток ввода в <B>GZIPInputStream</B> или <B>ZipInputStream</B>. Все остальное 
  - это обычные операции чтения и записи. Это пример смешивания символьно-ориентированных 
  потоков и байт-ориентированных потоков: <B>in</B> использует класс <B>Reader</B>, 
  несмотря на то, что конструктор <B>GZIPOutputStream</B> может принимать только 
  объекты <B>OutputStream</B>, а не объекты <B>Writer</B>. Когда файл будет открыт, 
  <B>GZIPInputStream</B> конвертируется в <B>Reader</B>.</FONT><A NAME="_Toc481064760"></A></P>
<A NAME="Heading386"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Многофайловое хранение с использованием Zip</H3>
</FONT>
<P><FONT FACE="Georgia">Библиотека, поддерживающая Zip формат, более обширная. 
  С ее помощью вы можете легко хранить множественные файлы, есть даже отдельные 
  файлы, которые делают легким процесс чтения Zip файла. Библиотека использует 
  стандартный Zip формат, так что он может работать совместно со всеми инструментами, 
  которые доступны в Internet. Следующий пример имеет ту же форму, что и предыдущий, 
  но он обрабатывает столько аргументов командной строки, сколько вы захотите. 
  Кроме того, он показывает использование классов <A NAME="Index1388"></A><B>Checksum</B> 
  для подсчета и проверки контрольной суммы для файла. Есть два типа <B>Checksum</B> 
  : <A NAME="Index1389"></A><B>Adler32</B> (который быстрее) и <A NAME="Index1390"></A><B>CRC32</B> 
  (который медленнее, но немного более аккуратный).</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c11:ZipCompress.java</font>
<font color=#009900>// Использует компрессию Zip для компрессии любого</font>
<font color=#009900>// числа файлов, переданных из командной строки.</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> java.util.zip.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ZipCompress {
  <font color=#009900>// Исключение выбрасывается на консоль:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
  <font color=#0000ff>throws</font> IOException {
    FileOutputStream f =
      <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"test.zip"</font>);
    CheckedOutputStream csum =
      <font color=#0000ff>new</font> CheckedOutputStream(
        f, <font color=#0000ff>new</font> Adler32());
    ZipOutputStream out =
      <font color=#0000ff>new</font> ZipOutputStream(
        <font color=#0000ff>new</font> BufferedOutputStream(csum));
    out.setComment(<font color=#004488>"A test of Java Zipping"</font>);
    <font color=#009900>// Хотя нет соответствующего getComment().</font>
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; args.length; i++) {
      System.out.println(
        <font color=#004488>"Writing file "</font> + args[i]);
      BufferedReader in =
        <font color=#0000ff>new</font> BufferedReader(
          <font color=#0000ff>new</font> FileReader(args[i]));
      out.putNextEntry(<font color=#0000ff>new</font> ZipEntry(args[i]));
      <font color=#0000ff>int</font> c;
      <font color=#0000ff>while</font>((c = in.read()) != -1)
        out.write(c);
      in.close();
    }
    out.close();
    <font color=#009900>// Контрольная сумма действительна только после</font>
    <font color=#009900>// того, как файл будет закрыт!</font>
    System.out.println(<font color=#004488>"Checksum: "</font> +
      csum.getChecksum().getValue());
    <font color=#009900>// Теперь вытянем файлы:</font>
    System.out.println(<font color=#004488>"Reading file"</font>);
    FileInputStream fi =
       <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"test.zip"</font>);
    CheckedInputStream csumi =
      <font color=#0000ff>new</font> CheckedInputStream(
        fi, <font color=#0000ff>new</font> Adler32());
    ZipInputStream in2 =
      <font color=#0000ff>new</font> ZipInputStream(
        <font color=#0000ff>new</font> BufferedInputStream(csumi));
    ZipEntry ze;
    <font color=#0000ff>while</font>((ze = in2.getNextEntry()) != <font color=#0000ff>null</font>) {
      System.out.println(<font color=#004488>"Reading file "</font> + ze);
      <font color=#0000ff>int</font> x;
      <font color=#0000ff>while</font>((x = in2.read()) != -1)
        System.out.write(x);
    }
    System.out.println(<font color=#004488>"Checksum: "</font> +
      csumi.getChecksum().getValue());
    in2.close();
    <font color=#009900>// Альтернативный способ для открытия и чтения</font>
    <font color=#009900>// zip файлов:</font>
    ZipFile zf = <font color=#0000ff>new</font> ZipFile(<font color=#004488>"test.zip"</font>);
    Enumeration e = zf.entries();
    <font color=#0000ff>while</font>(e.hasMoreElements()) {
      ZipEntry ze2 = (ZipEntry)e.nextElement();
      System.out.println(<font color=#004488>"File: "</font> + ze2);
      <font color=#009900>// ... и вытягиваем данные, как и раньше</font>
    }
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Для каждого файла, добавляемого в архив, вы должны вызвать 
  <b>putNextEntry(&#160;) </b>и передать ему объект <a name="Index1391"></a><a name="Index1392"></a><b>ZipEntry</b>. 
  Объект <b>ZipEntry</b> содержит обширный интерфейс, который позволит вам получить 
  и установить все данные, доступные для этого конкретного включения в ваш Zip 
  файл: имя, компрессированный и не компрессированный размеры, дата, CRC контрольная 
  сумма, дополнительное поле данных, комментарий, метод компрессии и есть ли включаемые 
  директории. Однако, хотя формат Zip имеет возможность установки пароля, это 
  не поддерживается в Zip библиотеке Java. И хотя <b>CheckedInputStream</b> и 
  <b>CheckedOutputStream</b> поддерживают обе контрольные суммы <b>Adler32</b> 
  и <b>CRC32</b>, класс <b>ZipEntry</b> поддерживает только интерфейс для CRC. 
  Это является ограничением лежащего в основе Zip формата, и это может ограничить 
  вас в использовании быстрого <b>Adler32</b>.</FONT></P>
<P><FONT FACE="Georgia">Для извлечения файлов <B>ZipInputStream</B> имеет метод 
  <B>getNextEntry(&#160;)</B>, который возвращает следующий <b>ZipEntry</b>, если 
  он существует. В качестве более краткой альтернативы, вы можете читать файл, 
  используя объект <b>ZipFile</b>, который имеет метод <b>entries(&#160;)</b>, 
  возвращающий <b>Enumeration</b> из <b>ZipEntries</b>.</FONT></P>
<P><FONT FACE="Georgia">Для чтения контрольной суммы вы должны как-то получить 
  доступ к ассоциированному объекту <b>Checksum</b>. Здесь получается ссылка на 
  объекты <b>CheckedOutputStream</b> и <b>CheckedInputStream</b>, но вы также 
  могли просто владеть ссылкой на объект <b>Checksum</b>.</FONT></P>
<DIV ALIGN="LEFT"></DIV>
<P><FONT FACE="Georgia">Трудным методом для потоков Zip является <b>setComment(&#160;)</b>. 
  Как показано выше, вы можете установить комментарий, когда вы записываете файл, 
  но нет способа получить коментарий в <b>ZipInputStream</b>. Комментарии появились 
  для полной поддержки базиса включение-за-включением только через <b>ZipEntry</b>.</FONT></P>
<P><FONT FACE="Georgia">Конечно, вы не ограничены в файлах, когда используете 
  библиотеки <B>GZIP</B> или <B>Zip</B> &#8212; вы можете компрессировать все, 
  что угодно, включая данные для посылки через сетевое соединение.</FONT><A NAME="_Toc481064761"></A></P>
<DIV ALIGN="LEFT"></DIV>
<A NAME="Heading387"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Java архивы (JAR'ы)</H3>
</FONT> 
<P><FONT FACE="Georgia">Формат Zip также используется в файле, формата <a name="Index1393"></a><a name="Index1394"></a>JAR 
  (Java ARchive), который является способом сбора группы файлов в один компрессированный 
  файл, так же как и Zip. Однако, как и все остальное в Java, JAR файлы являются 
  кроссплатформенными, так что вам не нужно беспокоится о возможностях платформы. 
  Вы также можете включить звуковой и графический файл наряду с файлами классов.</FONT></P>
<P><FONT FACE="Georgia">JAR файлы обычно полезны, когда вы имеете дело с Internet. 
  До появления JAR файлов ваш Web броузер делал повторяющиеся запросы к Web серверу 
  для загрузки всех файлов, из которых состоит апплет. Кроме того, каждый из этих 
  файлов был не компрессирован. При сборе всех этих файлов для определенного апплета 
  в единый JAR файл необходим только один запрос к серверу, а передача пройдет 
  быстрее из-за компрессии. А каждое включение в JAR файл может иметь цифровую 
  подпись для безопасности (обратитесь за деталями к документации по Java).</FONT></P>
<P><FONT FACE="Georgia"> JAR файл состоит из единого файла, содержащего набор 
  файлов, упакованных с помощью Zip, наряду с &#8220;<a name="Index1395"></a>манифестом&#8221;, 
  который описывает их. (Вы можете создать свой собственный файл манифеста; в 
  противном случае программа <b>jar </b>сделает это за вас.) Вы можете найти больше 
  информации о файлах манифеста JAR в HTML документации для JDK.</FONT></P>
<P><FONT FACE="Georgia">Утилита <B>jar</B>, пришедшая вместе с JDK от Sun, автоматически 
  компрессирует файлы по вашему выбору. Вы можете вызвать ее из командной строки:</FONT></P>
<DIV ALIGN="LEFT"></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>jar [options] destination [manifest] inputfile(s)</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Опции - это просто набор символов (не нужно ни дефисов, 
  ни другой индикации). Пользователи Unix/Linux заметят сходство с опциями <B>tar</B>. 
  Вот они:</FONT></P>
<TABLE BORDER width="100%">
  <TR VALIGN="TOP"> 
    <TD width="6%"> <FONT FACE="Georgia"><B>c</B></FONT></TD>
    <TD width="94%"> <FONT FACE="Georgia">Создает новый или пустой архив.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD width="6%"> <FONT FACE="Georgia"><B>t</B></FONT></TD>
    <TD width="94%"> <FONT FACE="Georgia">Список содержания.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD width="6%"> <FONT FACE="Georgia"><B>x</B></FONT></TD>
    <TD width="94%"> <FONT FACE="Georgia">Извлечь все файлы.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD width="6%"> <FONT FACE="Georgia"><B>x file</B></FONT></TD>
    <TD width="94%"> <FONT FACE="Georgia">Извлекает указанный файл.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD width="6%"> <FONT FACE="Georgia"><B>f</B></FONT></TD>
    <TD width="94%"> <FONT FACE="Georgia">Говорит: &#8220;Я дам тебе имя файла&#8221;. 
      Если вы не используете это, jar поймет, что ввод должен идти через стандартный 
      ввод или, если создается файл, вывод происходит через стандартный вывод.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD width="6%"> <FONT FACE="Georgia"><B>m</B></FONT></TD>
    <TD width="94%"> <FONT FACE="Georgia">Говорит о том, что первый аргумент будет 
      именем файла манифеста, созданного пользователем.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD width="6%"> <FONT FACE="Georgia"><B>v</B></FONT></TD>
    <TD width="94%"> <FONT FACE="Georgia">Генерирует подробный вывод, описывающий 
      то, что делает jar.</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD width="6%"> <FONT FACE="Georgia"><B>0</B></FONT></TD>
    <TD width="94%"> <FONT FACE="Georgia">Только хранение файлов; не компрессирует 
      файлы (используйте для создания JAR файла, который вы можете поместить в 
      ваш classpath).</FONT></TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD width="6%"> <FONT FACE="Georgia"><B>M</B></FONT></TD>
    <TD width="94%"> 
      <DIV ALIGN="LEFT">
        <P><FONT FACE="Georgia">Не выполняется автоматическое создание файла манифеста.</FONT></P>
      </DIV>
    </TD>
  </TR>
</TABLE>
<p></P>
<DIV ALIGN="LEFT">
  <P><FONT FACE="Georgia">Если поддиректории включаются в файлы, помещаемые в 
    JAR файл, эти поддиректории добавляются автоматически, включая все вложенные 
    поддиректории и т.д. Информация о пути тоже сохраняется.</FONT></P>
</DIV>
<DIV ALIGN="LEFT">
  <P><FONT FACE="Georgia">Вот типичный способ вызова <B>jar</B>:</FONT></P>
</DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>jar cf myJarFile.jar *.<font color=#0000ff>class</font></PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Это создает JAR файл, называемый <B>myJarFile.jar</B>, 
  содержащий все файлы классов из текущей директории наряду с автоматически сгенерированным 
  файлом манифеста.</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>jar cmf myJarFile.jar myManifestFile.mf *.<font color=#0000ff>class</font></PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Как и в предыдущем примере, но добавляется файл манифеста, 
  созданный пользователем. Он называется <B>myManifestFile.mf</B>.</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>jar tf myJarFile.jar</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Производится содержание файла <B>myJarFile.jar</B>.</FONT><FONT SIZE = "+1"></FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE>jar tvf myJarFile.jar</PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Добавляет флаг &#8220;verbose&#8221;, чтобы получить более 
  детальную информацию о файлах в <B>myJarFile.jar</B>.</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>jar cvf myApp.jar audio classes image</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Принимая во внимание, что <B>audio</B>, <B>classes</B> 
  и <B>image</B> являются поддиректориями, таким образом, все собирается в файл 
  <b>myApp.jar</b>. Также включен флаг &#8220;verbose&#8221;, чтобы иметь обратную 
  связь, пока работает программа <b>jar</b>.</FONT></P>
<P><FONT FACE="Georgia">Если вы создаете JAR файл, используя опцию <B>0</B>, такой 
  файл может быть помещен в ваш CLASSPATH:</FONT></P>
<DIV ALIGN="LEFT"></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>CLASSPATH=<font color=#004488>"lib1.jar;lib2.jar;"</font></PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">После этого Java может искать <b></b>файлы <B>lib1.jar</B> 
  и <B>lib2.jar</B>.</FONT></P>
<P><FONT FACE="Georgia">Инструмент <B>jar</B> не является таким же полезным, как 
  утилита <b>zip</b>. Например, вы не можете добавить или обновить файлы существующего 
  JAR файла; вы можете создать JAR файл только с самого начала. Также вы не можете 
  переместить файл в JAR файл и стереть его сразу, как только он будет перемещен. 
  Однако JAR файл, созданный на одной платформе, может быть прочитан инструментом 
  <b>jar</b> на любой другой платформе (проблема, которая иногда надоедает с утилитой 
  <b>zip</b>).</FONT></P>
<P><FONT FACE="Georgia">Как вы увидите в <a href="Chapter13.html">Главе 13</a>, 
  JAR файлы также используются для упаковки JavaBeans.</FONT><A NAME="_Toc481064762"></A></P>
<DIV ALIGN="LEFT"></DIV>
<A NAME="Heading388"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Сериализация объектов<A NAME="Index1396"></A><A NAME="Index1397"></A><A NAME="Index1398"></A><A NAME="Index1399"></A><A NAME="Index1400"></A><A NAME="Index1401"></A></H2>
</FONT> 
<P><FONT FACE="Georgia"><i>Сериализация объектов</i> Java позволяет вам взять 
  любой объект, который реализует интерфейс <b>Serializable</b> и включит его 
  в последовательность байт, которые могут быть полностью восстановлены для регенерации 
  оригинального объекта. Это также выполняется при передаче по сети, что означает, 
  что механизм сериализации автоматически поддерживается на различных операционных 
  системах. То есть, вы можете создать объект на машине с Windows, сериализовать 
  его и послать по сети на Unix машину, где он будет корректно реконструирован. 
  Вам не нужно будет беспокоиться о представлении данных на различных машинах, 
  порядке следования байт и любых других деталях.</FONT></P>
<P><FONT FACE="Georgia">Сама по себе сериализация объектов очень интересна, потому 
  что это позволяет вам реализовать <i>устойчивую живучесть</i>. Помните, что 
  живучесть означает, что продолжительность жизни объектов не определяется тем, 
  выполняется ли программа &#8212; объекты живут <i>в промежутках между</i> вызовами 
  программы. Вы берете сериализованный объект и записываете его на диск, затем 
  восстанавливаете объект при новом вызове программы, таким образом, вы способны 
  обеспечить эффективную живучесть. Причина названия &#8220;устойчивая&#8221; 
  в том, что вы не можете просто определить объект, используя какой-либо вид ключевого 
  слова &#8220;устойчивый&#8221;, и позволить системе заботиться о деталях (хотя 
  это может случиться в будущем). Вместо этого вы должны явно сериализовать и 
  десериализовать объекты в вашей программе.</FONT></P>
<P><FONT FACE="Georgia">Сериализация объектов была добавлена в язык для поддержки 
  двух главных особенностей. <i>Удаленный вызов методов</i> (RMI) в Java позволяет 
  объектам существовать на другой машине и вести себя так, как будто они существуют 
  на вашей машине. Когда посылается сообщение удаленному объекту, необходима сериализация 
  объекта для транспортировки аргументов и возврата значений. RMI обсуждается 
  в <a href="Chapter15.html">Главе 15</a>.</FONT></P>
<P><FONT FACE="Georgia">Сериализация объектов так же необходима для JavaBeans, 
  описанных в <a href="Chapter13.html">Главе 13</a>. Когда используется компонент 
  (Bean), информация о его состоянии обычно конфигурируется во время дизайна. 
  Эта информации о состоянии должна сохранятся, а затем восстанавливаться, когда 
  программа запускается; cериализация объектов выполняет эту задачу.</FONT></P>
<P><FONT FACE="Georgia">Сериализация объекта достаточно проста, если объект реализует 
  интерфейс <b>Serializable</b> (этот интерфейс похож на флаг и не имеет методов). 
  Когда сериализация была добавлена в язык, многие стандартные библиотеки классов 
  были изменены, чтобы сделать их сериализованными, включая все оболочки примитивных 
  типов, все контейнерные классы и многие другие. Даже объект <b>Class</b> может 
  быть сериализован. (Смотрите <a href="Chapter12.html">Главу 12</a> о реализации 
  этого.)</FONT></P>
<P><FONT FACE="Georgia">Для сериализации объекта вы создаете определенный сорт 
  объекта <b>OutputStream</b>, а затем вкладываете его в объект <b>ObjectOutputStream</b>. 
  После этого вам достаточно вызвать <a name="Index1404"></a><a name="Index1405"></a><b>writeObject(&#160;)</b> 
  и ваш объект будет сериализован и послан в <b>OutputStream</b>. Чтобы провести 
  обратный процесс, вы вкладываете <b>InputStream</b> внутрь <b>ObjectInputStream</b> 
  и вызываете <a name="Index1406"></a><a name="Index1407"></a><b>readObject(&#160;)</b>. 
  То, что приходит, обычно это ссылка на родительский <b>Object</b>, так что вы 
  должны выполнить обратное приведение, чтобы сделать вещи правильными.</FONT></P>
<P><FONT FACE="Georgia">Особенно полезное свойство сериализации объектов состоит 
  в том, что при этом сохраняется не только образ объекта, а за ним также следуют 
  все ссылки, содержащиеся в вашем объекте. <i>Эти</i> объекты также сохраняются, 
  а за ними следуют все ссылки из каждого объекта, и т.д. Иногда это называется 
  &#8220;<a name="Index1408"></a><a name="Index1409"></a>паутиной объектов&#8221;, 
  так как единственный объект может быть присоединен к чему-то, и может содержать 
  массив ссылок на объекты точно так же, как и на члены объектов. Если вы поддерживаете 
  собственную схему сериализации объектов, код, поддерживающий все эти ссылки, 
  может свести с ума. Однако сериализация объектов в Java, по видимому, осуществляет 
  это безупречно, используя, несомненно, оптимизированный алгоритм, который исследует 
  всю паутину объектов. Следующий пример проверяет механизм сериализации, создавая 
  &#8220;цепочку&#8221; связанных объектов, каждый из которых имеет ссылку на 
  следующий сегмент цепочки точно так же, как и массив ссылок указывает на объекты 
  различных классов</FONT><FONT FACE="Georgia">:</FONT></P>
<DIV ALIGN="LEFT"></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"> 
  <PRE><font color=#009900>//: c11:Worm.java</font>
<font color=#009900>// Демонстрация сериализации объектов.</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>class</font> Data <font color=#0000ff>implements</font> Serializable {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> i;
  Data(<font color=#0000ff>int</font> x) { i = x; }
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> Integer.toString(i);
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Worm <font color=#0000ff>implements</font> Serializable {
  <font color=#009900>// Генерируется случайно значение типа int:</font>
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> r() {
    <font color=#0000ff>return</font> (<font color=#0000ff>int</font>)(Math.random() * 10);
  }
  <font color=#0000ff>private</font> Data[] d = {
    <font color=#0000ff>new</font> Data(r()), <font color=#0000ff>new</font> Data(r()), <font color=#0000ff>new</font> Data(r())
  };
  <font color=#0000ff>private</font> Worm next;
  <font color=#0000ff>private</font> <font color=#0000ff>char</font> c;
  <font color=#009900>// Значение i == Номеру сегмента</font>
  Worm(<font color=#0000ff>int</font> i, <font color=#0000ff>char</font> x) {
    System.out.println(<font color=#004488>" Worm constructor: "</font> + i);
    c = x;
    <font color=#0000ff>if</font>(--i &gt; 0)
      next = <font color=#0000ff>new</font> Worm(i, (<font color=#0000ff>char</font>)(x + 1));
  }
  Worm() {
    System.out.println(<font color=#004488>"Default constructor"</font>);
  }
  <font color=#0000ff>public</font> String toString() {
    String s = <font color=#004488>":"</font> + c + <font color=#004488>"("</font>;
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; d.length; i++)
      s += d[i].toString();
    s += <font color=#004488>")"</font>;
    <font color=#0000ff>if</font>(next != <font color=#0000ff>null</font>)
      s += next.toString();
    <font color=#0000ff>return</font> s;
  }
  <font color=#009900>// Исключение выбрасывается на консоль:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
  <font color=#0000ff>throws</font> ClassNotFoundException, IOException {
    Worm w = <font color=#0000ff>new</font> Worm(6, 'a');
    System.out.println(<font color=#004488>"w = "</font> + w);
    ObjectOutputStream out =
      <font color=#0000ff>new</font> ObjectOutputStream(
        <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"worm.out"</font>));
    out.writeObject(<font color=#004488>"Worm storage"</font>);
    out.writeObject(w);
    out.close(); <font color=#009900>// Также очищается вывод</font>
    ObjectInputStream in =
      <font color=#0000ff>new</font> ObjectInputStream(
        <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"worm.out"</font>));
    String s = (String)in.readObject();
    Worm w2 = (Worm)in.readObject();
    System.out.println(s + <font color=#004488>", w2 = "</font> + w2);
    ByteArrayOutputStream bout =
      <font color=#0000ff>new</font> ByteArrayOutputStream();
    ObjectOutputStream out2 =
      <font color=#0000ff>new</font> ObjectOutputStream(bout);
    out2.writeObject(<font color=#004488>"Worm storage"</font>);
    out2.writeObject(w);
    out2.flush();
    ObjectInputStream in2 =
      <font color=#0000ff>new</font> ObjectInputStream(
        <font color=#0000ff>new</font> ByteArrayInputStream(
          bout.toByteArray()));
    s = (String)in2.readObject();
    Worm w3 = (Worm)in2.readObject();
    System.out.println(s + <font color=#004488>", w3 = "</font> + w3);
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Чтобы сделать пример интереснее, массив объектов <b>Data</b> 
  внутри <b>Worm</b> инициализируется случайными числами. (Этот способ не дает 
  компилятору представление о типе хранимой мета информации.) Каждый сегмент цепочки 
  (<b>Worm</b>) помечается символом (<b>char</b>), который генерируется автоматически 
  в процессе рекурсивной генерации связанного списка <b>Worm</b>. Когда вы создаете 
  <b>Worm</b>, вы говорите конструктору необходимую вам длину. Чтобы сделать следующую<b> 
  </b>ссылку (<b>next</b>), вызывается конструктор <b>Worm</b> с длиной на единичку 
  меньше, и т.д. Последняя ссылка <b>next</b> остается равной <b>null</b>, указывая 
  на конец цепочки <b>Worm</b>.</FONT></P>
<P><FONT FACE="Georgia">Все это сделано для создания чего-то достаточно сложного, 
  что не может быть легко сериализовано. Однако действия, направленные на сериализацию, 
  достаточно просты. Как только создается объект <b>ObjectOutputStream</b> из 
  некоторого другого потока, <b>writeObject(&#160;)</b> сериализует объект. Обратите 
  внимание, что вызов <b>writeObject(&#160;)</b> для <b>String</b> такой же. Вы 
  также можете записать все примитивные типы, используя тот же метод <b>DataOutputStream</b> 
  (они задействуют тот же интерфейс).</FONT></P>
<P><FONT FACE="Georgia">Здесь есть две различные секции кода, которые выглядят 
  одинаково. Первая пишет и читает файл, а вторая, для разнообразия, пишет и читает 
  <b>ByteArray</b>. Вы можете прочесть и записать объект, используя сериализацию 
  для любого <b>DataInputStream</b> или <b>DataOutputStream</b>, включая, как 
  вы увидите в <a href="Chapter15.html">Главе 15</a>, сеть. Вывод после одного 
  запуска имеет вид:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Worm constructor: 6
Worm constructor: 5
Worm constructor: 4
Worm constructor: 3
Worm constructor: 2
Worm constructor: 1
w = :a(262):b(100):c(396):d(480):e(316):f(398)
Worm storage, w2 = :a(262):b(100):c(396):d(480):e(316):f(398)
Worm storage, w3 = :a(262):b(100):c(396):d(480):e(316):f(398)</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Вы можете видеть, что десериализованный объект на самом 
  деле содержит все ссылки, которые были в оригинальном объекте.</FONT></P>
<P><FONT FACE="Georgia">Обратите внимание, что в процессе десериализации объекта 
  <b>Serializable</b> не вызывается ни конструктор, ни даже конструктор по умолчанию.</FONT></P>
<P><FONT FACE="Georgia">Сериализация объектов является <B>byte</B>-ориентированной, 
  и поэтому используется иерархия <B>InputStream</B> и <B>OutputStream</B>.</FONT><A NAME="_Toc481064763"></A></P>
<DIV ALIGN="LEFT"></DIV>
<A NAME="Heading389"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Нахождение класса</H3>
</FONT>
<P><FONT FACE="Georgia">Вы можете задаться вопросом, что необходимо для восстановления 
  объекта из его сериализованного состояния. Например, предположим, вы сериализовали 
  объект и послали его в файл или по сети на другую машину. Может ли программа 
  на другой машине реконструировать объект, используя только содержимое файла?</FONT></P>
<P><FONT FACE="Georgia">Лучшим способом для ответа на этот вопрос (как обычно) 
  будет проведение эксперимента. Следующий файл содержится в поддиректории для 
  этой главы:</FONT></P>
<DIV ALIGN="LEFT"></DIV>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c11:Alien.java</font>
<font color=#009900>// Сериализуемый класс.</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Alien <font color=#0000ff>implements</font> Serializable {
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Файл, который создает и сериализует объект <B>Alien</B>, 
  содержится в том же директории:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c11:FreezeAlien.java</font>
<font color=#009900>// Создает файл сериализации.</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> FreezeAlien {
  <font color=#009900>// Выбрасывает исключение на консоль:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
  <font color=#0000ff>throws</font> IOException {
    ObjectOutput out = 
      <font color=#0000ff>new</font> ObjectOutputStream(
        <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"X.file"</font>));
    Alien zorcon = <font color=#0000ff>new</font> Alien();
    out.writeObject(zorcon); 
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">С точки зрения поимки и обработки исключений, эта программа 
  выбрала быстрый и грязный способ передачи исключений наружу <b>main(&#160;)</b>, 
  так что информация о них будет помещаться в командной строке.</FONT></P>
<P><FONT FACE="Georgia">Как только программа будет скомпилирована и запущена, 
  скопируйте результирующий файл <B>X.file</B> в поддиректорий, под названием 
  <B>xfiles</B>, где имеется следующий код:</FONT></P>
<DIV ALIGN="LEFT"></DIV>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c11:xfiles:ThawAlien.java</font>
<font color=#009900>// Пробуем восстановить сериализованный файл</font>
<font color=#009900>// без объекта класса, хранимого в файле.</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ThawAlien {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
  <font color=#0000ff>throws</font> IOException, ClassNotFoundException {
    ObjectInputStream in =
      <font color=#0000ff>new</font> ObjectInputStream(
        <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"X.file"</font>));
    Object mystery = in.readObject();
    System.out.println(mystery.getClass());
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Эта программа открывает файл и успешно читает объект <b>mystery</b>. 
  Однако, как только вы попробуете найти что-нибудь об объекте &#8212; что требует 
  <b>Class</b> объекта для <b>Alien</b> &#8212; виртуальная машина Java (JVM) 
  не сможет найти <b>Alien.class</b> (если он не будет указан в Classpath, чего 
  не должно случится в этом примере). Вы получите <b>ClassNotFoundException.</b> 
  (Еще раз: все свидетельства иной жизни исчезнут прежде, чем доказательства ее 
  существования могут быть проверены!)</FONT></P>
<P><FONT FACE="Georgia">Если вы хотите многое сделать после восстановления объекта, 
  который был сериализован, вы должны убедится, что JVM может найти соответствующий 
  <B>.class</B> либо по локальному пути классов, либо где-то в Internet.</FONT><A NAME="_Toc481064764"></A></P>
<DIV ALIGN="LEFT"></DIV>
<A NAME="Heading390"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Управление сериализацией<A NAME="Index1410"></A><A NAME="Index1411"></A></H3>
</FONT>
<P><FONT FACE="Georgia">Как вы можете видеть, стандартный механизм сериализации 
  тривиален в использовании. Но что, если вам нужны специальные требования? Может 
  быть, вы имеете особые требования по безопасности и вы не хотите сериализовать 
  часть вашего объекта, или, может быть, не имеет смысла сериализовать один из 
  подобъектов, если эта часть будет вновь создана при восстановлении объекта.</FONT></P>
<P><FONT FACE="Georgia">Вы можете управлять процессом сериализации, реализовав 
  интерфейс <a name="Index1412"></a><a name="Index1413"></a><b>Externalizable</b> 
  вместо интерфейса <a name="Index1414"></a><a name="Index1415"></a><b>Serializable</b>. 
  Интерфейс <b>Externalizable</b> расширяет интерфейс <b>Serializable</b> и добавляет 
  два метода: <a name="Index1416"></a><a name="Index1417"></a><b>writeExternal(&#160;)</b> 
  и <a name="Index1418"></a><a name="Index1419"></a><b>readExternal(&#160;)</b>, 
  которые автоматически вызываются для вашего объекта во время сериализации и 
  десериализации, так что вы можете выполнить специальные операции.</FONT></P>
<P><FONT FACE="Georgia">Следующий пример показывает простую реализацию методов 
  интерфейса <B>Externalizable</B>. Обратите внимание, что <B>Blip1</B> и <B>Blip2</B> 
  почти идентичны, за исключением тонких различий (проверьте, сможете ли вы найти 
  их в коде):</FONT><BR>
</P>
<DIV ALIGN="LEFT"></DIV>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c11:Blips.java</font>
<font color=#009900>// Простое использование Externalizable &amp; ловушка.</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> Blip1 <font color=#0000ff>implements</font> Externalizable {
  <font color=#0000ff>public</font> Blip1() {
    System.out.println(<font color=#004488>"Blip1 Constructor"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> writeExternal(ObjectOutput out)
      <font color=#0000ff>throws</font> IOException {
    System.out.println(<font color=#004488>"Blip1.writeExternal"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> readExternal(ObjectInput in)
     <font color=#0000ff>throws</font> IOException, ClassNotFoundException {
    System.out.println(<font color=#004488>"Blip1.readExternal"</font>);
  }
}

<font color=#0000ff>class</font> Blip2 <font color=#0000ff>implements</font> Externalizable {
  Blip2() {
    System.out.println(<font color=#004488>"Blip2 Constructor"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> writeExternal(ObjectOutput out)
      <font color=#0000ff>throws</font> IOException {
    System.out.println(<font color=#004488>"Blip2.writeExternal"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> readExternal(ObjectInput in)
     <font color=#0000ff>throws</font> IOException, ClassNotFoundException {
    System.out.println(<font color=#004488>"Blip2.readExternal"</font>);
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Blips {
  <font color=#009900>// Исключения выбрасываются на консоль:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
  <font color=#0000ff>throws</font> IOException, ClassNotFoundException {
    System.out.println(<font color=#004488>"Constructing objects:"</font>);
    Blip1 b1 = <font color=#0000ff>new</font> Blip1();
    Blip2 b2 = <font color=#0000ff>new</font> Blip2();
    ObjectOutputStream o =
      <font color=#0000ff>new</font> ObjectOutputStream(
        <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"Blips.out"</font>));
    System.out.println(<font color=#004488>"Saving objects:"</font>);
    o.writeObject(b1);
    o.writeObject(b2);
    o.close();
    <font color=#009900>// Теперь получаем их обратно:</font>
    ObjectInputStream in =
      <font color=#0000ff>new</font> ObjectInputStream(
        <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"Blips.out"</font>));
    System.out.println(<font color=#004488>"Recovering b1:"</font>);
    b1 = (Blip1)in.readObject();
    <font color=#009900>// OOPS! Выброшено исключение:</font>
<font color=#009900>//! System.out.println("Recovering b2:");</font>
<font color=#009900>//! b2 = (Blip2)in.readObject();</font>
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Вывод для этой программы:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Constructing objects:
Blip1 Constructor
Blip2 Constructor
Saving objects:
Blip1.writeExternal
Blip2.writeExternal
Recovering b1:
Blip1 Constructor
Blip1.readExternal</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Причина того, что объект <b>Blip2</b> не восстановлен 
  в том, что происходит попытка сделать нечто, что является причиной исключения. 
  Вы нашли различия между <b>Blip1</b> и <b>Blip2</b>? Конструктор для <b>Blip1</b> 
  является <b>public</b>, в то время как конструктор для <b>Blip2</b> не такой, 
  и поэтому появляется исключение во время восстановления. Попробуйте сделать 
  конструктор <b>Blip2 public</b> и удалите комментарии <b>//!</b>, чтобы увидеть 
  корректный результат.</FONT></P>
<P><FONT FACE="Georgia">Когда восстанавливается <B>b1</B>, вызывается конструктор 
  по умолчанию для <B>Blip1</B>. Это отличается от восстановления объекта с <b>Serializable</b>, 
  в котором конструирование целиком происходит из сохраненных бит без вызова конструктора. 
  Для объектов <b>Externalizable</b> проявляется обычное поведение конструктора 
  по умолчанию (включая инициализацию в точке определения полей), а затем вызывается 
  <b>readExternal(&#160;)</b>. Вы должны осознавать это &#8212; в частности, тот 
  факт, что все конструкторы по умолчанию занимают свое место &#8212; для производства 
  корректного поведения вашего объекта с <b>Externalizable</b>.</FONT></P>
<P><FONT FACE="Georgia"> </FONT><FONT FACE="Georgia">Вот пример, который показывает, 
  что вы должны сделать для полного хранение и восстановления объекта с <B>Externalizable</B>:</FONT><BR>
</P>
<DIV ALIGN="LEFT"></DIV>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c11:Blip3.java</font>
<font color=#009900>// Реконструирование externalizable объекта.</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> Blip3 <font color=#0000ff>implements</font> Externalizable {
  <font color=#0000ff>int</font> i;
  String s; <font color=#009900>// Без инициализации</font>
  <font color=#0000ff>public</font> Blip3() {
    System.out.println(<font color=#004488>"Blip3 Constructor"</font>);
    <font color=#009900>// s, i не инициализируется</font>
  }
  <font color=#0000ff>public</font> Blip3(String x, <font color=#0000ff>int</font> a) {
    System.out.println(<font color=#004488>"Blip3(String x, int a)"</font>);
    s = x;
    i = a;
    <font color=#009900>// s &amp; i инициализируются только в</font>
    <font color=#009900>// конструкторе не по умолчанию.</font>
  }
  <font color=#0000ff>public</font> String toString() { <font color=#0000ff>return</font> s + i; }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> writeExternal(ObjectOutput out)
  <font color=#0000ff>throws</font> IOException {
    System.out.println(<font color=#004488>"Blip3.writeExternal"</font>);
    <font color=#009900>// Вы обязаны сделать это:</font>
    out.writeObject(s); 
    out.writeInt(i);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> readExternal(ObjectInput in)
  <font color=#0000ff>throws</font> IOException, ClassNotFoundException {
    System.out.println(<font color=#004488>"Blip3.readExternal"</font>);
    <font color=#009900>// Вы обязаны сделать это:</font>
    s = (String)in.readObject(); 
    i =in.readInt();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args)
  <font color=#0000ff>throws</font> IOException, ClassNotFoundException {
    System.out.println(<font color=#004488>"Constructing objects:"</font>);
    Blip3 b3 = <font color=#0000ff>new</font> Blip3(<font color=#004488>"A String "</font>, 47);
    System.out.println(b3);
    ObjectOutputStream o =
      <font color=#0000ff>new</font> ObjectOutputStream(
        <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"Blip3.out"</font>));
    System.out.println(<font color=#004488>"Saving object:"</font>);
    o.writeObject(b3);
    o.close();
    <font color=#009900>// Теперь получим обратно:</font>
    ObjectInputStream in =
      <font color=#0000ff>new</font> ObjectInputStream(
        <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"Blip3.out"</font>));
    System.out.println(<font color=#004488>"Recovering b3:"</font>);
    b3 = (Blip3)in.readObject();
    System.out.println(b3);
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Поля <b>s</b> и <b>i</b> инициализируются только во втором 
  конструкторе, но не в конструкторе по умолчанию. Это значит, что если вы не 
  инициализируете <b>s</b> и <b>i</b> в <b>readExternal(&#160;)</b>, они будут 
  равны <b>null</b> (так как хранилище объектов заполняется нулями при первом 
  шаге создания объектов). Если вы закомментируете две строки кода, следующих 
  за фразой &#8220;Вы обязаны сделать это&#8221;, и запустите программу, вы увидите, 
  что при восстановлении объекта <b>s</b> равно <b>null</b>, а <b>i</b> равно 
  нулю.</FONT></P>
<P><FONT FACE="Georgia">Если вы наследуете от объекта с интерфейсом <b>Externalizable</b>, 
  обычно вы будете вызывать методы <b>writeExternal(&#160;) </b>и <b>readExternal(&#160;)</b> 
  базового класса для обеспечения правильного хранения и восстановления компонент 
  базового класса.</FONT></P>
<P><FONT FACE="Georgia">Таким образом, чтобы сделать все правильно, вы должны 
  не только записать важные данные из объекта в методе <b>writeExternal(&#160;)</b> 
  (здесь нет стандартного поведения, при котором записывается любой член объекта 
  с интерфейсом <b>Externalizable</b>), но вы также должны восстановить эти данные 
  в методе <b>readExternal(&#160;)</b>. Сначала это может немного смущать, потому 
  что поведение конструктора по умолчанию объекта с интерфейсом <b>Externalizable</b> 
  может представить все, как некоторый вид автоматического сохранения и восстановления. 
  Но это не так.</FONT></P>
<DIV ALIGN="LEFT"></DIV>
<A NAME="Heading391"></A><FONT FACE = "Verdana">
<H4 ALIGN="LEFT"> Ключевое слово transient</H4>
</FONT> 
<P><FONT FACE="Georgia">Когда вы управляете сериализацией, возможно появление 
  определенных подобъектов, для который вы не захотите применять механизм сериализации 
  Java для автоматического сохранения и восстановления. В основном это происходит 
  в том случае, если такой подобъект представляет важную информацию, которую вы 
  не хотите сериализовать, например, пароль. Даже если такая информация имеет 
  модификатор <b>private</b> в объекте, так как она сериализуется, то кто-либо 
  может получить доступ для чтения файла или перехватить сетевую передачу.</FONT></P>
<P><FONT FACE="Georgia">Один способ предохранения важной части вашего объекта 
  от сериализации, заключающий в реализации <b>Externalizable</b>, показан в предыдущем 
  разделе. Но при этом ничего автоматически не сериализуется и вы должны явно 
  сеарилизовать только нужные вам части внутри <b>writeExternal(&#160;)</b>.</FONT></P>
<P><FONT FACE="Georgia">Однако если вы работаете с <b>Serializable</b> объектом, 
  вся сериализация происходит автоматически. Для управления этим, вы можете выключить 
  сериализацию полей индивидуально, используя ключевое слово <a name="Index1420"></a><a name="Index1421"></a><a name="Index1422"></a><b>transient</b>, 
  которое говорит: &#8220;Не беспокойтесь о сохранении и восстановлении этого 
  &#8212; я позабочусь об этом&#8221;.</FONT></P>
<P><FONT FACE="Georgia">В качестве примера рассмотрим объект <B>Login</B>, хранящий 
  информацию об определенной сессии подключения. Предположим, что как только вы 
  проверили имя пользователя, вы хотите сохранить данные, но без пароля. Простейшим 
  способом является реализация <A NAME="Index1423"></A><B>Serializable</B> и пометка 
  поля <B>password</B> ключевым словом <B>transient</B>. Вот как это выглядит:</FONT></P>
<DIV ALIGN="LEFT"></DIV>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c11:Logon.java</font>
<font color=#009900>// Демонстрация ключевого слова "transient".</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> Logon <font color=#0000ff>implements</font> Serializable {
  <font color=#0000ff>private</font> Date date = <font color=#0000ff>new</font> Date();
  <font color=#0000ff>private</font> String username;
  <font color=#0000ff>private</font> <font color=#0000ff>transient</font> String password;
  Logon(String name, String pwd) {
    username = name;
    password = pwd;
  }
  <font color=#0000ff>public</font> String toString() {
    String pwd =
      (password == <font color=#0000ff>null</font>) ? <font color=#004488>"(n</font><font color=#004488>/a)"</font> : password;
    <font color=#0000ff>return</font> <font color=#004488>"logon info: \n   "</font> +
      <font color=#004488>"username: "</font> + username +
      <font color=#004488>"\n   date: "</font> + date +
      <font color=#004488>"\n   password: "</font> + pwd;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args)
  <font color=#0000ff>throws</font> IOException, ClassNotFoundException {
    Logon a = <font color=#0000ff>new</font> Logon(<font color=#004488>"Hulk"</font>, <font color=#004488>"myLittlePony"</font>);
    System.out.println( <font color=#004488>"logon a = "</font> + a);
      ObjectOutputStream o =
        <font color=#0000ff>new</font> ObjectOutputStream(
          <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"Logon.out"</font>));
    o.writeObject(a);
    o.close();
    <font color=#009900>// Задержка:</font>
    <font color=#0000ff>int</font> seconds = 5;
    <font color=#0000ff>long</font> t = System.currentTimeMillis()
           + seconds * 1000;
    <font color=#0000ff>while</font>(System.currentTimeMillis() &lt; t)
      ;
    <font color=#009900>// Теперь получаем его обратно:</font>
    ObjectInputStream in =
      <font color=#0000ff>new</font> ObjectInputStream(
        <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"Logon.out"</font>));
    System.out.println(
      <font color=#004488>"Recovering object at "</font> + <font color=#0000ff>new</font> Date());
    a = (Logon)in.readObject();
    System.out.println( <font color=#004488>"logon a = "</font> + a);
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Вы можете видеть, что поля <B>date</B> и <B>username</B> 
  являются обычными (не <B>transient</B>), и поэтому сериализуются автоматически. 
  Однако поле <B>password</B> является <B>transient</B>, и поэтому не сохраняется 
  на диске; так же механизм сериализации не делает попытку восстановить его. На 
  выходе получаем:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>logon a = logon info:
   username: Hulk
   date: Sun Mar 23 18:25:53 PST 1997
   password: myLittlePony
Recovering object at Sun Mar 23 18:25:59 PST 1997
logon a = logon info:
   username: Hulk
   date: Sun Mar 23 18:25:53 PST 1997
   password: (n/a)</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Когда объект восстанавливается, поле <b>password</b> заполняется 
  значением <b>null</b>. Обратите внимание, что <b>toString(&#160;)</b> должна 
  проверять значение на равенство <b>null</b> поля <b>password</b>, потому что 
  если вы попробуете собрать объект <b>String</b>, используя перегруженный оператор 
  &#8216;<b>+</b>&#8217;, а этот оператор обнаружит ссылку, равную <b>null</b>, 
  вы получите <b>NullPointerException.</b> (Новые версии Java могут содержать 
  код для предотвращения этой проблемы.)</FONT></P>
<P><FONT FACE="Georgia">Вы также можете заметить, что поле <b>date</b> сохраняется 
  и восстановления с диска и не генерируется заново.</FONT></P>
<P><FONT FACE="Georgia">Так как объекты с интерфейсом <B>Externalizable</B> не 
  сохраняют никакие из своих полей автоматически, поэтому ключевое слово <B>transient</B> 
  используется только для объектов с интерфейсом <B>Serializable</B>.</FONT></P>
<DIV ALIGN="LEFT"></DIV>
<A NAME="Heading392"></A><FONT FACE = "Verdana">
<H4 ALIGN="LEFT"> Альтернатива Externalizable</H4>
</FONT>
<P><FONT FACE="Georgia">Если вы не достаточно сильны в реализации интерфейса <A NAME="Index1424"></A><B>Externalizable</B>, 
  существует другой подход. Вы можете реализовать интерфейс <B>Serializable</B> 
  и добавить (обратите внимание, я сказал &#8220;добавить&#8221;, а не &#8220;перекрыть&#8221; 
  или &#8220;реализовать&#8221;) методы, называемые <A NAME="Index1425"></A><A NAME="Index1426"></A><B>writeObject(&#160;)</B> 
  и <A NAME="Index1427"></A><A NAME="Index1428"></A><B>readObject(&#160;)</B>, 
  которые будут автоматически вызваны, когда объект будет, соответственно, сериализоваться 
  и десериализоваться. То есть, если вы обеспечите эти два метода, они будут использоваться 
  взамен сериализации по умолчанию.</FONT></P>
<P><FONT FACE="Georgia">Методы должны иметь следующие точные сигнатуры:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>private</font> <font color=#0000ff>void</font> 
  writeObject(ObjectOutputStream stream)
    <font color=#0000ff>throws</font> IOException;

<font color=#0000ff>private</font> <font color=#0000ff>void</font> 
  readObject(ObjectInputStream stream)
    <font color=#0000ff>throws</font> IOException, ClassNotFoundException</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">С точки зрения дизайна, это мистические вещи. Прежде всего, 
  вы можете подумать так, потому что эти методы не являются частью базового класса 
  или интерфейса <b>Serializable</b>, следовательно, они не будут определены в 
  своем собственном интерфейсе. Но обратите внимание, что они объявлены как <b>private</b>, 
  что означает, что они будут вызываться только другим членом этого класса. Однако 
  на самом деле вы не вызываете их из других членов этого класса, а вместо этого 
  методы <b>writeObject(&#160;)</b> и <b>readObject(&#160;)</b>, принадлежащие 
  объекту <b>ObjectOutputStream</b> и <b>ObjectInputStream</b>, вызывают методы 
  <b>writeObject(&#160;)</b> и <b>readObject(&#160;)</b> вашего объекта. (Обратите 
  внимание на мою невероятную сдержанность, из-за которой я не пускаюсь в пространные 
  обличительные речи по поводу использования одних и тех же имен методов здесь. 
  Я просто скажу: путаница.) Вы можете быть удивлены, как объекты <b>ObjectOutputStream</b> 
  и <b>ObjectInputStream</b> получают доступ к <b>private</b> методам вашего класса. 
  Мы можем только иметь в виду, что эта часть составляет магию сериализации.</FONT></P>
<P><FONT FACE="Georgia">В любом случае, все, что определено в интерфейсе, автоматически 
  становится <b>public</b>, поэтому, если <b>writeObject(&#160;)</b> и <b>readObject(&#160;)</b> 
  должны быть <b>private</b>, то они не могут быть частью интерфейса. Так как 
  вы должны следовать точным сигнатурам, получаемый эффект тот же самые, как если 
  бы вы реализовали <b>interface</b>.</FONT></P>
<P><FONT FACE="Georgia">Может показаться, что когда вы вызываете <b>ObjectOutputStream.writeObject(&#160;)</b>, 
  объект с интерфейсом <b>Serializable</b>, который вы передаете, опрашивается 
  (используя рефлексию, не имеет значения) на предмет реализации своего собственного 
  <b>writeObject(&#160;)</b>. Если это так, то нормальный процесс сериализации 
  пропускается, и вызывается <b>writeObject(&#160;)</b>. Аналогичная ситуация 
  наблюдается и для <b>readObject(&#160;)</b>.</FONT></P>
<P><FONT FACE="Georgia">Есть еще один поворот. Внутри вашего <B>writeObject(&#160;)</B> 
  вы можете выбрать выполнение стандартного действия <B>writeObject(&#160;)</B>, 
  вызвав <B>defaultWriteObject(&#160;)</B>. Точно так же, внутри <B>readObject(&#160;)</B> 
  вы можете вызвать <B>defaultReadObject(&#160;)</B>. Вот пример, который демонстрирует, 
  как вы можете управлять хранением и восстановлением объектов с интерфейсом <B>Serializable</B>:</FONT></P>
<DIV ALIGN="LEFT"></DIV>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c11:SerialCtl.java</font>
<font color=#009900>// Управление сериализацией, путем добавления</font>
<font color=#009900>// собственных методов writeObject() и readObject().</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SerialCtl <font color=#0000ff>implements</font> Serializable {
  String a;
  <font color=#0000ff>transient</font> String b;
  <font color=#0000ff>public</font> SerialCtl(String aa, String bb) {
    a = <font color=#004488>"Not Transient: "</font> + aa;
    b = <font color=#004488>"Transient: "</font> + bb;
  }
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> a + <font color=#004488>"\n"</font> + b;
  }
  <font color=#0000ff>private</font> <font color=#0000ff>void</font> 
    writeObject(ObjectOutputStream stream)
      <font color=#0000ff>throws</font> IOException {
    stream.defaultWriteObject();
    stream.writeObject(b);
  }
  <font color=#0000ff>private</font> <font color=#0000ff>void</font> 
    readObject(ObjectInputStream stream)
      <font color=#0000ff>throws</font> IOException, ClassNotFoundException {
    stream.defaultReadObject();
    b = (String)stream.readObject();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args)
  <font color=#0000ff>throws</font> IOException, ClassNotFoundException {
    SerialCtl sc = 
      <font color=#0000ff>new</font> SerialCtl(<font color=#004488>"Test1"</font>, <font color=#004488>"Test2"</font>);
    System.out.println(<font color=#004488>"Before:\n"</font> + sc);
    ByteArrayOutputStream buf = 
      <font color=#0000ff>new</font> ByteArrayOutputStream();
    ObjectOutputStream o =
      <font color=#0000ff>new</font> ObjectOutputStream(buf);
    o.writeObject(sc);
    <font color=#009900>// Теперь получим это назад:</font>
    ObjectInputStream in =
      <font color=#0000ff>new</font> ObjectInputStream(
        <font color=#0000ff>new</font> ByteArrayInputStream(
          buf.toByteArray()));
    SerialCtl sc2 = (SerialCtl)in.readObject();
    System.out.println(<font color=#004488>"After:\n"</font> + sc2);
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">В этом примере есть одно обычное поле <b>String</b>, а 
  другое имеет модификатор <b>transient</b>, для обеспечения возможности сохранения 
  не <b>transient</b> поля с помощью метода <a name="Index1429"></a><a name="Index1430"></a><b>defaultWriteObject(&#160;)</b>, 
  а <b>transient</b> поля сохраняются и восстанавливаются явно. Поля инициализируются 
  внутри конструктора, а не в точке определения, чтобы удостоверится, что они 
  не инициализируются каким-либо автоматическим механизмом во время десериализации.</FONT></P>
<P><FONT FACE="Georgia">Если вы будете использовать стандартный механизм записи 
  не <b>transient</b> частей вашего объекта, вы должны вызвать <b>defaultWriteObject(&#160;)</b>, 
  как первое действие <b>writeObject(&#160;)</b> и <a name="Index1431"></a><a name="Index1432"></a><b>defaultReadObject(&#160;)</b>, 
  как первое действие <b>readObject(&#160;)</b>. Это странный вызов методов. Он 
  может показать, например, что вы вызываете <b>defaultWriteObject(&#160;)</b> 
  для <b>ObjectOutputStream</b> и не передаете ему аргументов, но все же как-то 
  происходит включение и узнавание ссылки на ваш объект и способа записи всех 
  не <b>transient</b> частей. Мираж.</FONT></P>
<P><FONT FACE="Georgia">Для хранения и восстановления </FONT> <FONT FACE="Georgia"> 
  <B>transient</B> объектов используется более знакомый код. И еще, подумайте 
  о том, что происходит тут. В <B>main(&#160;)</B> создается объект <B>SerialCtl</B>, 
  а затем он сериализуется в <B>ObjectOutputStream.</B> (Обратите внимание, что 
  в этом случае используется буфер вместо файла &#8212; это все тот же <B>ObjectOutputStream</B>.) 
  Сериализация происходит в строке:</FONT></P>
<DIV ALIGN="LEFT"></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>o.writeObject(sc);</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Метод <B>writeObject(&#160;)</B> должен проверить <B>sc</B> 
  на предмет существования собственного метода <B>writeObject(&#160;)</B>. (Не 
  с помощью проверки интерфейса &#8212; здесь нет его &#8212; или типа класса, 
  а реальной охотой за методом, используя рефлексию.) Если метод существует, он 
  используется. Аналогичный подход используется для <B>readObject(&#160;)</B>. 
  Возможно это чисто практический способ, которым можно решить проблему, но он, 
  несомненно, странен.</FONT></P>
<A NAME="Heading393"></A><FONT FACE = "Verdana">
<H4 ALIGN="LEFT"> Работа с версиями<A NAME="Index1433"></A><A NAME="Index1434"></A></H4>
</FONT>
<P><FONT FACE="Georgia">Возможно, что вам захочется изменить версию сериализованного 
  класса (объекты оригинального класса могут храниться, например, в базе данных). 
  Это допустимо, но вы, вероятно, будете делать это только в специальных случаях, 
  так как это требует дополнительного глубокого понимания, которого мы не достигнем 
  здесь. Документация по JDK в формате HTML, доступная на <i>java.sun.com</i>, 
  описывает эту тему достаточно полно.</FONT></P>
<P><FONT FACE="Georgia">Вы также должны обратить внимание, что в HTML документация 
  JDK многие комментарии начинаются с предупреждения:</FONT></P>
<P><FONT FACE="Georgia"><B><i>Внимание:</i></B><i> Сериализованные объекты этого 
  класса не будут совместимы с будущими выпусками Swing. Существующая поддержка 
  сериализации подходит для кратковременного хранения или для RMI между приложениями. 
  ...</i></FONT></P>
<P><FONT FACE="Georgia">Это происходит потому, что механизм работы с версиями 
  слишком прост для надежной работы во всех ситуациях, особенно с JavaBeans. Он 
  работает корректно для дизайна и это то, о чем говорит это предупреждение.</FONT><A NAME="_Toc481064765"></A></P>
<DIV ALIGN="LEFT"></DIV>
<A NAME="Heading394"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Использование устойчивости<A NAME="Index1435"></A></H3>
</FONT> 
<P><FONT FACE="Georgia">Достаточно привлекательно использовать <a name="Index1436"></a>технологию 
  сериализации для хранения некоторых состояний вашей программы, чтобы в последствии 
  вы могли легко восстановить программу до текущего состояния. Но прежде, чем 
  сделать это, необходимо ответить на некоторые вопросы. Что случится, если вы 
  сериализуете два объекта, оба из которых имеют ссылки на один объект? Когда 
  вы восстановите эти два объекта из их сериализованного состояния, будите ли 
  вы иметь только один экземпляр третьего объекта? Что, если вы сериализуете два 
  объекта в различные файлы, а десериализуете их в различных частях кода?</FONT></P>
<P><FONT FACE="Georgia">Вот пример, показывающий эту проблему:</FONT><BR>
</P>
<DIV ALIGN="LEFT"></DIV>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c11:MyWorld.java</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> House <font color=#0000ff>implements</font> Serializable {}

<font color=#0000ff>class</font> Animal <font color=#0000ff>implements</font> Serializable {
  String name;
  House preferredHouse;
  Animal(String nm, House h) { 
    name = nm; 
    preferredHouse = h;
  }
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> name + <font color=#004488>"["</font> + <font color=#0000ff>super</font>.toString() + 
      <font color=#004488>"], "</font> + preferredHouse + <font color=#004488>"\n"</font>;
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> MyWorld {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args)
  <font color=#0000ff>throws</font> IOException, ClassNotFoundException {
    House house = <font color=#0000ff>new</font> House();
    ArrayList  animals = <font color=#0000ff>new</font> ArrayList();
    animals.add(
      <font color=#0000ff>new</font> Animal(<font color=#004488>"Bosco the dog"</font>, house));
    animals.add(
      <font color=#0000ff>new</font> Animal(<font color=#004488>"Ralph the hamster"</font>, house));
    animals.add(
      <font color=#0000ff>new</font> Animal(<font color=#004488>"Fronk the cat"</font>, house));
    System.out.println(<font color=#004488>"animals: "</font> + animals);

    ByteArrayOutputStream buf1 = 
      <font color=#0000ff>new</font> ByteArrayOutputStream();
    ObjectOutputStream o1 =
      <font color=#0000ff>new</font> ObjectOutputStream(buf1);
    o1.writeObject(animals);
    o1.writeObject(animals); <font color=#009900>// Запись второго класса</font>
    <font color=#009900>// Запись в другой поток:</font>
    ByteArrayOutputStream buf2 = 
      <font color=#0000ff>new</font> ByteArrayOutputStream();
    ObjectOutputStream o2 =
      <font color=#0000ff>new</font> ObjectOutputStream(buf2);
    o2.writeObject(animals);
    <font color=#009900>// Теперь получаем назад:</font>
    ObjectInputStream in1 =
      <font color=#0000ff>new</font> ObjectInputStream(
        <font color=#0000ff>new</font> ByteArrayInputStream(
          buf1.toByteArray()));
    ObjectInputStream in2 =
      <font color=#0000ff>new</font> ObjectInputStream(
        <font color=#0000ff>new</font> ByteArrayInputStream(
          buf2.toByteArray()));
    ArrayList animals1 = 
      (ArrayList)in1.readObject();
    ArrayList animals2 = 
      (ArrayList)in1.readObject();
    ArrayList animals3 = 
      (ArrayList)in2.readObject();
    System.out.println(<font color=#004488>"animals1: "</font> + animals1);
    System.out.println(<font color=#004488>"animals2: "</font> + animals2);
    System.out.println(<font color=#004488>"animals3: "</font> + animals3);
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Одна вещь, которая интересна здесь, состоит в возможности 
  использовать сериализацию объекта через массив байт, как способ выполнения &#8220;глубокого 
  копирования&#8221; любого объекта с интерфейсом <b>Serializable.</b> (Глубокое 
  копирование означает, что вы дублируете всю паутину объектов, а не просто основной 
  объект и принадлежащие ему ссылки.) Более глубоко копирование освещено в <a href="AppendixA.html">Приложении 
  А</a>.</FONT></P>
<P><FONT FACE="Georgia">Объекты <B>Animal</B> содержат поля типа <B>House</B>. 
  В <B>main(&#160;)</B> создается <B>ArrayList</B> из этих <B>Animal</B>, и он 
  сериализуется дважды в один поток, а затем снова в другой поток. Когда это десериализуется 
  и распечатается, вы увидите следующий результат одного запуска (объекты будут 
  располагаться в разных участках памяти при каждом запуске):</FONT></P>
<DIV ALIGN="LEFT"></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>animals: [Bosco the dog[Animal@1cc76c], House@1cc769
, Ralph the hamster[Animal@1cc76d], House@1cc769
, Fronk the cat[Animal@1cc76e], House@1cc769
]
animals1: [Bosco the dog[Animal@1cca0c], House@1cca16
, Ralph the hamster[Animal@1cca17], House@1cca16
, Fronk the cat[Animal@1cca1b], House@1cca16
]
animals2: [Bosco the dog[Animal@1cca0c], House@1cca16
, Ralph the hamster[Animal@1cca17], House@1cca16
, Fronk the cat[Animal@1cca1b], House@1cca16
]
animals3: [Bosco the dog[Animal@1cca52], House@1cca5c
, Ralph the hamster[Animal@1cca5d], House@1cca5c
, Fronk the cat[Animal@1cca61], House@1cca5c
]</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Конечно, вы ожидаете, что десериализованные объекты имеют 
  адреса, отличные от первоначальных. Но обратите внимание, что в <b>animals1</b> 
  и <b>animals2</b> появляется один и тот же адрес, включая ссылки на объект <b>House, 
  </b>который они оба разделяют. С другой стороны, когда восстанавливается <b>animals3</b>, 
  у системы нет способа узнать, что объекты в этом потоке являются алиасами объектов 
  первого потока, так что при этом создается полностью отличная паутина объектов.</FONT></P>
<P><FONT FACE="Georgia">Если вы сериализовали что-то в единственный поток, вы 
  будете способны восстановить ту же паутину объектов, которую вы записали, без 
  случайного дублирования объектов. Конечно, вы можете изменить состояние ваших 
  объектов в промежутке между временем первой и последней записи, но это ваше 
  дело &#8212; объекты будут записаны не зависимо от того, в каком бы состоянии 
  они не были (и со всеми соединениями, которые они имеют с другими объектами) 
  в то время, когда вы сериализуете их.</FONT></P>
<P><FONT FACE="Georgia">Самым безопасным для сохранение состояния системы является 
  сериализация, как &#8220;атомная&#8221; операция. Если вы сериализуете какие-то 
  вещи, выполняете какую-то работу и сериализуйте еще, и т.д., то вы не будете 
  держать систему в безопасности. Вместо этого поместите все объекты, которые 
  относятся к состоянию вашей системы, в единственный контейнер и просто запишите 
  этот контейнер в одной операции. Затем вы можете восстановить его так же единственным 
  вызовом метода.</FONT></P>
<P><FONT FACE="Georgia">Следующий пример относится к мнимой вспомогательной системе 
  компьютерного дизайна (CAD), который демонстрирует такой подход. Кроме того, 
  здесь примешана проблема полей <B>static</B> &#8212; если вы взглянете на документацию, 
  вы увидите, что если <B>Class</B> является сериализуемым, то должно быть легким 
  хранение <B> </B> <B>static</B> поля простой сериализацией объекта <A NAME="Index1437"></A><A NAME="Index1438"></A><B>Class</B>. 
  Тем не менее, такой подход выглядит достаточно важным.</FONT></P>
<DIV ALIGN="LEFT"></DIV>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c11:CADState.java</font>
<font color=#009900>// Запись и восстановление состояния</font>
<font color=#009900>// симулятора системы CAD.</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>abstract</font> <font color=#0000ff>class</font> Shape <font color=#0000ff>implements</font> Serializable {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>final</font> <font color=#0000ff>int</font> 
    RED = 1, BLUE = 2, GREEN = 3;
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> xPos, yPos, dimension;
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Random r = <font color=#0000ff>new</font> Random();
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> counter = 0;
  <font color=#0000ff>abstract</font> <font color=#0000ff>public</font> <font color=#0000ff>void</font> setColor(<font color=#0000ff>int</font> newColor);
  <font color=#0000ff>abstract</font> <font color=#0000ff>public</font> <font color=#0000ff>int</font> getColor();
  <font color=#0000ff>public</font> Shape(<font color=#0000ff>int</font> xVal, <font color=#0000ff>int</font> yVal, <font color=#0000ff>int</font> dim) {
    xPos = xVal;
    yPos = yVal;
    dimension = dim;
  }
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> getClass() + 
      <font color=#004488>" color["</font> + getColor() +
      <font color=#004488>"] xPos["</font> + xPos +
      <font color=#004488>"] yPos["</font> + yPos +
      <font color=#004488>"] dim["</font> + dimension + <font color=#004488>"]\n"</font>;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> Shape randomFactory() {
    <font color=#0000ff>int</font> xVal = r.nextInt() % 100;
    <font color=#0000ff>int</font> yVal = r.nextInt() % 100;
    <font color=#0000ff>int</font> dim = r.nextInt() % 100;
    <font color=#0000ff>switch</font>(counter++ % 3) {
      <font color=#0000ff>default</font>: 
      <font color=#0000ff>case</font> 0: <font color=#0000ff>return</font> <font color=#0000ff>new</font> Circle(xVal, yVal, dim);
      <font color=#0000ff>case</font> 1: <font color=#0000ff>return</font> <font color=#0000ff>new</font> Square(xVal, yVal, dim);
      <font color=#0000ff>case</font> 2: <font color=#0000ff>return</font> <font color=#0000ff>new</font> Line(xVal, yVal, dim);
    }
  }
}

<font color=#0000ff>class</font> Circle <font color=#0000ff>extends</font> Shape {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> color = RED;
  <font color=#0000ff>public</font> Circle(<font color=#0000ff>int</font> xVal, <font color=#0000ff>int</font> yVal, <font color=#0000ff>int</font> dim) {
    <font color=#0000ff>super</font>(xVal, yVal, dim);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> setColor(<font color=#0000ff>int</font> newColor) { 
    color = newColor;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> getColor() { 
    <font color=#0000ff>return</font> color;
  }
}

<font color=#0000ff>class</font> Square <font color=#0000ff>extends</font> Shape {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> color;
  <font color=#0000ff>public</font> Square(<font color=#0000ff>int</font> xVal, <font color=#0000ff>int</font> yVal, <font color=#0000ff>int</font> dim) {
    <font color=#0000ff>super</font>(xVal, yVal, dim);
    color = RED;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> setColor(<font color=#0000ff>int</font> newColor) { 
    color = newColor;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> getColor() { 
    <font color=#0000ff>return</font> color;
  }
}

<font color=#0000ff>class</font> Line <font color=#0000ff>extends</font> Shape {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> color = RED;
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  serializeStaticState(ObjectOutputStream os)
      <font color=#0000ff>throws</font> IOException {
    os.writeInt(color);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  deserializeStaticState(ObjectInputStream os)
      <font color=#0000ff>throws</font> IOException {
    color = os.readInt();
  }
  <font color=#0000ff>public</font> Line(<font color=#0000ff>int</font> xVal, <font color=#0000ff>int</font> yVal, <font color=#0000ff>int</font> dim) {
    <font color=#0000ff>super</font>(xVal, yVal, dim);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> setColor(<font color=#0000ff>int</font> newColor) { 
    color = newColor;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> getColor() { 
    <font color=#0000ff>return</font> color;
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> CADState {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
  <font color=#0000ff>throws</font> Exception {
    ArrayList shapeTypes, shapes;
    <font color=#0000ff>if</font>(args.length == 0) {
      shapeTypes = <font color=#0000ff>new</font> ArrayList();
      shapes = <font color=#0000ff>new</font> ArrayList();
      <font color=#009900>// Добавляем ссылку в объект класса:</font>
      shapeTypes.add(Circle.<font color=#0000ff>class</font>);
      shapeTypes.add(Square.<font color=#0000ff>class</font>);
      shapeTypes.add(Line.<font color=#0000ff>class</font>);
      <font color=#009900>// Создаем какие-то образы:</font>
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
        shapes.add(Shape.randomFactory());
      <font color=#009900>// Устанавливаем все статические цвета в GREEN:</font>
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
        ((Shape)shapes.get(i))
          .setColor(Shape.GREEN);
      <font color=#009900>// Запись вектора состояния:</font>
      ObjectOutputStream out =
        <font color=#0000ff>new</font> ObjectOutputStream(
          <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"CADState.out"</font>));
      out.writeObject(shapeTypes);
      Line.serializeStaticState(out);
      out.writeObject(shapes);
    } <font color=#0000ff>else</font> { <font color=#009900>// Есть аргументы командной строки</font>
      ObjectInputStream in =
        <font color=#0000ff>new</font> ObjectInputStream(
          <font color=#0000ff>new</font> FileInputStream(args[0]));
      <font color=#009900>// Читаем в том же порядке, в котором была запись:</font>
      shapeTypes = (ArrayList)in.readObject();
      Line.deserializeStaticState(in);
      shapes = (ArrayList)in.readObject();
    }
    <font color=#009900>// Отображаем образы:</font>
    System.out.println(shapes);
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Класс <B>Shape</B> реализует интерфейс <b><a name="Index1439"></a>Serializable</b>, 
  так что все, что наследуется от <b>Shape</b>, автоматически реализует <b>Serializable</b>. 
  Каждый <b>Shape</b> содержит данные, а каждый наследуемый от <b>Shape</b> класс 
  содержит статическое поле, определяющее цвет всех этих <b>Shape</b>. (Помещение 
  статического поля в базовый класс приведет к тому, что будет существовать только 
  одно поле, так как статическое поле не дублируется для наследуемых классов.) 
  Методы базового класса могут быть перекрыты для установки цвета для различных 
  типов (статические методы не имеют динамических ограничений, так что это обычные 
  методы). Метод <b>randomFactory(&#160;)</b> создает различные объекты <b>Shape</b> 
  при каждом вызове, используя случайные значения для данных <b>Shape</b>.</FONT></P>
<P><FONT FACE="Georgia"><B>Circle</B> и <B>Square</B> являются прямым расширением 
  <b>Shape</b>; отличия только в том, что <b>Circle</b> инициализирует <b>color</b> 
  в точке определения, а <b>Square</b> инициализирует его в конструкторе. Дискуссию 
  относительно <b>Line</b> пока отложим.</FONT></P>
<P><FONT FACE="Georgia">В <B>main(&#160;)</B> используется один <b>ArrayList</b> 
  для хранения объектов <b>Class</b>, а другой для хранения образов. Если вы не 
  задействовали аргумент командной строки, создается <b>shapeTypes</b> <b>ArrayList</b>, 
  и добавляются объекты <b>Class</b>, а затем создается <b>ArrayList</b> <b>shapes</b>, 
  и в него добавляются объекты <b>Shape</b>. Далее, все значения <b>static</b> 
  <b>color</b> устанавливаются равными <b>GREEN</b>, и все сериализуется в файл 
  <b>CADState.out</b>.</FONT></P>
<P><FONT FACE="Georgia">Если вы укажите аргумент командной строки (предположительно 
  <B>CADState.out</B>), этот файл будет открыт и использован для восстановления 
  состояния программы. В обеих ситуациях распечатывается результирующий <B>ArrayList</B> 
  из <B>Shape</B>. Вот результат одного запуска:</FONT></P>
<DIV ALIGN="LEFT"></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>&gt;java CADState
[<font color=#0000ff>class</font> Circle color[3] xPos[-51] yPos[-99] dim[38]
, <font color=#0000ff>class</font> Square color[3] xPos[2] yPos[61] dim[-46]
, <font color=#0000ff>class</font> Line color[3] xPos[51] yPos[73] dim[64]
, <font color=#0000ff>class</font> Circle color[3] xPos[-70] yPos[1] dim[16]
, <font color=#0000ff>class</font> Square color[3] xPos[3] yPos[94] dim[-36]
, <font color=#0000ff>class</font> Line color[3] xPos[-84] yPos[-21] dim[-35]
, <font color=#0000ff>class</font> Circle color[3] xPos[-75] yPos[-43] dim[22]
, <font color=#0000ff>class</font> Square color[3] xPos[81] yPos[30] dim[-45]
, <font color=#0000ff>class</font> Line color[3] xPos[-29] yPos[92] dim[17]
, <font color=#0000ff>class</font> Circle color[3] xPos[17] yPos[90] dim[-76]
]

&gt;java CADState CADState.out
[<font color=#0000ff>class</font> Circle color[1] xPos[-51] yPos[-99] dim[38]
, <font color=#0000ff>class</font> Square color[0] xPos[2] yPos[61] dim[-46]
, <font color=#0000ff>class</font> Line color[3] xPos[51] yPos[73] dim[64]
, <font color=#0000ff>class</font> Circle color[1] xPos[-70] yPos[1] dim[16]
, <font color=#0000ff>class</font> Square color[0] xPos[3] yPos[94] dim[-36]
, <font color=#0000ff>class</font> Line color[3] xPos[-84] yPos[-21] dim[-35]
, <font color=#0000ff>class</font> Circle color[1] xPos[-75] yPos[-43] dim[22]
, <font color=#0000ff>class</font> Square color[0] xPos[81] yPos[30] dim[-45]
, <font color=#0000ff>class</font> Line color[3] xPos[-29] yPos[92] dim[17]
, <font color=#0000ff>class</font> Circle color[1] xPos[17] yPos[90] dim[-76]
]</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Вы можете видеть, что значения <b>xPos</b>, <b>yPos</b> 
  и <b>dim</b> были успешно сохранены и восстановлены, но при восстановлении статической 
  информации произошли какие-то ошибки. Везде на входе имели &#8220;3&#8221;, 
  но на выходе этого не получили. <b>Circle</b> имеет значение 1 (<b>RED</b>, 
  как это определено), а <b>Square</b> имеет значение 0 (Помните, что он инициализировался 
  в конструкторе). Это похоже на то, что <b>static</b> не сериализовался совсем! 
  Это верно, несмотря на то, что класс <b>Class</b> реализует интерфейс <b>Serializable</b>, 
  он не делает того, что вы от него ожидаете. Так что если вы хотите сериализовать 
  <b>statics</b>, вы должны сделать это сами.</FONT></P>
<P><FONT FACE="Georgia">Это то, для чего нужны статические методы <b>serializeStaticState(&#160;) 
  </b>и <b>deserializeStaticState(&#160;)</b> в <b>Line</b>. Вы можете видеть, 
  что они явно вызываются как часть процесса сохранения и восстановления. (Обратите 
  внимание, что порядок записи в файл сериализации и чтения из него должен сохранятся). 
  Таким образом, чтобы <b>CADState.java</b> работал корректно, вы должны</FONT><FONT FACE="Georgia">:</FONT></P>
<DIV ALIGN="LEFT"></DIV>
<OL>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Добавить <B>serializeStaticState(&#160;)</B> 
    и <B>deserializeStaticState(&#160;)</B> к образам.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Удалить <B>ArrayList</B> 
    <B>shapeTypes</B> и весь код, относящийся к нему.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Добавить вызов новых статических 
    методов сериализации и десериализации образов.</FONT>
</OL>
<P><FONT FACE="Georgia">Другую проблему вы можете получить, думая о безопасности, 
  так как сериализация сохраняет данные с модификатором </FONT> <FONT FACE="Georgia"><B>private</B>. 
  Если вы имеете проблемы безопасности, эти поля должны помечаться, как <B>transient</B>. 
  Затем вы должны разработать безопасный способ для хранения такой информации, 
  чтобы когда вы делали восстановление, вы могли установить эти <b>private</b> 
  переменные.</FONT><A NAME="_Toc481064766"></A></P>
<A NAME="Heading395"></A><FONT FACE = "Verdana"> 
<H2 ALIGN="LEFT"> Токенизация(Tokenizing) ввода<A NAME="Index1440"></A><A NAME="Index1441"></A></H2>
</FONT> 
<P><FONT FACE="Georgia"> <I>Tokenizing </I> - это процесс разбивания последовательности 
  символов на последовательность значащих элементов (&#8220;tokens&#8221;), которые 
  являются кусочками текста, разделенных чем-либо по вашему выбору. Например, 
  ваши значащие элементы могут быть словами, разделенными пробелом и пунктуацией. 
  Есть два класса, обеспечиваемых стандартной библиотекой Java, которые могут 
  использоваться для токенизации: <B>StreamTokenizer</B> и <B>StringTokenizer</B>.</FONT><A NAME="_Toc375545398"></A><A NAME="_Toc481064767"></A></P>
<A NAME="Heading396"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> StreamTokenizer<A NAME="Index1442"></A><A NAME="Index1443"></A></H3>
</FONT>
<P><FONT FACE="Georgia">Хотя <B>StreamTokenizer</B> не наследуется от <B>InputStream</B> 
  или <B>OutputStream</B>, он работает только с объектами <B>InputStream</B>, 
  так что он по праву принадлежит библиотеке ввода/вывода.</FONT></P>
<P><FONT FACE="Georgia">Рассмотрим программу, подсчитывающую встречающихся слов 
  в текстовом файле:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c11:WordCount.java</font>
<font color=#009900>// Подсчет слов в файле, выводит</font>
<font color=#009900>// результат в отсортированном порядке.</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> Counter {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> i = 1;
  <font color=#0000ff>int</font> read() { <font color=#0000ff>return</font> i; }
  <font color=#0000ff>void</font> increment() { i++; }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> WordCount {
  <font color=#0000ff>private</font> FileReader file;
  <font color=#0000ff>private</font> StreamTokenizer st;
  <font color=#009900>// TreeMap хранит ключи в отсортированном порядке:</font>
  <font color=#0000ff>private</font> TreeMap counts = <font color=#0000ff>new</font> TreeMap();
  WordCount(String filename)
    <font color=#0000ff>throws</font> FileNotFoundException {
    <font color=#0000ff>try</font> {
      file = <font color=#0000ff>new</font> FileReader(filename);
      st = <font color=#0000ff>new</font> StreamTokenizer(
        <font color=#0000ff>new</font> BufferedReader(file));
      st.ordinaryChar('.');
      st.ordinaryChar('-');
    } <font color=#0000ff>catch</font>(FileNotFoundException e) {
      System.err.println(
        <font color=#004488>"Could not open "</font> + filename);
      <font color=#0000ff>throw</font> e;
    }
  }
  <font color=#0000ff>void</font> cleanup() {
    <font color=#0000ff>try</font> {
      file.close();
    } <font color=#0000ff>catch</font>(IOException e) {
      System.err.println(
        <font color=#004488>"file.close() unsuccessful"</font>);
    }
  }
  <font color=#0000ff>void</font> countWords() {
    <font color=#0000ff>try</font> {
      <font color=#0000ff>while</font>(st.nextToken() !=
        StreamTokenizer.TT_EOF) {
        String s;
        <font color=#0000ff>switch</font>(st.ttype) {
          <font color=#0000ff>case</font> StreamTokenizer.TT_EOL:
            s = <font color=#0000ff>new</font> String(<font color=#004488>"EOL"</font>);
            <font color=#0000ff>break</font>;
          <font color=#0000ff>case</font> StreamTokenizer.TT_NUMBER:
            s = Double.toString(st.nval);
            <font color=#0000ff>break</font>;
          <font color=#0000ff>case</font> StreamTokenizer.TT_WORD:
            s = st.sval; <font color=#009900>// Уже String</font>
            <font color=#0000ff>break</font>;
          <font color=#0000ff>default</font>: <font color=#009900>// единственный символ в ttype</font>
            s = String.valueOf((<font color=#0000ff>char</font>)st.ttype);
        }
        <font color=#0000ff>if</font>(counts.containsKey(s))
          ((Counter)counts.get(s)).increment();
        <font color=#0000ff>else</font>
          counts.put(s, <font color=#0000ff>new</font> Counter());
      }
    } <font color=#0000ff>catch</font>(IOException e) {
      System.err.println(
        <font color=#004488>"st.nextToken() unsuccessful"</font>);
    }
  }
  Collection values() {
    <font color=#0000ff>return</font> counts.values();
  }
  Set keySet() { <font color=#0000ff>return</font> counts.keySet(); }
  Counter getCounter(String s) {
    <font color=#0000ff>return</font> (Counter)counts.get(s);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
  <font color=#0000ff>throws</font> FileNotFoundException {
    WordCount wc =
      <font color=#0000ff>new</font> WordCount(args[0]);
    wc.countWords();
    Iterator keys = wc.keySet().iterator();
    <font color=#0000ff>while</font>(keys.hasNext()) {
      String key = (String)keys.next();
      System.out.println(key + <font color=#004488>": "</font>
               + wc.getCounter(key).read());
    }
    wc.cleanup();
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Представление слов в сортированном виде проще выполнить 
  при хранении данных в <b>TreeMap</b>, который автоматически организует ключи 
  в сортированном порядке (смотрите <a href="Chapter09.html">Главу 9</a>). Когда 
  вы получите набор ключей, используя <b>keySet(&#160;)</b>, они также будут отсортированы.</FONT></P>
<P><FONT FACE="Georgia">Для открытия файла используется <b>FileReader</b>, а для 
  деления файла на слова, создается <b>StreamTokenizer</b> из <b>FileReader</b>, 
  помещенного в <b>BufferedReader</b>. Для <b>StreamTokenizer</b>, существует 
  стандартный список разделителей, и вы можете добавить еще с помощью нескольких 
  методов. Здесь используется <b>ordinaryChar(&#160;)</b> для того, чтобы сказать: 
  &#8220;Этот символ не является тем, чем я интересуюсь&#8221;, так что синтаксический 
  анализатор не будет включать его, как часть любого слова, которые он создает. 
  Например, фраза <b>st.ordinaryChar('.')</b> означает, что точка не будет включаться, 
  как часть анализируемого слова. Вы можете найти более подробную информацию в 
  HTML документации по JDK на <i>java.sun.com</i>.</FONT></P>
<P><FONT FACE="Georgia">В <B>countWords(&#160;)</B> значащие элементы извлекаются 
  по одному, далее используется информация <b>ttype</b> для определения, что нужно 
  делать с каждым значащим элементом, так как он может быть переводом строки, 
  числом, строкой или единичным символом.</FONT></P>
<P><FONT FACE="Georgia">Как только значащий элемент будет найден, опрашивается 
  <a name="Index1444"></a><b>TreeMap counts</b> на предмет проверки, содержится 
  ли этот элемент как ключевое значение. Если это так, инкрементируется соответствующий 
  объект <b>Counter</b>, указывающий что был найден еще один экземпляр найденного 
  слова. Если нет, создается новый <b>Counter</b> &#8212; так как конструктор 
  <b>Counter</b> инициализирует свое значение единицей, то при этом также происходит 
  подсчет слов.</FONT></P>
<P><FONT FACE="Georgia"><B>WordCount</B> не является типом <b>TreeMap</b>, так 
  как она не была унаследована. Она выполняет определенный тип функциональности, 
  так что даже хотя методы <b>keys(&#160;)</b> и <b>values(&#160;)</b> должны 
  быть открытыми, это все еще не означает, что должно использоваться <a name="Index1445"></a><a name="Index1446"></a>наследование, 
  так как некоторые методы <b>TreeMap</b> здесь не подходят. Кроме того, другие 
  методы, такие как <b>getCounter(&#160;)</b>, возвращающие <b>Counter</b> для 
  определенной <b>String</b>, и <b>sortedKeys(&#160;)</b>, производящие <b>Iterator</b>, 
  завершают изменения в интерфейсе <b>WordCount</b>.</FONT></P>
<P><FONT FACE="Georgia">В <B>main(&#160;)</B> вы можете видеть использование <b>WordCount</b> 
  для открытия и подсчета слов в файле &#8212; это занимает всего две строчки 
  кода. Затем извлекается итератор сортированного списка ключей (слов), который 
  используется для получения каждого ключа и ассоциированного <b>Count</b>. Вызов 
  <b>cleanup(&#160;)</b> необходим, чтобы быть уверенным в закрытии файла</FONT><FONT FACE="Georgia">.</FONT><A NAME="_Toc375545399"></A><A NAME="_Toc481064768"></A></P>
<DIV ALIGN="LEFT"></DIV>
<A NAME="Heading397"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
StringTokenizer</H3>
</FONT> 
<P><FONT FACE="Georgia">Хотя он не является частью библиотеки ввода/вывода, <b>StringTokenizer</b> 
  имеет во многом сходную функциональность, что и описанный здесь <b>StreamTokenizer</b>.</FONT></P>
<P><FONT FACE="Georgia"> <A NAME="Index1447"></A><B>StringTokenizer</B> возвращает 
  значащие элементы из строки по одной. Эти значащие элементы являются последовательностью 
  символов, разделенных символами табуляции, пробелами и символами перевода строки. 
  Таким образом, значащими элементами строки &#8220;Куда делась моя кошка?&#8221; 
  являются &#8220;Куда&#8221;, &#8220;делась&#8221;, &#8220;моя&#8221; и &#8220;кошка?&#8221;. 
  Как и в случае <b>StreamTokenizer</b>, вы можете настроить <b>StringTokenizer</b>, 
  чтобы он разбивал ввод любым способом, который вам нужен, но с помощью <b>StringTokenizer</b> 
  вы можете сделать это, передав второй аргумент в конструктор, который имеет 
  тип <b>String </b>и является разделителем, который вы хотите использовать. В 
  общем, если вам нужна большая изощренность, используйте <b>StreamTokenizer</b>.</FONT></P>
<P><FONT FACE="Georgia">Вы запрашиваете у объекта <b>StringTokenizer</b> следующий 
  значащий элемент строки, используя метод <b>nextToken(&#160;)</b>, который возвращает 
  либо следующий значащий элемент, либо пустую строку, которая указывает, что 
  более элементов не осталось.</FONT></P>
<P><FONT FACE="Georgia">В качестве примера рассмотрим программу, которая выполняет 
  ограниченный анализ предложения, ища ключевые фразы, указывающие на выражения 
  счастья или огорчения.</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c11:AnalyzeSentence.java</font>
<font color=#009900>// Поиск определенных последовательностей в предложении.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> AnalyzeSentence {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    analyze(<font color=#004488>"I am happy about this"</font>);
    analyze(<font color=#004488>"I am not happy about this"</font>);
    analyze(<font color=#004488>"I am not! I am happy"</font>);
    analyze(<font color=#004488>"I am sad about this"</font>);
    analyze(<font color=#004488>"I am not sad about this"</font>);
    analyze(<font color=#004488>"I am not! I am sad"</font>);
    analyze(<font color=#004488>"Are you happy about this?"</font>);
    analyze(<font color=#004488>"Are you sad about this?"</font>);
    analyze(<font color=#004488>"It's you! I am happy"</font>);
    analyze(<font color=#004488>"It's you! I am sad"</font>);
  }
  <font color=#0000ff>static</font> StringTokenizer st;
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> analyze(String s) {
    prt(<font color=#004488>"\nnew sentence &gt;&gt; "</font> + s);
    <font color=#0000ff>boolean</font> sad = <font color=#0000ff>false</font>;
    st = <font color=#0000ff>new</font> StringTokenizer(s);
    <font color=#0000ff>while</font> (st.hasMoreTokens()) {
      String token = next();
      <font color=#009900>// Поиск идет до тех пор, пока вы</font>
      <font color=#009900>// не найдете одну из двух начальных элементов:</font>
      <font color=#0000ff>if</font>(!token.equals(<font color=#004488>"I"</font>) &amp;&amp;
         !token.equals(<font color=#004488>"Are"</font>))
        <font color=#0000ff>continue</font>; <font color=#009900>// В начала цикла while</font>
      <font color=#0000ff>if</font>(token.equals(<font color=#004488>"I"</font>)) {
        String tk2 = next();
        <font color=#0000ff>if</font>(!tk2.equals(<font color=#004488>"am"</font>)) <font color=#009900>// Должно быть после Я</font>
          <font color=#0000ff>break</font>; <font color=#009900>// Выход из цикла while</font>
        <font color=#0000ff>else</font> {
          String tk3 = next();
          <font color=#0000ff>if</font>(tk3.equals(<font color=#004488>"sad"</font>)) {
            sad = <font color=#0000ff>true</font>;
            <font color=#0000ff>break</font>; <font color=#009900>// Выход из цикла while</font>
          }
          <font color=#0000ff>if</font> (tk3.equals(<font color=#004488>"not"</font>)) {
            String tk4 = next();
            <font color=#0000ff>if</font>(tk4.equals(<font color=#004488>"sad"</font>))
              <font color=#0000ff>break</font>; <font color=#009900>// Leave sad false</font>
            <font color=#0000ff>if</font>(tk4.equals(<font color=#004488>"happy"</font>)) {
              sad = <font color=#0000ff>true</font>;
              <font color=#0000ff>break</font>;
            }
          }
        }
      }
      <font color=#0000ff>if</font>(token.equals(<font color=#004488>"Are"</font>)) {
        String tk2 = next();
        <font color=#0000ff>if</font>(!tk2.equals(<font color=#004488>"you"</font>))
          <font color=#0000ff>break</font>; <font color=#009900>// Должно быть после Are</font>
        String tk3 = next();
        <font color=#0000ff>if</font>(tk3.equals(<font color=#004488>"sad"</font>))
          sad = <font color=#0000ff>true</font>;
        <font color=#0000ff>break</font>; <font color=#009900>// Выход из цикла while</font>
      }
    }
    <font color=#0000ff>if</font>(sad) prt(<font color=#004488>"Sad detected"</font>);
  }
  <font color=#0000ff>static</font> String next() {
    <font color=#0000ff>if</font>(st.hasMoreTokens()) {
      String s = st.nextToken();
      prt(s);
      <font color=#0000ff>return</font> s;
    } 
    <font color=#0000ff>else</font>
      <font color=#0000ff>return</font> <font color=#004488>""</font>;
  }
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> prt(String s) {
    System.out.println(s);
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Анализ происходит для каждой строки, происходит вход в 
  цикл <b>while</b> и из строки извлекается значащий элемент. Обратите внимание, 
  что первая инструкция <b>if</b>, которая командует <b>continue</b> (вернуться 
  назад к началу цикла и начать его заново), если значащий элемент не является 
  ни словом &quot;I&quot;, ни &#8220;Are&#8221;. Это означает, что будут извлекаться 
  значащие элементы до тех пор, пока не будет найдено </FONT><font face="Georgia">&#8220;I&#8221; 
  или &#8220;Are&#8221;. Вы можете решить, что нужно использовать == вместо метода 
  <a name="Index1448"></a><a name="Index1449"></a><b>equals(&#160;)</b>, но этот 
  оператор не будет работать корректно, так как == сравнивает значения ссылок, 
  а метод <b>equals(&#160;)</b> сравнивает содержимое.</font></P>
<P><FONT FACE="Georgia">Логика оставшейся части метода <b>analyze(&#160;)</b> 
  заключается в поиске шаблона, с которого начинается фраза &#8220;I am sad&#8221;, 
  &#8220;I am not happy&#8221; или &#8220;Are you sad?&#8221;. Без использования 
  инструкции <b>break</b> этот код был бы еще грязнее, чем он есть. Вы должны 
  знать, что типичный синтаксический анализатор (это примитивный пример одного 
  из них) обычно имеет таблицу таких значащих элементов и часть кода, проходящую 
  по всем состояниям таблицы, после чтения каждого элемента.</FONT></P>
<P><FONT FACE="Georgia">Вы должны думать, что <B>StringTokenizer</B> является 
  стенографическим упрощением для определенного вида <B>StreamTokenizer</B>. Однако 
  если вы имеете <B>String</B>, которую вы хотите разбить на элементы, <B>StringTokenizer</B> 
  является слишком ограниченным, все, что вам нужно сделать - это перевести строку 
  в <B>StringBufferInputStream</B>, а затем использовать его для создания более 
  мощного <B>StreamTokenizer</B>.</FONT><A NAME="_Toc375545504"></A><A NAME="_Toc481064769"></A></P>
<A NAME="Heading398"></A><FONT FACE = "Verdana"> 
<H3 ALIGN="LEFT"> Проверка стиля капитализации</H3>
</FONT> 
<P><FONT FACE="Georgia">В этом разделе мы взглянем на более сложный пример использования 
  ввода/вывода в Java, который также использует токенизацию. <a name="Index1450"></a><a name="Index1451"></a>Этот 
  проект весьма полезен, потому что он выполняет проверку стиля, чтобы убедится, 
  что ваша капитализация соответствует стилю Java, который можно найти на <i>java.sun.com/docs/codeconv/index.html</i>. 
  Он открывает <b>.java</b> файл в текущем директории и извлекает все имена классов 
  и идентификаторов, затем показывает, если какой-то из них не соответствует стилю 
  Java.</FONT></P>
<P><FONT FACE="Georgia">Для тех программ, которые откроются корректно, вы сначала 
  должны построить хранилище имен классов для хранения всех имен классов из стандартной 
  библиотеки Java. Вы делаете это путем прохождения по всем поддиректориям с исходным 
  кодом стандартной библиотеки Java и запуском <b>ClassScanner</b> в каждой поддиректории. 
  В качестве аргумента получается файл хранилища (каждый раз используется один 
  и тот же путь и одно и тоже имя), к опция командной строки <b>-a</b> указывает, 
  что имена классов должны добавляться в хранилище.</FONT></P>
<P><FONT FACE="Georgia">Используя программу для проверки вашего кода, передайте 
  ей имя хранилища для использования. Она проверит все классы и идентификаторы 
  в текущем директории, и скажет вам, какие из них не следуют типичному стилю 
  капитализации Java.</FONT></P>
<P><FONT FACE="Georgia">Вы должны знать, что программа не является точной; есть 
  несколько моментов, когда она будет указывать на то, что она считает проблемой, 
  но, взглянув на код, вы увидите, что ничего не нужно менять. Это немного раздражает, 
  но это гораздо легче, чем пытаться найти все эти случаи, пристально вглядываясь 
  в код.</FONT></P>
<DIV ALIGN="LEFT"></DIV>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: c11:ClassScanner.java</font>
<font color=#009900>// Сканирует все файлы в директории в поисках</font>
<font color=#009900>// классов и идентификаторов для проверки капитализации.</font>
<font color=#009900>// Принимает правильно составленные списки кода.</font>
<font color=#009900>// Не все делает правильно, но достаточно хороший помощник.</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> MultiStringMap <font color=#0000ff>extends</font> HashMap {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> add(String key, String value) {
    <font color=#0000ff>if</font>(!containsKey(key))
      put(key, <font color=#0000ff>new</font> ArrayList());
    ((ArrayList)get(key)).add(value);
  }
  <font color=#0000ff>public</font> ArrayList getArrayList(String key) {
    <font color=#0000ff>if</font>(!containsKey(key)) {
      System.err.println(
        <font color=#004488>"ERROR: can't find key: "</font> + key);
      System.exit(1);
    }
    <font color=#0000ff>return</font> (ArrayList)get(key);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> printValues(PrintStream p) {
    Iterator k = keySet().iterator();
    <font color=#0000ff>while</font>(k.hasNext()) {
      String oneKey = (String)k.next();
      ArrayList val = getArrayList(oneKey);
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; val.size(); i++)
        p.println((String)val.get(i));
    }
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ClassScanner {
  <font color=#0000ff>private</font> File path;
  <font color=#0000ff>private</font> String[] fileList;
  <font color=#0000ff>private</font> Properties classes = <font color=#0000ff>new</font> Properties();
  <font color=#0000ff>private</font> MultiStringMap 
    classMap = <font color=#0000ff>new</font> MultiStringMap(),
    identMap = <font color=#0000ff>new</font> MultiStringMap();
  <font color=#0000ff>private</font> StreamTokenizer in;
  <font color=#0000ff>public</font> ClassScanner() <font color=#0000ff>throws</font> IOException {
    path = <font color=#0000ff>new</font> File(<font color=#004488>"."</font>);
    fileList = path.list(<font color=#0000ff>new</font> JavaFilter());
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; fileList.length; i++) {
      System.out.println(fileList[i]);
      <font color=#0000ff>try</font> {
        scanListing(fileList[i]);
      } <font color=#0000ff>catch</font>(FileNotFoundException e) {
        System.err.println(<font color=#004488>"Could not open "</font> +
          fileList[i]);
      }
    }
  }
  <font color=#0000ff>void</font> scanListing(String fname) 
  <font color=#0000ff>throws</font> IOException {
    in = <font color=#0000ff>new</font> StreamTokenizer(
        <font color=#0000ff>new</font> BufferedReader(
          <font color=#0000ff>new</font> FileReader(fname)));
    <font color=#009900>// Кажется, не работает:</font>
    <font color=#009900>// in.slashStarComments(true);</font>
    <font color=#009900>// in.slashSlashComments(true);</font>
    in.ordinaryChar('/');
    in.ordinaryChar('.');
    in.wordChars('_', '_');
    in.eolIsSignificant(<font color=#0000ff>true</font>);
    <font color=#0000ff>while</font>(in.nextToken() != 
          StreamTokenizer.TT_EOF) {
      <font color=#0000ff>if</font>(in.ttype == '/')
        eatComments();
      <font color=#0000ff>else</font> <font color=#0000ff>if</font>(in.ttype == 
              StreamTokenizer.TT_WORD) {
        <font color=#0000ff>if</font>(in.sval.equals(<font color=#004488>"class"</font>) || 
           in.sval.equals(<font color=#004488>"interface"</font>)) {
          <font color=#009900>// Получаем имя класса:</font>
             <font color=#0000ff>while</font>(in.nextToken() != 
                   StreamTokenizer.TT_EOF
                   &amp;&amp; in.ttype != 
                   StreamTokenizer.TT_WORD)
               ;
             classes.put(in.sval, in.sval);
             classMap.add(fname, in.sval);
        }
        <font color=#0000ff>if</font>(in.sval.equals(<font color=#004488>"import"</font>) ||
           in.sval.equals(<font color=#004488>"package"</font>))
          discardLine();
        <font color=#0000ff>else</font> <font color=#009900>// Это идентификатор или ключевое слово</font>
          identMap.add(fname, in.sval);
      }
    }
  }
  <font color=#0000ff>void</font> discardLine() <font color=#0000ff>throws</font> IOException {
    <font color=#0000ff>while</font>(in.nextToken() != 
          StreamTokenizer.TT_EOF
          &amp;&amp; in.ttype != 
          StreamTokenizer.TT_EOL)
      ; <font color=#009900>// Выбрасываем элемент в конец строки</font>
  }
  <font color=#009900>// Кажется, что метод удаления комментариев StreamTokenizer</font>
  <font color=#009900>// сломан. Это извлекает комментарии:</font>
  <font color=#0000ff>void</font> eatComments() <font color=#0000ff>throws</font> IOException {
    <font color=#0000ff>if</font>(in.nextToken() != 
       StreamTokenizer.TT_EOF) {
      <font color=#0000ff>if</font>(in.ttype == '/')
        discardLine();
      <font color=#0000ff>else</font> <font color=#0000ff>if</font>(in.ttype != '*')
        in.pushBack();
      <font color=#0000ff>else</font> 
        <font color=#0000ff>while</font>(<font color=#0000ff>true</font>) {
          <font color=#0000ff>if</font>(in.nextToken() == 
            StreamTokenizer.TT_EOF)
            <font color=#0000ff>break</font>;
          <font color=#0000ff>if</font>(in.ttype == '*')
            <font color=#0000ff>if</font>(in.nextToken() != 
              StreamTokenizer.TT_EOF
              &amp;&amp; in.ttype == '/')
              <font color=#0000ff>break</font>;
        }
    }
  }
  <font color=#0000ff>public</font> String[] classNames() {
    String[] result = <font color=#0000ff>new</font> String[classes.size()];
    Iterator e = classes.keySet().iterator();
    <font color=#0000ff>int</font> i = 0;
    <font color=#0000ff>while</font>(e.hasNext())
      result[i++] = (String)e.next();
    <font color=#0000ff>return</font> result;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> checkClassNames() {
    Iterator files = classMap.keySet().iterator();
    <font color=#0000ff>while</font>(files.hasNext()) {
      String file = (String)files.next();
      ArrayList cls = classMap.getArrayList(file);
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; cls.size(); i++) {
        String className = (String)cls.get(i);
        <font color=#0000ff>if</font>(Character.isLowerCase(
             className.charAt(0)))
          System.out.println(
            <font color=#004488>"class capitalization error, file: "</font>
            + file + <font color=#004488>", class: "</font> 
            + className);
      }
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> checkIdentNames() {
    Iterator files = identMap.keySet().iterator();
    ArrayList reportSet = <font color=#0000ff>new</font> ArrayList();
    <font color=#0000ff>while</font>(files.hasNext()) {
      String file = (String)files.next();
      ArrayList ids = identMap.getArrayList(file);
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; ids.size(); i++) {
        String id = (String)ids.get(i);
        <font color=#0000ff>if</font>(!classes.contains(id)) {
          <font color=#009900>// Игнорирует идентификаторы длиной 3 или</font>
          <font color=#009900>// более символов, если они все в верхнем регистре</font>
          <font color=#009900>// (эероятно это значения static final):</font>
          <font color=#0000ff>if</font>(id.length() &gt;= 3 &amp;&amp;
             id.equals(
               id.toUpperCase()))
            <font color=#0000ff>continue</font>;
          <font color=#009900>// Проверяется, записан ли первый символ в верхнем регистре:</font>
          <font color=#0000ff>if</font>(Character.isUpperCase(id.charAt(0))){
            <font color=#0000ff>if</font>(reportSet.indexOf(file + id)
                == -1){ <font color=#009900>// Еще не включено в отчет</font>
              reportSet.add(file + id);
              System.out.println(
                <font color=#004488>"Ident capitalization error in:"</font>
                + file + <font color=#004488>", ident: "</font> + id);
            }
          }
        }
      }
    }
  }
  <font color=#0000ff>static</font> <font color=#0000ff>final</font> String usage =
    <font color=#004488>"Usage: \n"</font> + 
    <font color=#004488>"ClassScanner classnames -a\n"</font> +
    <font color=#004488>"\tAdds all the class names in this \n"</font> +
    <font color=#004488>"\tdirectory to the repository file \n"</font> +
    <font color=#004488>"\tcalled 'classnames'\n"</font> +
    <font color=#004488>"ClassScanner classnames\n"</font> +
    <font color=#004488>"\tChecks all the java files in this \n"</font> +
    <font color=#004488>"\tdirectory for capitalization errors, \n"</font> +
    <font color=#004488>"\tusing the repository file 'classnames'"</font>;
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> usage() {
    System.err.println(usage);
    System.exit(1);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
  <font color=#0000ff>throws</font> IOException {
    <font color=#0000ff>if</font>(args.length &lt; 1 || args.length &gt; 2)
      usage();
    ClassScanner c = <font color=#0000ff>new</font> ClassScanner();
    File old = <font color=#0000ff>new</font> File(args[0]);
    <font color=#0000ff>if</font>(old.exists()) {
      <font color=#0000ff>try</font> {
        <font color=#009900>// Пробуем открыть существующий</font>
        <font color=#009900>// файл свойств:</font>
        InputStream oldlist =
          <font color=#0000ff>new</font> BufferedInputStream(
            <font color=#0000ff>new</font> FileInputStream(old));
        c.classes.load(oldlist);
        oldlist.close();
      } <font color=#0000ff>catch</font>(IOException e) {
        System.err.println(<font color=#004488>"Could not open "</font>
          + old + <font color=#004488>" for reading"</font>);
        System.exit(1);
      }
    }
    <font color=#0000ff>if</font>(args.length == 1) {
      c.checkClassNames();
      c.checkIdentNames();
    }
    <font color=#009900>// Записываем имя класса в хранилище:</font>
    <font color=#0000ff>if</font>(args.length == 2) {
      <font color=#0000ff>if</font>(!args[1].equals(<font color=#004488>"-a"</font>))
        usage();
      <font color=#0000ff>try</font> {
        BufferedOutputStream out =
          <font color=#0000ff>new</font> BufferedOutputStream(
            <font color=#0000ff>new</font> FileOutputStream(args[0]));
        c.classes.store(out,
          <font color=#004488>"Classes found by ClassScanner.java"</font>);
        out.close();
      } <font color=#0000ff>catch</font>(IOException e) {
        System.err.println(
          <font color=#004488>"Could not write "</font> + args[0]);
        System.exit(1);
      }
    }
  }
}

<font color=#0000ff>class</font> JavaFilter <font color=#0000ff>implements</font> FilenameFilter {
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> accept(File dir, String name) {
    <font color=#009900>// Strip path information:</font>
    String f = <font color=#0000ff>new</font> File(name).getName();
    <font color=#0000ff>return</font> f.trim().endsWith(<font color=#004488>".java"</font>);
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<P><A NAME="Index1452"></A><A NAME="Index1453"></A><A NAME="Index1454"></A><FONT FACE="Georgia">Класс 
  <B>MultiStringMap</B> является инструментом, позволяющим вам ставить в соответствие 
  группу строк и каждое ключевое включение. Он использует <b>HashMap</b> (в этот 
  раз через наследование). В качестве ключевых значений используются единичные 
  строки, которые ставятся в соответствие значению <b>ArrayList</b>. Метод <b>add(&#160;)</b> 
  просто проверяет, есть ли уже такое ключевое значение в <b>HashMap</b>, а если 
  его нет, помещает его туда. Метод <b>getArrayList(&#160;)</b> производит <b>ArrayList</b> 
  определенных ключей, а <b>printValues(&#160;)</b>, который особенно полезен 
  для отладки, печатает все значения <b>ArrayList</b>, получая <b>ArrayList</b>.</FONT></P>
<P><FONT FACE="Georgia">Для облегчения жизни все имена классов стандартной библиотеки 
  Java помещаются в объект <a name="Index1455"></a><b>Properties</b> (из стандартной 
  библиотеки Java). Помните, что объект <b>Properties</b> является типом <b>HashMap</b>, 
  который хранит только объекты <b>String</b> и для ключевого значения, и для 
  хранимого элемента. Однако он может быть сохранен на диске и восстановлен с 
  диска в одном вызове метода, так что он идеален в качестве хранилища имен. На 
  самом деле нам нужен только список имен, но <b>HashMap</b> не может принимать 
  <b>null</b> ни для ключевых значений, ни для хранящихся значений. Так что один 
  и тот же объект будет использоваться и для ключа, и для значения.</FONT></P>
<P><FONT FACE="Georgia">Для классов и идентификаторов, которые будут обнаружены 
  в определенном директории, используются две <b>MultiStringMap</b>: <b>classMap 
  </b>и <b>identMap</b>. Также, когда запускается программа, она загружает хранилище 
  стандартных имен классов в объект <b>Properties</b>, называемый <b>classes</b>, 
  а когда обнаруживается новое имя класса в локальном директории, то оно добавляется 
  и в <b>classes</b>, и в <b>classMap</b>. Таким образом, <b>classMap</b> может 
  использоваться для обхода всех классов в локальном директории, а <b>classes</b> 
  может использоваться для проверки, является ли текущий значащий элемент именем 
  класса (что указывается определением объекта или началом метода, так как захватывается 
  следующий значащий элемент &#8212; до точки с запятой &#8212; и помещается в 
  <b>identMap</b>).</FONT></P>
<P><FONT FACE="Georgia">Конструктор по умолчанию для <b>ClassScanner</b> создает 
  список имен, используя <b>JavaFilter</b>, показанный в конце файла, который 
  реализует интерфейс <a name="Index1456"></a><a name="Index1457"></a><b>FilenameFilter</b>. 
  Затем вызывается <b>scanListing(&#160;)</b> для каждого имени файла.</FONT></P>
<P><FONT FACE="Georgia">Внутри <B>scanListing(&#160;)</B> открывается файл исходного 
  кода и передается в <a name="Index1458"></a><a name="Index1459"></a><b>StreamTokenizer</b>. 
  В документации есть функции <b>slashStarComments(&#160;)</b> и <b>slashSlashComments(&#160;)</b>, 
  предназначенные для отсеивания коментариев, которым передается <b>true</b>, 
  но это выглядит некорректно, так как это плохо работает. Поэтому эти строки 
  закомментированы, а комментарии извлекаются другим методом. Чтобы извлечь комментарий, 
  &#8220;<b>/</b>&#8221; должен трактоваться как обычный символ, и нужно не позволять 
  <b>StreamTokenizer</b> собирать его как часть комментария, поэтому метод <b>ordinaryChar(&#160;)</b> 
  говорит <b>StreamTokenizer</b>, чтобы он не делал это. Это также верно в отношении 
  точки (&#8220;<b>.</b>&#8221;), так как мы хотим иметь метод, который бы извлекал 
  индивидуальные идентификаторы. Однако символ подчеркивания, который трактуется 
  <b>StreamTokenizer</b> как индивидуальный символ, должен оставляться как часть 
  идентификатора, так как он появляется в таких значениях типа <b>static</b> <b>final</b>, 
  как <b>TT_EOF</b>, и т. д., очень популярных в этой программе. Метод <b>wordChars(&#160;) 
  </b> принимает диапазон символов, которые вы хотите добавить к остающимся внутри 
  значащего элемента, анализирующегося одним словом. Наконец, когда анализируете 
  однострочный комментарий или обнаруживаете строку, для которой необходимо определить 
  конец строки, то при вызове <b>eolIsSignificant(true)</b> конец строки будет 
  обнаружен раньше, чем он будет получен <b>StreamTokenizer</b>.</FONT></P>
<P><FONT FACE="Georgia">Оставшаяся часть <b>scanListing(&#160;)</b> читает и реагирует 
  на значащие элементы, пока не встретится конец файла, которых будет обнаружен, 
  когда <b>nextToken(&#160;)</b> вернет значение <b>final static StreamTokenizer.TT_EOF</b>.</FONT></P>
<P><FONT FACE="Georgia">Если значащим элементом является &#8220;/&#8221;, он потенциально 
  может быть комментарием, так что вызывается <b>eatComments(&#160;)</b>, чтобы 
  разобраться с этим. Но нас будут интересовать другие ситуации, когда мы имеем 
  дело со словом, для которого есть несколько специальных случаев.</FONT></P>
<P>Если это слово <font face="Georgia"><b>class</b> или <b>interface</b>, то следующий 
  значащий элемент представляет имя класса или интерфейса, и оно помещается в 
  <b>classes</b> и <b>classMap</b>. Если это слово <b>import</b> или <b>package</b>, 
  то нам не нужна оставшаяся часть строки. Все остальное должно быть идентификатором 
  (которые нас интересуют) или ключевым словом (которые нас не интересуют, но 
  все они написаны в нижнем регистре, так что они не портят рассматриваемые нами 
  вещи). Они добавляются в <b>identMap</b>.</font></P>
<P><FONT FACE="Georgia">Метод <B>discardLine(&#160;)</B> является простым инструментом, 
  ищущим конец строки. Обратите внимание, что при каждом получении значащего элемента 
  вы должны проверять конец строки.</FONT></P>
<P><FONT FACE="Georgia">Метод <B>eatComments(&#160;)</B> вызывается всякий раз, 
  когда обнаружен слеш в главном цикле анализа. Однако это не обязательно означает, 
  что обнаружен комментарий, так что должен быть извлечен следующий значащий элемент, 
  чтобы проверить, не является ли он слешем (в этом случае строка пропускается) 
  или звездочкой. Но если это ни то, ни другое, это означает, что тот значащий 
  элемент, который вы только что извлекли, необходимо вернуть в главный цикл анализа! 
  К счастью, метод <a name="Index1460"></a><a name="Index1461"></a><b>pushBack(&#160;)</b> 
  позволяет вам &#8220;втолкнуть назад&#8221; текущий элемент во входной поток, 
  поэтому, когда главный цикл анализа вызовет <a name="Index1462"></a><a name="Index1463"></a><b>nextToken(&#160;)</b>, 
  то он получит то, что вы только что втолкнули обратно.</FONT></P>
<P><FONT FACE="Georgia">По соглашению, метод <b>classNames(&#160;)</b> производит 
  массив из всех имен, содержащихся в <b>classes</b>. Этот метод не используется 
  в программе, но он очень полезен для отладки.</FONT></P>
<P><FONT FACE="Georgia">Следующие два метода относятся к тем, в которых действительно 
  идет проверка. В <b>checkClassNames(&#160;)</b>, имя класса извлекается из <b>classMap</b> 
  (который, запомните, содержит только имена их этой директории, организованные 
  по именам файлов, так что имя файла может быть напечатано наряду с беспорядочными 
  именами классов). Это выполняется путем получения каждого ассоциированного <b>ArrayList</b>, 
  и прохода по нему в поисках элементов с меленькой первой буквой. Если такой 
  элемент найден, то печатается соответствующее сообщение об ошибке.</FONT></P>
<P><FONT FACE="Georgia">В <B>checkIdentNames(&#160;)</B>, используется аналогичный 
  подход; каждое имя идентификатора извлекается из <b>identMap</b>. Если имени 
  нет в списке <b>classes</b>, оно трактуется как идентификатор или ключевое слово. 
  Проверяется особый случай: если длина имени идентификатора больше или равна 
  трем, <i>и</i> все символы являются символами верхнего регистра, этот идентификатор 
  игнорируется, потому что, вероятно, это значение <b>static</b> <b>final</b>, 
  такое как <b>TT_EOF</b>. Конечно, это не идеальный алгоритм, но он означает, 
  что вы будете предупреждены обо всех идентификаторах, записанных в верхнем регистре, 
  и находящихся не на месте.</FONT></P>
<P><FONT FACE="Georgia">Вместо сообщения о каждом идентификаторе, который начинается 
  с большой буквы, этот метод хранит историю всего, о чем уже сообщил в <b>ArrayList</b> 
  вызов <b>reportSet(&#160;)</b>. Это трактует <b>ArrayList</b> , как &#8220;набор&#8221;, 
  который говорит вам, встречались ли эти экземпляры в наборе. Экземпляры производятся 
  соединением имени файла и идентификатора. Если элемента нет в наборе, он добавляется, 
  после чего делается сообщение.</FONT></P>
<P><FONT FACE="Georgia">Оставшаяся часть текста программы занимается методом <b>main(&#160;)</b>, 
  занимается обработкой аргументов командной строки и определяет, хотите ли вы 
  создать хранилище имен из стандартной библиотеки Java, или хотите проверить 
  написанный вами код. В обоих случаях он создает объект <b>ClassScanner</b>.</FONT></P>
<P><FONT FACE="Georgia">Независимо от того, строите ли вы хранилище, или используете 
  его, вы должны попробовать открыть существующее хранилище. При создании объекта 
  <A NAME="Index1464"></A><A NAME="Index1465"></A><B>File</B> и проверки существования, 
  вы можете решить, стоит ли открывать файл и загружать (<B>load(&#160;)</B>) 
  в <B>Properties</B> список классов <B>classes</B> внутри <B>ClassScanner</B>. 
  (Классы из хранилища добавляются, а не переписываются, к классам, найденным 
  конструктором <B>ClassScanner</B>.) Если вы передадите один аргумент командной 
  строки, это будет означать, что вы хотите выполнить проверку имен классов и 
  имен идентификаторов, но если вы передадите два аргумента (второй начинается 
  с &#8220;<B>-a</B>&#8221;), тем самым вы построите хранилище имен классов. В 
  этом случае открывается файл вывода и используется метод <B>Properties.save(&#160;)</B> 
  для записи списка в файл, наряду со строками, которые обеспечивают заголовочную 
  информацию файла.</FONT><A NAME="_Toc481064770"></A></P>
<A NAME="Heading399"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Резюме</H2>
</FONT> 
<P><FONT FACE="Georgia">Библиотека потоков ввода/вывода java удовлетворяет основным 
  требованиям: вы можете выполнить чтение и запись с консолью, файлом, блоком 
  памяти или даже через Internet (как вы увидите в <a href="Chapter15.html">Главе 
  15</a>). С помощью интерфейсов вы можете создать новые типы объектов ввода и 
  вывода. Вы также можете использовать простую расширяемость объектов потоков, 
  имея в виду, что метод <b>toString(&#160;)</b> вызывается автоматически, когда 
  вы передаете объект в метод, который ожидает <b>String</b> (ограничение Java 
  на &#8220;автоматическое преобразование типов&#8221;).</FONT></P>
<P><FONT FACE="Georgia">Есть несколько вопросов, оставшихся без ответа в документации 
  и дизайне библиотеке потоков ввода/вывода. Например, было бы неплохо, если бы 
  вы могли сказать, что хотите появление исключения при попытке перезаписи существующего 
  файла, когда вы открываете его для вывода &#8212; некоторые системы программирования 
  позволяют вам открыть файл только для вывода, только если он еще не существует. 
  В Java это означает, что вы способны использовать объект <b>File</b> для определения 
  существования файла, потому что, если вы откроете его, как <b>FileOutputStream</b> 
  или <b>FileWriter</b>, он всегда будет перезаписан.</FONT></P>
<P><FONT FACE="Georgia">Библиотека потоков ввода/вывода вызывает смешанные чувства; 
  она делает много работы и она компактна. Но если вы не готовы понимать шаблон 
  декоратора, то дизайн становится интуитивно не понятен, поэтому есть простор 
  для дополнительных исследований и обучения. Это то же не все: нет поддержки 
  определенного рода форматированного вывода, который поддерживают практически 
  все пакеты ввода/вывода других языков.</FONT></P>
<P><FONT FACE="Georgia">Однако, как только вы <i>поймете</i> шаблоны декорации 
  и начнете использование библиотеки в тех решениях, которые требуют гибкости, 
  вы сможете использовать выгоды дизайна, с точки зрения которого дополнительные 
  строки кода не будут вас беспокоить столь сильно.</FONT></P>
<P><FONT FACE="Georgia">Если вы не нашли того, что искали в этой главе (которая 
  было только введением и не преследовала цель всестороннего рассмотрения), то 
  за более глубоким обзором можете обратиться к книге <I>Java I/O</I>, Elliotte 
  Rusty Harold (O&#8217;Reilly, 1999).</FONT><A NAME="_Toc375545401"></A><A NAME="_Toc481064771"></A></P>
<DIV ALIGN="LEFT"></DIV>
<A NAME="Heading400"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Упражнения</H2>
</FONT><DIV ALIGN="LEFT">
  <P><font face="Georgia" size=2>Решения для выбранных упражнений могут быть найдены 
    в электронной документации <i>The Thinking in Java Annotated Solution Guide</i>, 
    доступной за малую плату на <i>www.BruceEckel.com</i>.</font></P>
</DIV>
<OL>
  <LI><FONT FACE="Georgia">Откройте текстовый файл так, чтобы вы смогли прочесть 
    его построчно. Читайте каждую строку, как <B>String</B>, и поместите этот 
    объект <B>String </B>в <B>LinkedList</B>. Распечатайте все строки из <B>LinkedList</B> 
    в обратном порядке.</FONT> 
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Измените Упражнение 1 
    так, чтобы имя читаемого фала принималось из командной строки.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Измените Упражнение 2, 
    чтобы была возможность открывать текстовый файл, в который вы могли бы писать. 
    Запишите строки из <B>ArrayList</B> вместе с номерами строк (не пробуйте использовать 
    класс &#8220;LineNumber&#8221;), в файл.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Измените Упражнение 2, 
    чтобы происходил перевод всех строк из <B>ArrayList</B> в верхний регистр, 
    а результат пошлите в <B>System.out</B>.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Измените Упражнение 2, 
    чтобы оно получало дополнительные аргументы из командной строки: слова, которые 
    необходимо найти в файле. Напечатайте строки, в которых есть эти слова.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Измените <B>DirList.java</B> 
    так, чтобы <B>FilenameFilter</B> на самом деле открывал каждый файл и принимал 
    файлы, основываясь на том, существует ли любой из аргументов командной строки 
    в этом файле.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Создайте класс, называемый 
    <B>SortedDirList</B> с конструктором, который принимает информацию о пути 
    к файлу и строит хранящийся список директории из файлов по этому пути. Создайте 
    два перегруженных метода <B>list(&#160;)</B>, которые будут производить либо 
    полный список, или подмножество из списка, основываясь на аргументе. Добавьте 
    метод <B>size(&#160;)</B>, который принимает имя файла и возвращает размер 
    этого файла.</FONT> 
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Измените <B>WordCount.java</B> 
    так, чтобы она производила алфавитную сортировку, используя инструмент из 
    <a href="Chapter09.html">Главы 9</a>.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Измените <B>WordCount.java</B> 
    так, чтобы она использовала классы, содержащие <B>String</B> и подсчитывающие 
    число хранящихся различных слова, а множество (<B>Set</B>) этих объектов содержало 
    список этих слов.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Измените <B>IOStreamDemo.java</B> 
    так, чтобы она использовала <B>LineNumberInputStream</B> для хранения истории 
    числа строк. Обратите внимание, что гораздо легче хранить историю программно.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Начиная с раздела 4 <B>IOStreamDemo.java</B>, 
    напишите программу, которая сравнивает производительность записи файла при 
    использовании буферизации и без нее при вводе/выводе.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Измените раздел <B>IOStreamDemo.java</B>, 
    чтобы подавить появление пробелов в строках, производимых первым вызовом <B>in5br.readLine(&#160;)</B>. 
    Сделайте это, используя цикл <B>while</B> и <B>readChar(&#160;)</B>.</FONT>
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">Восстановите программу 
    <B>CADState.java</B>, как описано в тексте.</FONT> 
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">В <B>Blips.java</B>, скопируйте 
    файл и переименуйте его в <B>BlipCheck.java</B>, затем переименуйте класс 
    <B>Blip2</B> в <B>BlipCheck </B>(сделав его <B>public</B> и удалив публичный 
    код из класса <B>Blips</B>). Удалите маркер <B>//!</B> в файле и выполните 
    программу, включая раздражающие строки. Далее, закомментируйте конструктор 
    по умолчанию для <B>BlipCheck</B>. Запустите программу и объясните почему 
    она работает. Обратите внимание, что после компиляции вы должны выполнить 
    программу с помощью строки &#8220;<B>java Blips</B>&#8221;, потому что метод 
    <B>main(&#160;)</B> все еще находится в классе <B>Blips</B>.</FONT> 
  <LI><FONT FACE="Verdana"> </FONT><FONT FACE="Georgia">В <B>Blip3.java</B>, закомментируйте 
    две строки после фразы &#8220;Вы обязаны сделать это:&#8221; и запустите программу. 
    Объясните результат и почему он отличается от того, когда эти две строки присутствуют 
    в программе.</FONT> 
  <LI><FONT FACE="Georgia">(Промежуточное) В <a href="Chapter08.html">Главе 8</a> 
    найдите пример <B>GreenhouseControls.java</B>, который состоит из трех файлов. 
    В <B>GreenhouseControls.java</B> внутренний класс <B>Restart(&#160;)</B> имеет 
    жестко привязанный набор событий. Измените программу так, чтобы она читала 
    события и относительное время из текстового файла. (Рекомендация: Используйте 
    шаблон разработки <I>метода производств</I>а для построения событий <I> </I> 
    &#8212; Смотрите <I>Thinking in Patterns with Java</I>, доступную на <I>www.BruceEckel.com.</I>)</FONT> 
</OL>
<HR>
<P><A NAME="fn57">[57]</a><FONT FACE="Georgia" SIZE=2> <I>Design Patterns</I>, 
  Erich Gamma <I>et al.</I>, Addison-Wesley 1995.</FONT></P>
<P><A NAME="fn58">[58]</a><FONT FACE="Georgia" SIZE=2> XML является другим способом 
  решения проблемы перемещения данных между различными платформами, которая не 
  зависит от того, есть ли Java на всех платформах. Однако инструментарий Java 
  поддерживает XML.</FONT></P>
<P><A NAME="fn59">[59]</a><FONT FACE="Georgia" SIZE=2> <a href="Chapter13.html">Глава 
  13</a> покажет даже более последовательное решение этого: GUI программу со скроллируемой 
  текстовой областью.</FONT></P>
<DIV ALIGN="CENTER"> <FONT FACE="Verdana" size = "-1"> </FONT><font face="Verdana" size = "-1">[ 
  <a href="Chapter10.html">Предыдущая глава </a> ] [ <a href="SimpleContents.html">Оглавление</a> 
  ] [ <a href="Contents.html">Содержание</a> ] [ <a href="DocIndex.html">Индекс</a> 
  ] [ <a href="Chapter12.html">Следующая глава </a> ]</font> </DIV>

</BODY>

</HTML>
